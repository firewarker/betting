<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BettingPro - AI Betting Intelligence</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #0a0e17;
      --bg-card: #141d2f;
      --bg-card-light: #1a2642;
      --bg-input: #0f172a;
      --accent-cyan: #f59e0b;
      --accent-blue: #10b981;
      --accent-green: #22c55e;
      --accent-yellow: #fbbf24;
      --accent-red: #ef4444;
      --accent-purple: #8b5cf6;
      --accent-gold: #f59e0b;
      --accent-emerald: #10b981;
      --text-white: #ffffff;
      --text-gray: #94a3b8;
      --text-dark: #64748b;
      --border: rgba(255,255,255,0.08);
      --glow-cyan: 0 0 20px rgba(245, 158, 11, 0.3);
      --glow-gold: 0 0 25px rgba(245, 158, 11, 0.4);
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, sans-serif;
      background: var(--bg-dark);
      background-image: radial-gradient(ellipse at top, rgba(245,158,11,0.05) 0%, transparent 50%),
                        radial-gradient(ellipse at bottom right, rgba(16,185,129,0.05) 0%, transparent 50%);
      color: var(--text-white);
      min-height: 100vh;
      padding-bottom: 100px;
    }
    .header {
      background: rgba(12,18,34,0.95);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--border);
      padding: 12px 24px;
      position: sticky;
      top: 0;
      z-index: 100;
    }
    .header-inner {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
    }
    .brand { display: flex; align-items: center; gap: 12px; }
    .brand-icon {
      width: 40px; height: 40px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      border-radius: 10px;
      display: flex; align-items: center; justify-content: center;
      font-size: 1.3rem;
    }
    .brand-name {
      font-size: 1.3rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .header-right { display: flex; align-items: center; gap: 16px; }
    .status-bar { display: flex; gap: 12px; }
    .status-item { display: flex; align-items: center; gap: 6px; font-size: 0.7rem; color: var(--text-dark); }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--text-dark); }
    .status-dot.online { background: var(--accent-green); box-shadow: 0 0 8px var(--accent-green); }
    .status-dot.loading { background: var(--accent-yellow); animation: blink 1s infinite; }
    @keyframes blink { 0%,100%{opacity:1} 50%{opacity:.3} }
    .slip-badge {
      display: flex; align-items: center; gap: 8px;
      padding: 8px 16px;
      background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
      border-radius: 20px;
      font-size: 0.8rem; font-weight: 700;
      cursor: pointer;
    }
    .slip-badge:hover { transform: scale(1.05); }
    .main { max-width: 1400px; margin: 0 auto; padding: 24px; }
    .date-tabs {
      display: flex; gap: 8px; margin-bottom: 20px; flex-wrap: wrap;
    }
    .date-tab {
      padding: 10px 20px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.85rem; font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .date-tab:hover { border-color: var(--accent-cyan); color: var(--text-white); }
    .date-tab.active {
      background: linear-gradient(135deg, rgba(34,211,238,0.2), rgba(59,130,246,0.2));
      border-color: var(--accent-cyan);
      color: var(--accent-cyan);
    }
    .panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .panel-title { font-size: 1rem; font-weight: 700; margin-bottom: 16px; color: var(--accent-cyan); }
    .select-field {
      width: 100%;
      padding: 14px 18px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-white);
      font-size: 0.95rem;
      cursor: pointer;
    }
    .select-field:focus { outline: none; border-color: var(--accent-cyan); }
    .matches-list { display: flex; flex-direction: column; gap: 10px; }
    .match-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 18px;
      background: var(--bg-card-light);
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .match-item:hover {
      border-color: var(--accent-cyan);
      transform: translateX(4px);
    }
    .match-item-left { display: flex; align-items: center; gap: 14px; flex: 1; min-width: 0; }
    .match-item-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      color: var(--accent-cyan);
      min-width: 45px;
    }
    .match-item-teams { font-weight: 600; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .match-item-badge {
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.65rem;
      font-weight: 700;
      background: var(--bg-input);
      color: var(--text-gray);
      flex-shrink: 0;
    }
    .back-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 20px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.85rem;
      cursor: pointer;
      margin-bottom: 20px;
    }
    .back-btn:hover { border-color: var(--accent-cyan); color: var(--accent-cyan); }
    .analysis-hero {
      background: linear-gradient(145deg, var(--bg-card), var(--bg-card-light));
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 30px;
      margin-bottom: 20px;
      text-align: center;
    }
    .hero-league { font-size: 0.8rem; color: var(--text-dark); margin-bottom: 20px; }
    .hero-match { display: flex; align-items: center; justify-content: center; gap: 24px; margin-bottom: 20px; flex-wrap: wrap; }
    .hero-team { display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .hero-team-logo { width: 60px; height: 60px; object-fit: contain; }
    .hero-team-logo-fallback {
      width: 60px; height: 60px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      border-radius: 14px;
      display: flex; align-items: center; justify-content: center;
      font-weight: 700; font-size: 1rem;
    }
    .hero-team-name { font-size: 1rem; font-weight: 700; max-width: 120px; text-align: center; }
    .hero-prediction { display: flex; align-items: center; gap: 10px; }
    .hero-score-box {
      width: 50px; height: 50px;
      background: var(--bg-input);
      border: 2px solid var(--accent-cyan);
      border-radius: 12px;
      display: flex; align-items: center; justify-content: center;
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.5rem; font-weight: 700;
    }
    .hero-vs { padding: 6px 12px; background: var(--accent-blue); border-radius: 6px; font-weight: 700; font-size: 0.8rem; }
    .analysis-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; margin-bottom: 20px; }
    .analysis-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
    }
    .analysis-card.wide { grid-column: 1 / -1; }
    .card-title {
      display: flex; align-items: center; gap: 10px;
      margin-bottom: 16px;
      font-size: 0.9rem; font-weight: 700;
    }
    .card-title-icon {
      width: 32px; height: 32px;
      background: linear-gradient(135deg, rgba(34,211,238,0.2), rgba(59,130,246,0.2));
      border-radius: 8px;
      display: flex; align-items: center; justify-content: center;
      font-size: 1rem;
    }
    .card-title-badge {
      margin-left: auto;
      padding: 4px 10px;
      background: var(--accent-cyan);
      border-radius: 6px;
      font-size: 0.7rem; font-weight: 700;
      color: var(--bg-dark);
    }
    .prob-row { display: flex; align-items: center; gap: 10px; margin-bottom: 12px; }
    .prob-row:last-child { margin-bottom: 0; }
    .prob-label { width: 80px; font-size: 0.8rem; color: var(--text-gray); }
    .prob-bar-track { flex: 1; height: 8px; background: var(--bg-input); border-radius: 4px; overflow: hidden; }
    .prob-bar-fill { height: 100%; border-radius: 4px; }
    .prob-bar-fill.cyan { background: linear-gradient(90deg, var(--accent-cyan), var(--accent-blue)); }
    .prob-bar-fill.green { background: linear-gradient(90deg, var(--accent-green), #34d399); }
    .prob-bar-fill.yellow { background: linear-gradient(90deg, var(--accent-yellow), #fcd34d); }
    .prob-bar-fill.purple { background: linear-gradient(90deg, var(--accent-purple), #c084fc); }
    .prob-value {
      width: 50px; text-align: right;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem; font-weight: 600;
      color: var(--accent-cyan);
    }
    .stat-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
    .stat-box {
      background: var(--bg-card-light);
      border-radius: 10px;
      padding: 12px;
      text-align: center;
    }
    .stat-box-label { font-size: 0.65rem; color: var(--text-dark); margin-bottom: 4px; text-transform: uppercase; }
    .stat-box-value { font-family: 'JetBrains Mono', monospace; font-size: 1.2rem; font-weight: 700; color: var(--accent-cyan); }
    .stat-box-sub { font-size: 0.6rem; color: var(--text-dark); margin-top: 2px; }
    .scores-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 8px; }
    .score-box {
      background: var(--bg-card-light);
      border-radius: 8px;
      padding: 10px 6px;
      text-align: center;
    }
    .score-box.highlight { background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue)); }
    .score-box-value { font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; font-weight: 700; }
    .score-box-prob { font-size: 0.6rem; color: var(--text-dark); margin-top: 2px; }
    .score-box.highlight .score-box-prob { color: rgba(255,255,255,0.8); }
    
    /* MG BOX SOTTO RISULTATI ESATTI */
    .mg-compact-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }
    .mg-compact-box {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      text-align: center;
    }
    .mg-compact-label { font-size: 0.7rem; color: var(--text-dark); margin-bottom: 4px; font-weight: 600; }
    .mg-compact-range { font-size: 0.95rem; font-weight: 700; color: var(--accent-cyan); }
    .mg-compact-prob { font-size: 0.75rem; color: var(--accent-green); margin-top: 2px; }
    
    /* COMBO SUGGERITE */
    .combo-panel {
      background: linear-gradient(135deg, var(--bg-card), var(--bg-card-light));
      border: 2px solid var(--accent-purple);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 20px;
    }
    .combo-title { font-size: 1.1rem; font-weight: 700; color: var(--accent-purple); margin-bottom: 16px; }
    .combo-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 12px; }
    .combo-card {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    .combo-card:hover { border-color: var(--accent-purple); transform: translateY(-2px); }
    .combo-card.selected { border-color: var(--accent-green); background: rgba(16,185,129,0.1); }
    .combo-value { font-size: 1rem; font-weight: 700; margin-bottom: 8px; }
    .combo-stats { display: flex; justify-content: center; gap: 12px; font-size: 0.75rem; }
    .combo-prob { color: var(--accent-cyan); }
    .combo-odds { color: var(--accent-green); }
    
    /* MULTIGOAL GRID */
    .multigoal-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
      gap: 10px;
    }
    .multigoal-box {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 8px;
      text-align: center;
      transition: all 0.2s;
    }
    .multigoal-box.best {
      border-color: var(--accent-green);
      background: rgba(16,185,129,0.1);
    }
    .multigoal-range {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 4px;
    }
    .multigoal-prob {
      font-size: 0.9rem;
      color: var(--accent-cyan);
      font-weight: 600;
    }
    .multigoal-quota {
      font-size: 0.75rem;
      color: var(--accent-green);
      margin-top: 2px;
    }
    
    /* TEMPO GOL */
    .tempo-highlight {
      background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(59,130,246,0.1));
      border: 1px solid var(--accent-purple);
      border-radius: 10px;
      padding: 12px;
      margin-top: 12px;
      text-align: center;
      font-size: 0.85rem;
    }
    .tempo-highlight strong {
      color: var(--accent-cyan);
      margin: 0 6px;
    }
    .tempo-prob {
      color: var(--accent-green);
      font-weight: 600;
    }
    
    /* FORM DISPLAY */
    .form-display {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .form-team {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
    }
    .form-team:last-child { border-bottom: none; }
    .form-team-name {
      font-weight: 600;
      font-size: 0.85rem;
    }
    .form-string {
      display: flex;
      gap: 4px;
    }
    .form-w, .form-d, .form-l {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      font-weight: 700;
    }
    .form-w { background: var(--accent-green); color: white; }
    .form-d { background: var(--accent-yellow); color: #1a1a2e; }
    .form-l { background: var(--accent-red); color: white; }
    
    /* CLASSIFICA E MOTIVAZIONE */
    .standings-card {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 8px;
    }
    .standings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .standings-position {
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--accent-cyan);
    }
    .standings-position sup {
      font-size: 0.7rem;
      color: var(--text-dark);
    }
    .motivation-badge {
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.7rem;
      font-weight: 600;
    }
    .motivation-badge.gold { background: rgba(255,215,0,0.2); color: gold; border: 1px solid gold; }
    .motivation-badge.cyan { background: rgba(6,182,212,0.2); color: var(--accent-cyan); border: 1px solid var(--accent-cyan); }
    .motivation-badge.blue { background: rgba(59,130,246,0.2); color: var(--accent-blue); border: 1px solid var(--accent-blue); }
    .motivation-badge.red { background: rgba(239,68,68,0.2); color: var(--accent-red); border: 1px solid var(--accent-red); }
    .motivation-badge.orange { background: rgba(249,115,22,0.2); color: #f97316; border: 1px solid #f97316; }
    .motivation-badge.gray { background: rgba(156,163,175,0.2); color: var(--text-dark); border: 1px solid var(--border); }
    .standings-stats {
      display: flex;
      gap: 12px;
      font-size: 0.75rem;
      color: var(--text-dark);
    }
    .standings-stat {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    /* INFORTUNATI */
    .injuries-card {
      background: rgba(239,68,68,0.05);
      border: 1px solid rgba(239,68,68,0.3);
      border-radius: 12px;
      padding: 12px;
    }
    .injuries-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-weight: 600;
      color: var(--accent-red);
    }
    .injuries-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .injury-chip {
      background: rgba(239,68,68,0.1);
      border: 1px solid rgba(239,68,68,0.3);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.7rem;
      color: var(--text);
    }
    .no-injuries {
      color: var(--accent-green);
      font-size: 0.8rem;
    }
    
    /* PANNELLO IMPOSTAZIONI */
    .settings-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 320px;
      height: 100vh;
      background: var(--bg-card);
      border-left: 1px solid var(--border);
      padding: 20px;
      z-index: 1000;
      overflow-y: auto;
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }
    .settings-panel.open { transform: translateX(0); }
    .settings-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 999;
      display: none;
    }
    .settings-overlay.open { display: block; }
    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid var(--border);
    }
    .settings-title {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--text);
    }
    .settings-close {
      background: none;
      border: none;
      color: var(--text-dark);
      font-size: 1.5rem;
      cursor: pointer;
    }
    .settings-section {
      margin-bottom: 20px;
    }
    .settings-section-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--accent-cyan);
      margin-bottom: 12px;
    }
    .settings-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .settings-label {
      font-size: 0.85rem;
      color: var(--text);
    }
    .settings-input {
      width: 70px;
      padding: 6px 10px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      text-align: center;
    }
    .settings-toggle {
      position: relative;
      width: 44px;
      height: 24px;
      background: var(--bg-input);
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .settings-toggle.active { background: var(--accent-green); }
    .settings-toggle::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }
    .settings-toggle.active::after { transform: translateX(20px); }
    
    /* STORICO WIN RATE */
    .history-chart {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-top: 12px;
    }
    .history-bars {
      display: flex;
      align-items: flex-end;
      gap: 4px;
      height: 80px;
      margin-bottom: 8px;
    }
    .history-bar {
      flex: 1;
      background: var(--accent-cyan);
      border-radius: 4px 4px 0 0;
      min-height: 4px;
      position: relative;
    }
    .history-bar.won { background: var(--accent-green); }
    .history-bar.lost { background: var(--accent-red); }
    .history-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.65rem;
      color: var(--text-dark);
    }
    
    /* WIN RATE PER SEGNO */
    .winrate-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 16px;
    }
    .winrate-item {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
    }
    .winrate-label {
      font-weight: 700;
      font-size: 0.85rem;
      color: var(--text-white);
      margin-bottom: 6px;
    }
    .winrate-stats {
      display: flex;
      gap: 12px;
      font-size: 0.75rem;
      color: var(--text-gray);
      margin-bottom: 8px;
    }
    .winrate-won { color: var(--accent-green); }
    .winrate-lost { color: var(--accent-red); }
    .winrate-bar {
      height: 8px;
      background: var(--bg-dark);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 4px;
    }
    .winrate-bar-fill {
      height: 100%;
      border-radius: 4px;
      transition: width 0.3s;
    }
    .winrate-bar-fill.good { background: linear-gradient(90deg, var(--accent-green), var(--accent-cyan)); }
    .winrate-bar-fill.bad { background: linear-gradient(90deg, var(--accent-red), var(--accent-yellow)); }
    .winrate-percent {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      font-weight: 700;
      color: var(--accent-cyan);
      text-align: right;
    }
    .winrate-summary {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      padding: 12px;
      background: var(--bg-card);
      border-radius: 10px;
      border: 1px solid var(--border);
    }
    .winrate-summary-item {
      text-align: center;
    }
    .winrate-summary-item span {
      display: block;
      font-size: 0.65rem;
      color: var(--text-dark);
      margin-bottom: 2px;
    }
    .winrate-summary-item strong {
      font-size: 1rem;
      font-weight: 700;
    }
    
    /* SETTINGS BUTTON */
    .settings-btn {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      color: var(--text);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.85rem;
      transition: all 0.2s;
    }
    .settings-btn:hover {
      border-color: var(--accent-cyan);
      background: rgba(6,182,212,0.1);
    }
    
    /* PRONOSTICI AI */
    .predictions-panel {
      background: linear-gradient(135deg, var(--bg-card), var(--bg-card-light));
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 20px;
    }
    .predictions-header { text-align: center; margin-bottom: 20px; }
    .predictions-title {
      font-size: 1.3rem; font-weight: 800; margin-bottom: 8px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .predictions-subtitle { font-size: 0.8rem; color: var(--text-dark); }
    .predictions-legend { display: flex; justify-content: center; gap: 16px; margin-top: 10px; font-size: 0.7rem; }
    .legend-item { display: flex; align-items: center; gap: 4px; }
    .legend-dot { width: 10px; height: 10px; border-radius: 50%; }
    .legend-dot.high { background: var(--accent-green); }
    .legend-dot.mid { background: var(--accent-yellow); }
    .legend-dot.low { background: var(--accent-red); }
    .predictions-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 12px; }
    .prediction-card {
      background: var(--bg-input);
      border: 2px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .prediction-card:hover { border-color: var(--accent-cyan); transform: translateY(-2px); }
    .prediction-card.selected { border-color: var(--accent-green); background: rgba(16,185,129,0.15); }
    .prediction-card.selected::after {
      content: '‚úì';
      position: absolute;
      top: 8px; right: 8px;
      width: 20px; height: 20px;
      background: var(--accent-green);
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 0.7rem; font-weight: 700;
    }
    .prediction-market { font-size: 0.65rem; color: var(--text-dark); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px; }
    .prediction-value { font-size: 1.1rem; font-weight: 800; margin-bottom: 8px; }
    .prediction-prob {
      display: inline-flex; align-items: center; gap: 4px;
      padding: 4px 10px;
      border-radius: 12px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem; font-weight: 600;
    }
    .prediction-prob.high { background: rgba(16,185,129,0.2); color: var(--accent-green); }
    .prediction-prob.mid { background: rgba(251,191,36,0.2); color: var(--accent-yellow); }
    .prediction-prob.low { background: rgba(239,68,68,0.2); color: var(--accent-red); }
    
    /* HOME SECTIONS - Picks del giorno */
    .home-sections { display: flex; flex-direction: column; gap: 20px; margin-bottom: 24px; }
    .picks-section {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      position: relative;
      overflow: hidden;
    }
    .picks-section::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 3px;
    }
    .picks-section.raddoppi::before { background: linear-gradient(90deg, var(--accent-green), var(--accent-cyan)); }
    .picks-section.gg::before { background: linear-gradient(90deg, var(--accent-yellow), var(--accent-green)); }
    .picks-section.over::before { background: linear-gradient(90deg, var(--accent-cyan), var(--accent-blue)); }
    .picks-section.pareggi::before { background: linear-gradient(90deg, var(--accent-purple), var(--accent-blue)); }
    .picks-section.over1t::before { background: linear-gradient(90deg, var(--accent-red), var(--accent-yellow)); }
    
    /* ADVICE TABS */
    .advice-section {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 0;
      margin-bottom: 20px;
      overflow: hidden;
    }
    .advice-tabs {
      display: flex;
      gap: 0;
      border-bottom: 1px solid var(--border);
      padding: 0;
    }
    .advice-tab {
      flex: 1;
      padding: 16px 20px;
      background: transparent;
      border: none;
      color: var(--text-gray);
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      border-bottom: 3px solid transparent;
    }
    .advice-tab:hover {
      color: var(--text-white);
      background: rgba(6, 182, 212, 0.05);
    }
    .advice-tab.active {
      color: var(--accent-cyan);
      border-bottom-color: var(--accent-cyan);
      background: rgba(6, 182, 212, 0.1);
    }
    .advice-content {
      padding: 20px;
      display: none;
    }
    .advice-content.active { display: block; }
    .advice-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 12px;
    }
    .advice-card {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 14px 16px;
      background: var(--bg-card-light);
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .advice-card:hover {
      border-color: var(--accent-cyan);
      transform: translateX(4px);
    }
    .advice-card-match {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-white);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .advice-card-league {
      font-size: 0.7rem;
      color: var(--text-dark);
    }
    .advice-card-pick {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .advice-card-value {
      font-weight: 700;
      color: var(--accent-cyan);
      font-size: 0.9rem;
    }
    .advice-card-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;
      font-weight: 800;
      color: var(--accent-green);
    }
    
    /* RADDOPPI COMBINATI */
    .raddoppi-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 14px; }
    .raddoppio-card {
      background: linear-gradient(145deg, var(--bg-card-light), var(--bg-input));
      border: 2px solid var(--accent-green);
      border-radius: 14px;
      padding: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .raddoppio-card:hover { transform: translateY(-3px); box-shadow: 0 8px 24px rgba(16,185,129,0.2); }
    .raddoppio-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .raddoppio-badge {
      background: var(--accent-green);
      color: var(--bg-dark);
      padding: 4px 10px;
      border-radius: 8px;
      font-size: 0.7rem;
      font-weight: 700;
    }
    .raddoppio-odds {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--accent-cyan);
    }
    .raddoppio-bets { display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; }
    .raddoppio-bet {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: var(--bg-input);
      border-radius: 8px;
    }
    .raddoppio-match { font-size: 0.8rem; color: var(--text-gray); }
    .raddoppio-pick { 
      font-weight: 700; 
      color: var(--accent-cyan);
      padding: 2px 8px;
      background: rgba(34,211,238,0.15);
      border-radius: 4px;
      font-size: 0.8rem;
    }
    .raddoppio-footer { text-align: center; }
    .raddoppio-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      color: var(--accent-green);
      font-weight: 600;
    }

    /* AI CONSIGLIO */
    .ai-advice {
      background: linear-gradient(135deg, rgba(168,85,247,0.15), rgba(34,211,238,0.15));
      border: 2px solid var(--accent-purple);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 20px;
      position: relative;
      overflow: hidden;
    }
    .ai-advice::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--accent-purple), var(--accent-cyan), var(--accent-green));
    }
    .ai-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .ai-icon {
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
    }
    .ai-title-group { flex: 1; }
    .ai-title {
      font-size: 1.1rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .ai-subtitle { font-size: 0.75rem; color: var(--text-dark); }
    .ai-confidence {
      padding: 6px 14px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 700;
    }
    .ai-confidence.high { background: rgba(16,185,129,0.2); color: var(--accent-green); }
    .ai-confidence.medium { background: rgba(251,191,36,0.2); color: var(--accent-yellow); }
    .ai-confidence.low { background: rgba(239,68,68,0.2); color: var(--accent-red); }
    .ai-pick {
      background: var(--bg-input);
      border-radius: 16px;
      padding: 20px;
      text-align: center;
      margin-bottom: 16px;
    }
    .ai-pick-label { font-size: 0.7rem; color: var(--text-dark); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
    .ai-pick-value {
      font-size: 1.8rem;
      font-weight: 800;
      color: var(--accent-cyan);
      margin-bottom: 4px;
    }
    .ai-pick-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1rem;
      color: var(--accent-green);
    }
    .ai-reasoning {
      background: var(--bg-card-light);
      border-radius: 12px;
      padding: 16px;
    }
    .ai-reasoning-title {
      font-size: 0.75rem;
      color: var(--text-dark);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .ai-reasoning-list { display: flex; flex-direction: column; gap: 8px; }
    .ai-reason {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.85rem;
      color: var(--text-gray);
    }
    .ai-reason-icon { font-size: 1rem; }
    .ai-reason.positive { color: var(--accent-green); }
    .ai-reason.negative { color: var(--accent-red); }
    .ai-reason.neutral { color: var(--accent-yellow); }
    .ai-alternatives {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    .ai-alt-title { font-size: 0.7rem; color: var(--text-dark); margin-bottom: 10px; }
    .ai-alt-grid { display: flex; gap: 10px; flex-wrap: wrap; }
    .ai-alt-chip {
      padding: 8px 14px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 20px;
      font-size: 0.8rem;
      color: var(--text-gray);
      cursor: pointer;
      transition: all 0.2s;
    }
    .ai-alt-chip:hover { border-color: var(--accent-cyan); color: var(--text-white); }

    /* DUAL ADVICE LAYOUT */
    .dual-advice-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }
    @media (max-width: 968px) {
      .dual-advice-container { grid-template-columns: 1fr; }
    }

    /* STATISTICAL ADVICE */
    .statistical-advice {
      background: linear-gradient(135deg, rgba(34,211,238,0.15), rgba(16,185,129,0.15));
      border: 2px solid var(--accent-cyan);
      border-radius: 20px;
      padding: 24px;
      position: relative;
      overflow: hidden;
    }
    .statistical-advice::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--accent-cyan), var(--accent-green), var(--accent-yellow));
    }

    /* STORICO VARIAZIONI PRONOSTICI */
    .history-section {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(59, 130, 246, 0.08));
      border: 1px solid rgba(139, 92, 246, 0.25);
      border-radius: 16px;
      padding: 20px;
      margin-top: 20px;
      margin-bottom: 20px;
    }
    .history-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .history-icon {
      width: 44px;
      height: 44px;
      background: linear-gradient(135deg, var(--accent-purple), #3b82f6);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.3rem;
    }
    .history-title h3 {
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-white);
    }
    .history-title p {
      font-size: 0.7rem;
      color: var(--text-dark);
    }
    .history-timeline {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .history-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
    }
    .history-item.current {
      border-color: var(--accent-gold);
      background: rgba(245, 158, 11, 0.08);
    }
    .history-item.significant {
      border-color: var(--accent-yellow);
      background: rgba(251, 191, 36, 0.08);
    }
    .history-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      color: var(--text-dark);
      min-width: 50px;
    }
    .history-pick {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .history-pick-value {
      font-weight: 700;
      color: var(--accent-gold);
      font-size: 0.85rem;
    }
    .history-pick-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      padding: 2px 8px;
      background: rgba(16, 185, 129, 0.2);
      color: var(--accent-green);
      border-radius: 4px;
    }
    .history-change {
      font-size: 0.65rem;
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: 600;
      white-space: nowrap;
    }
    .history-change.first { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
    .history-change.minor { background: rgba(100, 116, 139, 0.2); color: var(--text-gray); }
    .history-change.significant { background: rgba(251, 191, 36, 0.2); color: var(--accent-yellow); }
    .history-change.major { background: rgba(239, 68, 68, 0.2); color: var(--accent-red); }
    .history-empty {
      text-align: center;
      padding: 20px;
      color: var(--text-dark);
      font-size: 0.85rem;
    }
    .history-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    .history-stat {
      text-align: center;
    }
    .history-stat-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--accent-purple);
    }
    .history-stat-label {
      font-size: 0.6rem;
      color: var(--text-dark);
      text-transform: uppercase;
    }

    /* TRACKER BUTTONS */
    .track-btn {
      background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 10px;
      font-weight: 700;
      cursor: pointer;
      margin-top: 12px;
      width: 100%;
      font-size: 0.95rem;
      transition: all 0.3s;
    }
    .track-btn:hover { transform: scale(1.02); box-shadow: 0 4px 15px rgba(16,185,129,0.4); }
    .track-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    .track-btn.tracked { background: var(--text-dark); }

    .loading { display: flex; flex-direction: column; align-items: center; padding: 40px; }
    .spinner { width: 40px; height: 40px; border: 3px solid var(--border); border-top-color: var(--accent-cyan); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 12px; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-text { color: var(--text-gray); font-size: 0.9rem; }
    .empty { text-align: center; padding: 40px; color: var(--text-dark); }
    .empty-icon { font-size: 2.5rem; margin-bottom: 12px; }
    
    @media (max-width: 768px) {
      .main { padding: 16px; }
      .header { padding: 10px 16px; }
      .brand-name { font-size: 1.1rem; }
      .status-bar { font-size: 0.65rem; }
      .hero-match { gap: 16px; }
      .hero-team-logo, .hero-team-logo-fallback { width: 50px; height: 50px; }
      .hero-score-box { width: 40px; height: 40px; font-size: 1.2rem; }
      .analysis-grid { grid-template-columns: 1fr; }
      .predictions-grid { grid-template-columns: repeat(2, 1fr); }
      .stat-grid { grid-template-columns: repeat(3, 1fr); }
      .combo-grid { grid-template-columns: repeat(2, 1fr); }
      .advice-grid { grid-template-columns: 1fr; }
      .slip-floating { flex-wrap: wrap; gap: 10px; padding: 10px 16px; }
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <script>
    // ===================================================
    // BETTINGPRO v6 - SENZA LIVE, CON CONSIGLI DEL GIORNO
    // ===================================================
    
    const CONFIG = {
      API_FOOTBALL: {
        key: 'aeb2864a3d4dbb8395fa53c83a876a93',
        baseURL: 'https://v3.football.api-sports.io'
      },
      FOOTYSTATS: {
        key: 'bec59b6f83404b0bd79c40076be71f6f3abec62afdacf5eeba296f2357993f3e',
        baseURL: 'https://api.footystats.org'
      },
      FIREBASE: {
        url: 'https://bettingpro-d0125-default-rtdb.europe-west1.firebasedatabase.app'
      }
    };

    // Generate unique user ID
    const getUserId = () => {
      let id = localStorage.getItem('bettingpro_uid');
      if (!id) {
        id = 'user_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('bettingpro_uid', id);
      }
      return id;
    };
    const USER_ID = getUserId();

    let state = {
      view: 'leagues',
      selectedDate: 0,
      leagues: [],
      matches: [],
      selectedLeague: null,
      selectedMatch: null,
      analysis: null,
      loading: false,
      api: { 
        football: localStorage.getItem('api_football_status') || 'offline', 
        footystats: localStorage.getItem('api_footystats_status') || 'offline'
      },
      fsData: new Map(),
      slip: [],
      slipModal: false,
      // Picks del giorno
      dailyPicks: { raddoppi: [], gg: [], over25: [], pareggi: [], over1T: [] },
      // Consigli del giorno (new)
      dayAdvices: { gg: [], one: [], two: [], x: [] },
      adviceTab: 'gg', // tab attivo
      // Money Management
      money: {
        bankroll: parseFloat(localStorage.getItem('bp2_bankroll')) || 100,
        target: parseFloat(localStorage.getItem('bp2_target')) || 500,
        totalBets: parseInt(localStorage.getItem('bp2_totalbets')) || 10,
        currentBet: parseInt(localStorage.getItem('bp2_currentbet')) || 1,
        currentOdds: parseFloat(localStorage.getItem('bp2_odds')) || 1.80,
        history: JSON.parse(localStorage.getItem('bp2_history') || '[]')
      },
      // Tracking Pronostici
      trackedBets: JSON.parse(localStorage.getItem('bp2_tracked') || '[]'),
      // Cache Classifica e Infortunati
      standingsCache: new Map(),
      injuriesCache: new Map(),
      // Impostazioni
      settings: JSON.parse(localStorage.getItem('bp2_settings') || JSON.stringify({
        thresholds: {
          '1': 50,
          'X': 28,
          '2': 50,
          'GG': 55,
          'Over 2.5': 50,
          'Over 1.5': 65
        },
        showInjuries: true,
        showStandings: true,
        autoRefresh: true
      })),
      settingsOpen: false,
      statsView: false,
      // Storico variazioni
      predictionHistory: JSON.parse(localStorage.getItem('bp2_prediction_history') || '{}')
    };

    // === UTILITIES ===
    const esc = t => String(t || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]));
    const clamp = (min, v, max) => Math.max(min, Math.min(max, v));
    const formatTime = d => d ? new Date(d).toLocaleTimeString('it-IT', {hour:'2-digit', minute:'2-digit'}) : '--:--';
    const formatDate = d => d ? new Date(d).toLocaleDateString('it-IT', {day:'2-digit', month:'2-digit'}) : '--/--';
    const formatDateFull = d => d ? new Date(d).toLocaleDateString('it-IT', {weekday:'short', day:'2-digit', month:'short'}) : '';
        const getInitials = n => n ? n.split(' ').map(w => w[0]).join('').slice(0,3).toUpperCase() : '??';
    
    function getDateString(offset = 0) {
      const d = new Date();
      d.setDate(d.getDate() + offset);
      return d.toISOString().split('T')[0];
    }
    
    function getDateLabel(offset) {
      if (offset === -1) return 'Ieri';
      if (offset === 0) return 'Oggi';
      if (offset === 1) return 'Domani';
      if (offset === 2) return 'Dopodomani';
      return '';
    }

    // Poisson
    const factorial = n => { let r = 1; for (let i = 2; i <= n; i++) r *= i; return r; };
    const poisson = (l, k) => l <= 0 ? (k === 0 ? 1 : 0) : (Math.pow(l, k) * Math.exp(-l)) / factorial(k);

    // === STORICO VARIAZIONI PRONOSTICI ===
    
    function savePredictionToHistory(matchId, matchName, prediction) {
      const key = String(matchId);
      const now = new Date();
      const timestamp = now.toLocaleTimeString('it-IT', {hour:'2-digit', minute:'2-digit'});
      const fullTimestamp = now.getTime();
      
      if (!state.predictionHistory[key]) {
        state.predictionHistory[key] = {
          matchName: matchName,
          date: getDateString(state.selectedDate),
          predictions: []
        };
      }
      
      const history = state.predictionHistory[key].predictions;
      const lastPred = history.length > 0 ? history[history.length - 1] : null;
      
      let changeType = 'first';
      if (lastPred) {
        const pickChanged = lastPred.pick !== prediction.pick;
        const probDiff = Math.abs(prediction.prob - lastPred.prob);
        
        if (pickChanged) {
          changeType = 'major';
        } else if (probDiff >= 10) {
          changeType = 'significant';
        } else if (probDiff >= 3) {
          changeType = 'minor';
        } else {
          return;
        }
      }
      
      history.push({
        time: timestamp,
        fullTime: fullTimestamp,
        pick: prediction.pick,
        prob: prediction.prob,
        changeType: changeType
      });
      
      if (history.length > 10) {
        state.predictionHistory[key].predictions = history.slice(-10);
      }
      
      savePredictionHistory();
    }
    
    function savePredictionHistory() {
      try {
        const twoDaysAgo = new Date();
        twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);
        const cutoffDate = twoDaysAgo.toISOString().split('T')[0];
        
        Object.keys(state.predictionHistory).forEach(key => {
          if (state.predictionHistory[key].date < cutoffDate) {
            delete state.predictionHistory[key];
          }
        });
        
        localStorage.setItem('bp2_prediction_history', JSON.stringify(state.predictionHistory));
      } catch(e) { console.warn('Errore salvataggio storico:', e); }
    }
    
    function getPredictionHistory(matchId) {
      return state.predictionHistory[String(matchId)]?.predictions || [];
    }
    
    function renderHistorySection(matchId) {
      const history = getPredictionHistory(matchId);
      
      if (!history || history.length === 0) {
        return '<div class="history-section">' +
          '<div class="history-header">' +
            '<div class="history-icon">üìú</div>' +
            '<div class="history-title"><h3>Storico Variazioni</h3><p>Traccia le variazioni dei pronostici</p></div>' +
          '</div>' +
          '<div class="history-empty">üìä <strong>Prima analisi registrata!</strong></div>' +
        '</div>';
      }
      
      let historyHtml = '';
      history.forEach(function(item, index) {
        const isLast = index === history.length - 1;
        const itemClass = isLast ? 'current' : (item.changeType === 'major' || item.changeType === 'significant' ? 'significant' : '');
        
        let changeLabel = '', changeClass = '';
        if (item.changeType === 'first') { changeLabel = '1¬∞ ANALISI'; changeClass = 'first'; }
        else if (item.changeType === 'minor') { changeLabel = '‚Üï ¬±3-9%'; changeClass = 'minor'; }
        else if (item.changeType === 'significant') { changeLabel = '‚ö†Ô∏è ¬±10%+'; changeClass = 'significant'; }
        else if (item.changeType === 'major') { changeLabel = 'üîÑ CAMBIO!'; changeClass = 'major'; }
        
        historyHtml += '<div class="history-item ' + itemClass + '">' +
          '<span class="history-time">üïê ' + item.time + '</span>' +
          '<div class="history-pick">' +
            '<span class="history-pick-value">' + item.pick + '</span>' +
            '<span class="history-pick-prob">' + item.prob.toFixed(0) + '%</span>' +
          '</div>' +
          '<span class="history-change ' + changeClass + '">' + changeLabel + '</span>' +
        '</div>';
      });
      
      return '<div class="history-section">' +
        '<div class="history-header">' +
          '<div class="history-icon">üìú</div>' +
          '<div class="history-title"><h3>Storico Variazioni</h3></div>' +
        '</div>' +
        '<div class="history-timeline">' + historyHtml + '</div>' +
      '</div>';
    }

    // === API STATUS CHECK ===
    async function checkAPIStatus() {
      console.log('üîç Controllo stato API...');
      
      try {
        const testUrl = `${CONFIG.API_FOOTBALL.baseURL}/status`;
        const res = await fetch(testUrl, {
          headers: {
            'x-rapidapi-key': CONFIG.API_FOOTBALL.key,
            'x-rapidapi-host': 'v3.football.api-sports.io'
          }
        });
        
        if (res.ok) {
          state.api.football = 'online';
          localStorage.setItem('api_football_status', 'online');
          console.log('‚úÖ API-Football: ONLINE');
        } else {
          throw new Error('API-Football non disponibile');
        }
      } catch (e) {
        state.api.football = 'offline';
        localStorage.setItem('api_football_status', 'offline');
        console.warn('‚ùå API-Football: OFFLINE', e.message);
      }
      
      try {
        try {
          const testUrl = `${CONFIG.FOOTYSTATS.baseURL}/test?key=${CONFIG.FOOTYSTATS.key}`;
          const directRes = await fetch(testUrl);
          if (directRes.ok || directRes.status === 404) {
            state.api.footystats = 'online';
            localStorage.setItem('api_footystats_status', 'online');
            console.log('‚úÖ FootyStats: ONLINE (direct)');
            return;
          }
        } catch (e) {
          // Ignora errori CORS
        }
        
        const testUrl = `${CONFIG.FOOTYSTATS.baseURL}/test?key=${CONFIG.FOOTYSTATS.key}`;
        const proxies = [
          'https://api.allorigins.win/raw?url=',
          'https://corsproxy.io/?',
          'https://api.codetabs.com/v1/proxy?quest='
        ];
        
        for (const proxy of proxies) {
          try {
            const proxyUrl = proxy + encodeURIComponent(testUrl);
            const res = await fetch(proxyUrl);
            if (res.ok || res.status === 404) {
              state.api.footystats = 'online';
              localStorage.setItem('api_footystats_status', 'online');
              console.log(`‚úÖ FootyStats: ONLINE (proxy: ${proxy})`);
              return;
            }
          } catch (e) {
            continue;
          }
        }
        
        throw new Error('FootyStats non disponibile con nessun proxy');
      } catch (e) {
        state.api.footystats = 'offline';
        localStorage.setItem('api_footystats_status', 'offline');
        console.warn('‚ùå FootyStats: OFFLINE', e.message);
      }
    }

    // === API CALLS ===
    async function callAPIFootball(endpoint, params = {}) {
      const url = new URL(CONFIG.API_FOOTBALL.baseURL + endpoint);
      Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, v));
      
      try {
        const res = await fetch(url.toString(), {
          headers: {
            'x-rapidapi-key': CONFIG.API_FOOTBALL.key,
            'x-rapidapi-host': 'v3.football.api-sports.io'
          }
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        
        if (state.api.football !== 'online') {
          state.api.football = 'online';
          localStorage.setItem('api_football_status', 'online');
          render();
        }
        
        return data;
      } catch (e) {
        console.error('API Football error:', e);
        
        if (state.api.football !== 'offline') {
          state.api.football = 'offline';
          localStorage.setItem('api_football_status', 'offline');
          render();
        }
        
        return null;
      }
    }
    
    async function callFootyStats(endpoint, params = {}) {
      const url = new URL(CONFIG.FOOTYSTATS.baseURL + endpoint);
      url.searchParams.append('key', CONFIG.FOOTYSTATS.key);
      Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, v));
      
      try {
        try {
          const directRes = await fetch(url.toString());
          if (directRes.ok) {
            const data = await directRes.json();
            
            if (state.api.footystats !== 'online') {
              state.api.footystats = 'online';
              localStorage.setItem('api_footystats_status', 'online');
              render();
            }
            
            return data;
          }
        } catch (e) {
          // Ignora errori CORS
        }
        
        const proxies = [
          'https://api.allorigins.win/raw?url=',
          'https://corsproxy.io/?',
          'https://api.codetabs.com/v1/proxy?quest='
        ];
        
        for (const proxy of proxies) {
          try {
            const proxyUrl = proxy + encodeURIComponent(url.toString());
            const res = await fetch(proxyUrl);
            if (res.ok) {
              const data = await res.json();
              
              if (state.api.footystats !== 'online') {
                state.api.footystats = 'online';
                localStorage.setItem('api_footystats_status', 'online');
                render();
              }
              
              return data;
            }
          } catch (e) {
            continue;
          }
        }
        
        throw new Error('Tutti i proxy CORS hanno fallito');
      } catch (e) {
        console.error('FootyStats error:', e);
        
        if (state.api.footystats !== 'offline') {
          state.api.footystats = 'offline';
          localStorage.setItem('api_footystats_status', 'offline');
          render();
        }
        
        return null;
      }
    }

    // === CLASSIFICA ===
    async function getStandings(leagueId, season) {
      const cacheKey = `${leagueId}_${season}`;
      if (state.standingsCache.has(cacheKey)) {
        return state.standingsCache.get(cacheKey);
      }
      
      try {
        const data = await callAPIFootball('/standings', { league: leagueId, season: season || 2024 });
        if (data?.response?.[0]?.league?.standings?.[0]) {
          const standings = data.response[0].league.standings[0];
          state.standingsCache.set(cacheKey, standings);
          return standings;
        }
      } catch (e) {
        console.warn('Standings error:', e);
      }
      return null;
    }
    
    function getTeamPosition(standings, teamId) {
      if (!standings) return null;
      const team = standings.find(s => s.team.id === teamId);
      if (!team) return null;
      
      const totalTeams = standings.length;
      const position = team.rank;
      
      let motivation = 'normale';
      let motivationText = '';
      let motivationColor = 'gray';
      
      if (position <= 1) {
        motivation = 'alta';
        motivationText = 'üèÜ Lotta Scudetto';
        motivationColor = 'gold';
      } else if (position <= 4) {
        motivation = 'alta';
        motivationText = '‚≠ê Zona Champions';
        motivationColor = 'cyan';
      } else if (position <= 6) {
        motivation = 'media-alta';
        motivationText = 'üåü Zona Europa';
        motivationColor = 'blue';
      } else if (position >= totalTeams - 2) {
        motivation = 'altissima';
        motivationText = 'üî• Zona Retrocessione';
        motivationColor = 'red';
      } else if (position >= totalTeams - 5) {
        motivation = 'alta';
        motivationText = '‚ö†Ô∏è Rischio Retrocessione';
        motivationColor = 'orange';
      } else {
        motivation = 'normale';
        motivationText = '‚ûñ Met√† Classifica';
        motivationColor = 'gray';
      }
      
      return {
        position,
        totalTeams,
        points: team.points,
        form: team.form,
        played: team.all.played,
        won: team.all.win,
        draw: team.all.draw,
        lost: team.all.lose,
        goalsFor: team.all.goals.for,
        goalsAgainst: team.all.goals.against,
        goalDiff: team.goalsDiff,
        motivation,
        motivationText,
        motivationColor
      };
    }
    
    // === INFORTUNATI ===
    async function getInjuries(teamId, season) {
      const cacheKey = `injuries_${teamId}_${season}`;
      if (state.injuriesCache.has(cacheKey)) {
        return state.injuriesCache.get(cacheKey);
      }
      
      try {
        const data = await callAPIFootball('/injuries', { team: teamId, season: season || 2024 });
        if (data?.response) {
          const now = new Date();
          const thirtyDaysAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);
          
          const injuries = data.response.filter(inj => {
            const injDate = new Date(inj.fixture.date);
            return injDate >= thirtyDaysAgo;
          }).map(inj => ({
            player: inj.player.name,
            type: inj.player.type || 'Infortunio',
            reason: inj.player.reason || 'Non specificato'
          }));
          
          const uniqueInjuries = injuries.filter((inj, idx, arr) => 
            arr.findIndex(i => i.player === inj.player) === idx
          );
          
          state.injuriesCache.set(cacheKey, uniqueInjuries);
          return uniqueInjuries;
        }
      } catch (e) {
        console.warn('Injuries error:', e);
      }
      return [];
    }
    
    function calculateInjuryImpact(injuries) {
      if (!injuries || injuries.length === 0) return { attack: 1.0, defense: 1.0, text: '' };
      
      let attackImpact = 1.0;
      let defenseImpact = 1.0;
      const keyPlayers = [];
      
      injuries.forEach(inj => {
        attackImpact *= 0.97;
        defenseImpact *= 0.98;
        keyPlayers.push(inj.player);
      });
      
      attackImpact = Math.max(0.75, attackImpact);
      defenseImpact = Math.max(0.80, defenseImpact);
      
      const text = injuries.length > 0 
        ? `${injuries.length} assenti: ${keyPlayers.slice(0, 3).join(', ')}${injuries.length > 3 ? '...' : ''}`
        : '';
      
      return { attack: attackImpact, defense: defenseImpact, text };
    }
    
    // === SALVA IMPOSTAZIONI ===
    function saveSettings() {
      localStorage.setItem('bp2_settings', JSON.stringify(state.settings));
    }
    
    function toggleSettingsPanel() {
      state.settingsOpen = !state.settingsOpen;
      render();
    }

    // === DATA LOADING ===
    async function loadMatches(dateOffset = 0) {
      state.loading = true;
      state.selectedDate = dateOffset;
      render();
      
      const dateStr = getDateString(dateOffset);
      console.log('üìÖ Loading matches for:', dateStr);
      
      const data = await callAPIFootball('/fixtures', { date: dateStr, timezone: 'Europe/Rome' });
      
      if (data?.response) {
        const leagueMap = new Map();
        data.response.forEach(f => {
          const key = f.league.id;
          if (!leagueMap.has(key)) {
            leagueMap.set(key, {
              id: f.league.id,
              name: f.league.name,
              country: f.league.country,
              logo: f.league.logo,
              season: f.league.season,
              matchCount: 0
            });
          }
          leagueMap.get(key).matchCount++;
        });
        
        state.leagues = Array.from(leagueMap.values())
          .sort((a, b) => `${a.country} ${a.name}`.localeCompare(`${b.country} ${b.name}`));
        
        state.matches = data.response.map(f => ({
          id: f.fixture.id,
          date: f.fixture.date,
          timestamp: f.fixture.timestamp,
          status: f.fixture.status.short,
          elapsed: f.fixture.status.elapsed,
          league: f.league,
          home: { id: f.teams.home.id, name: f.teams.home.name, logo: f.teams.home.logo },
          away: { id: f.teams.away.id, name: f.teams.away.name, logo: f.teams.away.logo },
          goals: f.goals
        }));
        
        console.log(`‚úÖ Loaded ${state.leagues.length} leagues, ${state.matches.length} matches`);
      }
      
      const fsData = await callFootyStats('/todays-matches', {});
      if (fsData?.data) {
        fsData.data.forEach(m => {
          if (m.home_name && m.away_name) {
            const keys = [
              `${m.home_name.toLowerCase()}_${m.away_name.toLowerCase()}`,
              m.home_name.toLowerCase().replace(/\s+/g, '') + '_' + m.away_name.toLowerCase().replace(/\s+/g, '')
            ];
            keys.forEach(k => state.fsData.set(k, m));
          }
        });
      }
      
      // Calcola picks e consigli
      calculateDailyPicks();
      generateDayAdvices();
      
      state.loading = false;
      render();
    }

    // === DAILY PICKS ===
    const TOP_LEAGUES = [135, 136, 39, 40, 41, 140, 141, 78, 79, 61, 62, 88, 94, 144, 203, 2, 3, 848];
    
    function calculateDailyPicks() {
      if (state.matches.length === 0) return;
      
      const picks = { raddoppi: [], gg: [], over25: [], pareggi: [], over1T: [] };
      const safeBets = [];
      
      state.matches.forEach(match => {
        if (['1H','2H','HT','ET','P','LIVE','FT','AET','PEN'].includes(match.status)) return;
        
        const isTopLeague = TOP_LEAGUES.includes(match.league.id);
        
        let fsMatch = null;
        const fsKeys = [
          `${match.home.name.toLowerCase()}_${match.away.name.toLowerCase()}`,
          match.home.name.toLowerCase().replace(/\s+/g, '') + '_' + match.away.name.toLowerCase().replace(/\s+/g, '')
        ];
        for (const k of fsKeys) {
          if (state.fsData.has(k)) { fsMatch = state.fsData.get(k); break; }
        }
        
        let homeXG = 1.35, awayXG = 1.10;
        
        if (fsMatch) {
          if (fsMatch.home_xg) homeXG = fsMatch.home_xg;
          else if (fsMatch.home_ppg) homeXG = fsMatch.home_ppg * 0.8;
          else if (fsMatch.avg_goals_home) homeXG = fsMatch.avg_goals_home;
          
          if (fsMatch.away_xg) awayXG = fsMatch.away_xg;
          else if (fsMatch.away_ppg) awayXG = fsMatch.away_ppg * 0.7;
          else if (fsMatch.avg_goals_away) awayXG = fsMatch.avg_goals_away;
        }
        
        homeXG *= 1.10;
        awayXG *= 0.93;
        
        homeXG = clamp(0.3, homeXG, 3.5);
        awayXG = clamp(0.2, awayXG, 3.0);
        
        const totXG = homeXG + awayXG;
        
        const p1X2 = quickCalc1X2(homeXG, awayXG);
        const pOver15 = quickCalcOver(homeXG, awayXG, 1.5);
        const pOver25 = quickCalcOver(homeXG, awayXG, 2.5);
        const pBTTS = quickCalcBTTS(homeXG, awayXG);
        
        const matchInfo = {
          match,
          matchName: `${match.home.name} vs ${match.away.name}`,
          shortName: `${match.home.name.substring(0,12)} - ${match.away.name.substring(0,12)}`,
          league: `${match.league.country} - ${match.league.name}`,
          time: formatTime(match.date)
        };
        
        // Raddoppi sicuri (campionati TOP, prob >= 75%)
        if (isTopLeague) {
          const p1X = p1X2.home + p1X2.draw;
          const pX2 = p1X2.draw + p1X2.away;
          
          if (p1X >= 78) {
            safeBets.push({ ...matchInfo, bet: '1X', prob: p1X, odds: (100 / p1X).toFixed(2) });
          }
          if (pX2 >= 78) {
            safeBets.push({ ...matchInfo, bet: 'X2', prob: pX2, odds: (100 / pX2).toFixed(2) });
          }
          if (pOver15 >= 80) {
            safeBets.push({ ...matchInfo, bet: 'Over 1.5', prob: pOver15, odds: (100 / pOver15).toFixed(2) });
          }
          if (p1X2.home >= 73) {
            safeBets.push({ ...matchInfo, bet: '1', prob: p1X2.home, odds: (100 / p1X2.home).toFixed(2) });
          }
          if (p1X2.away >= 70) {
            safeBets.push({ ...matchInfo, bet: '2', prob: p1X2.away, odds: (100 / p1X2.away).toFixed(2) });
          }
        }
        
        if (pBTTS >= 55) {
          picks.gg.push({ ...matchInfo, bet: 'GG', prob: pBTTS });
        }
        
        if (pOver25 >= 55 && totXG >= 3.0) {
          picks.over25.push({ ...matchInfo, bet: 'Over 2.5', prob: pOver25, xgTotal: totXG.toFixed(2) });
        }
        
        if (p1X2.draw >= 28 && p1X2.home < 50 && p1X2.away < 50) {
          picks.pareggi.push({ ...matchInfo, bet: 'X', prob: p1X2.draw });
        }
        
        const pOver05_1T = quickCalcOver(homeXG * 0.45, awayXG * 0.45, 0.5);
        const pOver15_1T = quickCalcOver(homeXG * 0.45, awayXG * 0.45, 1.5);
        
        if (pOver05_1T >= 75 && totXG >= 3.0) {
          picks.over1T.push({ ...matchInfo, bet: 'Over 0.5 1T', prob: pOver05_1T, xgTotal: totXG.toFixed(2) });
        }
        if (pOver15_1T >= 55 && totXG >= 3.8) {
          picks.over1T.push({ ...matchInfo, bet: 'Over 1.5 1T', prob: pOver15_1T, xgTotal: totXG.toFixed(2) });
        }
      });
      
      // Costruisci raddoppi AI (max 3)
      picks.raddoppi = buildRaddoppiAI(safeBets, 3);
      
      // Ordina e limita a 6
      picks.gg = picks.gg.sort((a, b) => b.prob - a.prob).slice(0, 6);
      picks.over25 = picks.over25.sort((a, b) => b.prob - a.prob).slice(0, 6);
      picks.pareggi = picks.pareggi.sort((a, b) => b.prob - a.prob).slice(0, 6);
      picks.over1T = picks.over1T.sort((a, b) => b.prob - a.prob).slice(0, 6);
      
      state.dailyPicks = picks;
      console.log('üéØ Daily picks:', Object.keys(picks).map(k => `${k}: ${picks[k].length}`).join(', '));
    }

    // === RADDOPPI AI (max 3 combinazioni) ===
    function buildRaddoppiAI(safeBets, maxRaddoppi = 3) {
      if (safeBets.length < 2) return [];
      
      const raddoppi = [];
      const targetOdds = 2.0;
      const tolerance = 0.25;
      
      // Ordina per probabilit√† decrescente
      safeBets.sort((a, b) => b.prob - a.prob);
      
      // Prova combinazioni di 2 e 3 partite
      for (let size = 2; size <= Math.min(3, safeBets.length); size++) {
        const combos = getCombinations(safeBets, size);
        
        for (const combo of combos) {
          const matchIds = combo.map(c => c.match.id);
          if (new Set(matchIds).size !== matchIds.length) continue;
          
          const totalOdds = combo.reduce((acc, c) => acc * parseFloat(c.odds), 1);
          const totalProb = combo.reduce((acc, c) => acc * (c.prob / 100), 1) * 100;
          
          if (totalOdds >= targetOdds - tolerance && totalOdds <= targetOdds + tolerance) {
            raddoppi.push({
              bets: combo,
              totalOdds: totalOdds.toFixed(2),
              totalProb: totalProb.toFixed(1),
              size: combo.length
            });
          }
        }
      }
      
      // Ordina per probabilit√† e prendi i migliori MAX
      return raddoppi
        .sort((a, b) => parseFloat(b.totalProb) - parseFloat(a.totalProb))
        .slice(0, maxRaddoppi);
    }
    
    // Combinazioni
    function getCombinations(arr, k) {
      if (k === 1) return arr.map(x => [x]);
      if (k === arr.length) return [arr];
      if (k > arr.length) return [];
      
      const result = [];
      const n = arr.length;
      const maxCombos = 500;
      let count = 0;
      
      function combine(start, combo) {
        if (count >= maxCombos) return;
        if (combo.length === k) {
          result.push([...combo]);
          count++;
          return;
        }
        for (let i = start; i < n && count < maxCombos; i++) {
          combo.push(arr[i]);
          combine(i + 1, combo);
          combo.pop();
        }
      }
      
      combine(0, []);
      return result;
    }

    // === QUICK CALCOLI ===
    function quickCalc1X2(lH, lA) {
      let pH = 0, pD = 0, pA = 0;
      for (let i = 0; i <= 5; i++) {
        for (let j = 0; j <= 5; j++) {
          const p = poisson(lH, i) * poisson(lA, j);
          if (i > j) pH += p; else if (i === j) pD += p; else pA += p;
        }
      }
      const t = pH + pD + pA;
      return { home: (pH/t)*100, draw: (pD/t)*100, away: (pA/t)*100 };
    }
    
    function quickCalcOver(lH, lA, line) {
      let pUnder = 0;
      for (let i = 0; i <= 5; i++) {
        for (let j = 0; j <= 5; j++) {
          if (i + j <= Math.floor(line)) pUnder += poisson(lH, i) * poisson(lA, j);
        }
      }
      return clamp(10, (1 - pUnder) * 100, 90);
    }
    
    function quickCalcBTTS(lH, lA) {
      return clamp(15, (1 - poisson(lH, 0)) * (1 - poisson(lA, 0)) * 100, 85);
    }

    // === NUOVA FUNZIONE: CONSIGLI DEL GIORNO ===
    function generateDayAdvices() {
      if (state.matches.length === 0) return;
      
      const advices = { gg: [], one: [], two: [], x: [] };
      
      state.matches.forEach(match => {
        if (['1H','2H','HT','ET','P','LIVE','FT','AET','PEN'].includes(match.status)) return;
        
        // Estrai dati come in calculateDailyPicks
        let fsMatch = null;
        const fsKeys = [
          `${match.home.name.toLowerCase()}_${match.away.name.toLowerCase()}`,
          match.home.name.toLowerCase().replace(/\s+/g, '') + '_' + match.away.name.toLowerCase().replace(/\s+/g, '')
        ];
        for (const k of fsKeys) {
          if (state.fsData.has(k)) { fsMatch = state.fsData.get(k); break; }
        }
        
        let homeXG = 1.35, awayXG = 1.10;
        
        if (fsMatch) {
          if (fsMatch.home_xg) homeXG = fsMatch.home_xg;
          else if (fsMatch.home_ppg) homeXG = fsMatch.home_ppg * 0.8;
          else if (fsMatch.avg_goals_home) homeXG = fsMatch.avg_goals_home;
          
          if (fsMatch.away_xg) awayXG = fsMatch.away_xg;
          else if (fsMatch.away_ppg) awayXG = fsMatch.away_ppg * 0.7;
          else if (fsMatch.avg_goals_away) awayXG = fsMatch.avg_goals_away;
        }
        
        homeXG *= 1.10;
        awayXG *= 0.93;
        homeXG = clamp(0.3, homeXG, 3.5);
        awayXG = clamp(0.2, awayXG, 3.0);
        
        const p1X2 = quickCalc1X2(homeXG, awayXG);
        const pBTTS = quickCalcBTTS(homeXG, awayXG);
        
        const matchInfo = {
          match,
          matchName: `${match.home.name} vs ${match.away.name}`,
          league: `${match.league.country}`,
          time: formatTime(match.date)
        };
        
        // GG: generato da AI picks con GG
        if (pBTTS >= 55) {
          advices.gg.push({ ...matchInfo, prob: pBTTS.toFixed(0) });
        }
        
        // 1: AI pick = 1 con prob >= 85%
        if (p1X2.home >= 85) {
          advices.one.push({ ...matchInfo, prob: p1X2.home.toFixed(0) });
        }
        
        // 2: AI pick = 2 con prob >= 75%
        if (p1X2.away >= 75) {
          advices.two.push({ ...matchInfo, prob: p1X2.away.toFixed(0) });
        }
        
        // X: esito X da AI E prob X >= 33%
        if (p1X2.draw >= 33) {
          advices.x.push({ ...matchInfo, prob: p1X2.draw.toFixed(0) });
        }
      });
      
      // Ordina per probabilit√† decrescente e limita a Top 15 per categoria
      advices.gg = advices.gg.sort((a, b) => parseFloat(b.prob) - parseFloat(a.prob)).slice(0, 15);
      advices.one = advices.one.sort((a, b) => parseFloat(b.prob) - parseFloat(a.prob)).slice(0, 15);
      advices.two = advices.two.sort((a, b) => parseFloat(b.prob) - parseFloat(a.prob)).slice(0, 15);
      advices.x = advices.x.sort((a, b) => parseFloat(b.prob) - parseFloat(a.prob)).slice(0, 15);
      
      state.dayAdvices = advices;
      console.log('üìä Day advices:', Object.keys(advices).map(k => `${k}: ${advices[k].length}`).join(', '));
    }

    // === FIREBASE ===
    async function loadSlipFromFirebase() {
      try {
        const res = await fetch(`${CONFIG.FIREBASE.url}/slips2/${USER_ID}.json`);
        const data = await res.json();
        if (data && Array.isArray(data.items)) {
          state.slip = data.items;
          console.log('üìã Schedina caricata:', state.slip.length);
        }
      } catch (e) {
        console.warn('Firebase load error:', e);
      }
    }

    async function saveSlipToFirebase() {
      try {
        await fetch(`${CONFIG.FIREBASE.url}/slips2/${USER_ID}.json`, {
          method: 'PUT',
          body: JSON.stringify({ items: state.slip, updated: Date.now() })
        });
        console.log('üíæ Schedina salvata');
      } catch (e) {
        console.warn('Firebase save error:', e);
      }
    }

    function addToSlip(match, market, value, prob) {
      const key = `${match.id}_${market}`;
      const exists = state.slip.find(s => s.key === key);
      if (exists) {
        state.slip = state.slip.filter(s => s.key !== key);
      } else {
        state.slip.push({
          key,
          matchId: match.id,
          matchName: `${match.home.name} vs ${match.away.name}`,
          matchDate: match.date,
          market,
          value,
          prob
        });
      }
      saveSlipToFirebase();
      render();
    }

    function removeFromSlip(key) {
      state.slip = state.slip.filter(s => s.key !== key);
      saveSlipToFirebase();
      render();
    }

    function clearSlip() {
      state.slip = [];
      saveSlipToFirebase();
      render();
    }

    function isInSlip(matchId, market) {
      return state.slip.some(s => s.key === `${matchId}_${market}`);
    }

    // === MONEY MANAGEMENT ===
    function saveMoney() {
      localStorage.setItem('bp2_bankroll', state.money.bankroll);
      localStorage.setItem('bp2_target', state.money.target);
      localStorage.setItem('bp2_totalbets', state.money.totalBets);
      localStorage.setItem('bp2_currentbet', state.money.currentBet);
      localStorage.setItem('bp2_odds', state.money.currentOdds);
      localStorage.setItem('bp2_history', JSON.stringify(state.money.history.slice(-30)));
    }
    
    function calculateStake() {
      const { bankroll, target, totalBets, currentBet, currentOdds } = state.money;
      const remainingBets = totalBets - currentBet + 1;
      
      if (remainingBets <= 0 || bankroll <= 0 || currentOdds <= 1) {
        return { stake: 0, error: 'Parametri non validi' };
      }
      
      if (bankroll >= target) {
        return { stake: 0, reached: true };
      }
      
      const totalMultiplier = target / bankroll;
      const perBetMultiplier = Math.pow(totalMultiplier, 1 / remainingBets);
      const stake = bankroll * (perBetMultiplier - 1) / (currentOdds - 1);
      
      if (stake > bankroll * 0.95) {
        return { stake: Math.round(bankroll * 0.95 * 100) / 100, warning: '‚ö†Ô∏è Rischio MOLTO alto!' };
      }
      
      if (stake < 0.5) {
        return { stake: 0.5, warning: 'Puntata minima ‚Ç¨0.50' };
      }
      
      return {
        stake: Math.round(stake * 100) / 100,
        perBetMultiplier: perBetMultiplier.toFixed(3),
        potentialWin: Math.round(stake * (currentOdds - 1) * 100) / 100,
        newBankroll: Math.round((bankroll + stake * (currentOdds - 1)) * 100) / 100
      };
    }
    
    function recordBetResult(won) {
      const calc = calculateStake();
      const stake = calc.stake || 0;
      
      state.money.history.push({
        bet: state.money.currentBet,
        date: new Date().toLocaleTimeString('it-IT', {hour:'2-digit', minute:'2-digit'}),
        odds: state.money.currentOdds,
        stake: stake,
        won: won,
        bankrollBefore: state.money.bankroll
      });
      
      if (won) {
        state.money.bankroll += stake * (state.money.currentOdds - 1);
      } else {
        state.money.bankroll -= stake;
      }
      
      state.money.bankroll = Math.max(0, Math.round(state.money.bankroll * 100) / 100);
      state.money.currentBet++;
      
      saveMoney();
      render();
    }
    
    function resetMoney() {
      state.money.currentBet = 1;
      state.money.history = [];
      saveMoney();
      render();
    }
    
    function getMoneyStats() {
      const { bankroll, target, totalBets, currentBet, currentOdds, history } = state.money;
      const calc = calculateStake();
      const wins = history.filter(h => h.won).length;
      const losses = history.filter(h => !h.won).length;
      const progress = Math.min(100, (bankroll / target) * 100);
      
      return {
        bankroll,
        target,
        totalBets,
        currentBet,
        currentOdds,
        remainingBets: Math.max(0, totalBets - currentBet + 1),
        progress,
        stake: calc.stake || 0,
        warning: calc.warning,
        error: calc.error,
        reached: calc.reached,
        potentialWin: calc.potentialWin || 0,
        newBankroll: calc.newBankroll || bankroll,
        perBetMultiplier: calc.perBetMultiplier || '-',
        wins,
        losses,
        winRate: (wins + losses) > 0 ? ((wins / (wins + losses)) * 100).toFixed(0) : '-'
      };
    }

    // === TRACKING ===
    async function loadTrackingFromFirebase() {
      try {
        const res = await fetch(`${CONFIG.FIREBASE.url}/tracking2/${USER_ID}.json`);
        const data = await res.json();
        if (data && Array.isArray(data)) {
          state.trackedBets = data;
          saveTrackedBets();
        }
      } catch (e) {
        console.warn('Firebase tracking load error:', e);
      }
    }

    function trackBet(type, matchId, matchName, pick, prob, odds, isLive = false) {
      if (state.trackedBets.some(b => b.matchId === matchId && b.pick === pick)) {
        console.log('Pronostico gi√† tracciato');
        return null;
      }
      
      const bet = {
        id: Date.now(),
        type,
        matchId,
        matchName,
        pick,
        prob: parseFloat(prob),
        odds: parseFloat(odds) || 0,
        isLive,
        timestamp: new Date().toISOString(),
        status: 'pending',
        result: null
      };
      
      state.trackedBets.push(bet);
      saveTrackedBets();
      saveTrackingToFirebase();
      
      render();
      return bet;
    }
    
    function trackPrematchBet(matchId, matchName, pick, prob, event) {
      if (event) event.stopPropagation();
      
      const odds = (100 / prob).toFixed(2);
      const bet = trackBet('prematch', matchId, matchName, pick, prob, odds, false);
      if (bet) {
        alert(`‚úÖ Pronostico tracciato!\n\n${matchName}\n${pick} @ ${odds}\n\nVerr√† verificato automaticamente.`);
      } else {
        alert('‚ö†Ô∏è Questo pronostico √® gi√† stato tracciato.');
      }
    }
    
    function saveTrackedBets() {
      localStorage.setItem('bp2_tracked', JSON.stringify(state.trackedBets));
    }
    
    async function saveTrackingToFirebase() {
      try {
        await fetch(`${CONFIG.FIREBASE.url}/tracking2/${USER_ID}.json`, {
          method: 'PUT',
          body: JSON.stringify(state.trackedBets)
        });
      } catch (e) {
        console.warn('Firebase tracking save error:', e);
      }
    }
    
    async function checkPendingResults() {
      const pending = state.trackedBets.filter(b => b.status === 'pending');
      
      for (const bet of pending) {
        try {
          const data = await callAPIFootball('/fixtures', { id: bet.matchId });
          if (data && data.response && data.response[0]) {
            const fixture = data.response[0];
            const status = fixture.fixture.status.short;
            
            if (['FT', 'AET', 'PEN'].includes(status)) {
              const homeGoals = fixture.goals.home;
              const awayGoals = fixture.goals.away;
              const totalGoals = homeGoals + awayGoals;
              const result = `${homeGoals}-${awayGoals}`;
              
              let won = false;
              const pick = bet.pick.toLowerCase();
              
              if (pick.includes('over 0.5') && totalGoals >= 1) won = true;
              else if (pick.includes('over 1.5') && totalGoals >= 2) won = true;
              else if (pick.includes('over 2.5') && totalGoals >= 3) won = true;
              else if (pick.includes('over 3.5') && totalGoals >= 4) won = true;
              else if (pick.includes('under 2.5') && totalGoals < 3) won = true;
              else if (pick.includes('under 3.5') && totalGoals < 4) won = true;
              else if ((pick.includes('gg') || pick.includes('entrambe segnano')) && homeGoals > 0 && awayGoals > 0) won = true;
              else if (pick.includes('ng') && (homeGoals === 0 || awayGoals === 0)) won = true;
              else if ((pick === '1' || pick.startsWith('1 (') || pick.startsWith('1 ')) && homeGoals > awayGoals) won = true;
              else if ((pick === 'x' || pick.startsWith('x (') || pick === 'pareggio') && homeGoals === awayGoals) won = true;
              else if ((pick === '2' || pick.startsWith('2 (') || pick.startsWith('2 ')) && homeGoals < awayGoals) won = true;
              else if ((pick === '1x' || pick.startsWith('1x (') || pick.startsWith('1x ')) && homeGoals >= awayGoals) won = true;
              else if ((pick === 'x2' || pick.startsWith('x2 (') || pick.startsWith('x2 ')) && homeGoals <= awayGoals) won = true;
              else if (pick.includes('segna') && totalGoals > 0) won = true;
              else if (pick.includes('gol 2¬∞') && totalGoals > 0) won = true;
              
              const betIndex = state.trackedBets.findIndex(b => b.id === bet.id);
              if (betIndex >= 0) {
                state.trackedBets[betIndex].status = won ? 'won' : 'lost';
                state.trackedBets[betIndex].result = result;
              }
            }
          }
        } catch (e) {
          console.warn('Check result error:', e);
        }
      }
      
      saveTrackedBets();
      saveTrackingToFirebase();
      render();
    }
    
    function getTrackingStats() {
      const stats = {
        total: state.trackedBets.length,
        pending: state.trackedBets.filter(b => b.status === 'pending').length,
        won: state.trackedBets.filter(b => b.status === 'won').length,
        lost: state.trackedBets.filter(b => b.status === 'lost').length,
        byType: {},
        byPick: {}
      };
      
      const completed = stats.won + stats.lost;
      stats.winRate = completed > 0 ? ((stats.won / completed) * 100).toFixed(1) : 0;
      
      ['prematch', 'live'].forEach(type => {
        const bets = state.trackedBets.filter(b => b.type === type);
        const won = bets.filter(b => b.status === 'won').length;
        const lost = bets.filter(b => b.status === 'lost').length;
        const total = won + lost;
        stats.byType[type] = {
          total: bets.length,
          won,
          lost,
          winRate: total > 0 ? ((won / total) * 100).toFixed(1) : 0
        };
      });
      
      const pickTypes = [
        { key: 'over 0.5', label: 'Over 0.5' },
        { key: 'over 1.5', label: 'Over 1.5' },
        { key: 'over 2.5', label: 'Over 2.5' },
        { key: 'over 3.5', label: 'Over 3.5' },
        { key: 'under', label: 'Under' },
        { key: 'gg', label: 'GG' },
        { key: 'entrambe segnano', label: 'GG' },
        { key: '1 (', label: '1' },
        { key: '2 (', label: '2' },
        { key: '1x', label: '1X' },
        { key: 'x2', label: 'X2' },
        { key: 'pareggio', label: 'X' }
      ];
      pickTypes.forEach(pickType => {
        const bets = state.trackedBets.filter(b => b.pick.toLowerCase().includes(pickType.key));
        const won = bets.filter(b => b.status === 'won').length;
        const lost = bets.filter(b => b.status === 'lost').length;
        const total = won + lost;
        if (bets.length > 0) {
          stats.byPick[pickType.label] = {
            total: bets.length,
            won,
            lost,
            winRate: total > 0 ? ((won / total) * 100).toFixed(1) : 0
          };
        }
      });
      
      return stats;
    }

        // === ANALYSIS ENGINE ===
    
    async function analyzeMatch(match) {
      state.selectedMatch = match;
      state.view = 'analysis';
      state.loading = true;
      state.analysis = null;
      render();
      
      let homeStats = null, awayStats = null, h2h = [], apiPred = null;
      let homeLastMatches = [], awayLastMatches = [];
      let standings = null, homeInjuries = [], awayInjuries = [];
      
      try {
        const [hs, as] = await Promise.all([
          callAPIFootball('/teams/statistics', { team: match.home.id, league: match.league.id, season: match.league.season || 2024 }),
          callAPIFootball('/teams/statistics', { team: match.away.id, league: match.league.id, season: match.league.season || 2024 })
        ]);
        homeStats = hs?.response;
        awayStats = as?.response;
      } catch (e) {}
      
      try {
        const [homeLastRes, awayLastRes] = await Promise.all([
          callAPIFootball('/fixtures', { team: match.home.id, last: 5 }),
          callAPIFootball('/fixtures', { team: match.away.id, last: 5 })
        ]);
        homeLastMatches = homeLastRes?.response || [];
        awayLastMatches = awayLastRes?.response || [];
      } catch (e) {}
      
      try {
        const h2hRes = await callAPIFootball('/fixtures/headtohead', { h2h: `${match.home.id}-${match.away.id}`, last: 10 });
        h2h = h2hRes?.response || [];
      } catch (e) {}
      
      try {
        const predRes = await callAPIFootball('/predictions', { fixture: match.id });
        apiPred = predRes?.response?.[0];
      } catch (e) {}
      
      if (state.settings.showStandings) {
        try {
          standings = await getStandings(match.league.id, match.league.season || 2024);
        } catch (e) {}
      }
      
      if (state.settings.showInjuries) {
        try {
          const [homeInj, awayInj] = await Promise.all([
            getInjuries(match.home.id, match.league.season || 2024),
            getInjuries(match.away.id, match.league.season || 2024)
          ]);
          homeInjuries = homeInj || [];
          awayInjuries = awayInj || [];
        } catch (e) {}
      }
      
      let fsMatch = null;
      const fsKeys = [
        `${match.home.name.toLowerCase()}_${match.away.name.toLowerCase()}`,
        match.home.name.toLowerCase().replace(/\s+/g, '') + '_' + match.away.name.toLowerCase().replace(/\s+/g, '')
      ];
      for (const k of fsKeys) {
        if (state.fsData.has(k)) {
          fsMatch = state.fsData.get(k);
          break;
        }
      }
      
      const homeForm = calculateRealForm(homeLastMatches, match.home.id);
      const awayForm = calculateRealForm(awayLastMatches, match.away.id);
      
      const homePosition = getTeamPosition(standings, match.home.id);
      const awayPosition = getTeamPosition(standings, match.away.id);
      
      const homeInjuryImpact = calculateInjuryImpact(homeInjuries);
      const awayInjuryImpact = calculateInjuryImpact(awayInjuries);
      
      state.analysis = buildAnalysis(match, homeStats, awayStats, h2h, apiPred, fsMatch, homeForm, awayForm, {
        homePosition, awayPosition, homeInjuries, awayInjuries, homeInjuryImpact, awayInjuryImpact
      });
      
      if (state.analysis) {
        const ai = generateAIAdvice(match, state.analysis);
        const matchName = match.home.name + ' vs ' + match.away.name;
        savePredictionToHistory(match.id, matchName, {
          pick: ai.pick,
          prob: ai.prob
        });
      }
      
      state.loading = false;
      render();
    }
    
    function calculateRealForm(matches, teamId) {
      if (!matches || matches.length === 0) return 'DDDDD';
      
      let form = '';
      matches.forEach(m => {
        const homeGoals = m.goals?.home ?? 0;
        const awayGoals = m.goals?.away ?? 0;
        const isHome = m.teams?.home?.id === teamId;
        
        if (isHome) {
          if (homeGoals > awayGoals) form += 'W';
          else if (homeGoals < awayGoals) form += 'L';
          else form += 'D';
        } else {
          if (awayGoals > homeGoals) form += 'W';
          else if (awayGoals < homeGoals) form += 'L';
          else form += 'D';
        }
      });
      
      return form || 'DDDDD';
    }

    function buildAnalysis(match, homeStats, awayStats, h2h, apiPred, fsMatch, homeForm, awayForm, extraData = {}) {
      const homeData = extractTeamData(homeStats, 'home');
      const awayData = extractTeamData(awayStats, 'away');
      
      const { homePosition, awayPosition, homeInjuries, awayInjuries, homeInjuryImpact, awayInjuryImpact } = extraData;
      
      let homeXG = calculateXG(homeData, awayData, 'home', apiPred, fsMatch);
      let awayXG = calculateXG(awayData, homeData, 'away', apiPred, fsMatch);
      
      if (h2h.length >= 3) {
        const adj = analyzeH2H(h2h, match.home.id);
        homeXG *= adj.homeMultiplier;
        awayXG *= adj.awayMultiplier;
      }
      
      if (homeForm && awayForm) {
        const homeWins = (homeForm.match(/W/g) || []).length;
        const homeLosses = (homeForm.match(/L/g) || []).length;
        const awayWins = (awayForm.match(/W/g) || []).length;
        const awayLosses = (awayForm.match(/L/g) || []).length;
        
        if (homeWins >= 4) homeXG *= 1.08;
        else if (homeWins >= 3) homeXG *= 1.04;
        else if (homeLosses >= 3) homeXG *= 0.92;
        
        if (awayWins >= 4) awayXG *= 1.08;
        else if (awayWins >= 3) awayXG *= 1.04;
        else if (awayLosses >= 3) awayXG *= 0.92;
      }
      
      homeXG *= 1.10;
      awayXG *= 0.93;
      
      homeXG = clamp(0.25, homeXG, 3.8);
      awayXG = clamp(0.15, awayXG, 3.2);
      
      const totXG = homeXG + awayXG;
      
      const p1X2 = calc1X2(homeXG, awayXG);
      const pOU = calcOU(homeXG, awayXG);
      
      let pBTTS = calcBTTS(homeXG, awayXG);
      
      const homeWillScore = 100 - homeData.failedToScorePct;
      const awayWillScore = 100 - awayData.failedToScorePct;
      const historicalBTTS = (homeWillScore * awayWillScore) / 100;
      
      pBTTS = (pBTTS * 0.60) + (historicalBTTS * 0.40);
      pBTTS = clamp(15, pBTTS, 85);
      
      const exactScores = calcExactScores(homeXG, awayXG);
      
      const corners = calcCorners(homeData, awayData, fsMatch);
      const cards = calcCards(homeData, awayData, fsMatch);
      
      const predictions = buildPredictions(match, homeXG, awayXG, p1X2, pOU, pBTTS, exactScores, corners, cards);
      
      const combos = buildCombos(p1X2, pOU, pBTTS);
      
      const h2hInfo = summarizeH2H(h2h, match.home.id);
      
      const multigoal = calcAllMultigol(homeXG, awayXG);
      
      const temporalDistribution = calcTemporalDistribution(homeXG, awayXG);
      
      const multigoalHome = [
        { range: '1+', prob: calcTeamMultigol(homeXG, 1, 6) },
        { range: '2+', prob: calcTeamMultigol(homeXG, 2, 6) },
        { range: '1-2', prob: calcTeamMultigol(homeXG, 1, 2) },
        { range: '1-3', prob: calcTeamMultigol(homeXG, 1, 3) }
      ];
      const multigoalAway = [
        { range: '1+', prob: calcTeamMultigol(awayXG, 1, 6) },
        { range: '2+', prob: calcTeamMultigol(awayXG, 2, 6) },
        { range: '1-2', prob: calcTeamMultigol(awayXG, 1, 2) },
        { range: '1-3', prob: calcTeamMultigol(awayXG, 1, 3) }
      ];
      
      const shots = calcExpectedShots(homeXG, awayXG);
      
      return {
        match,
        xG: { home: homeXG, away: awayXG, total: totXG },
        p1X2, pOU, pBTTS,
        exactScores: exactScores.slice(0, 12),
        corners, cards,
        shots,
        h2h: h2hInfo,
        predictions,
        combos,
        multigoal,
        temporalDistribution,
        multigoalHome,
        multigoalAway,
        homeForm: homeForm || 'N/A',
        awayForm: awayForm || 'N/A',
        homePosition,
        awayPosition,
        homeInjuries: homeInjuries || [],
        awayInjuries: awayInjuries || [],
        quality: (homeStats || awayStats) ? 'enhanced' : 'base'
      };
    }

    function extractTeamData(stats, side) {
      if (!stats) return { 
        goalsFor: 1.3, goalsAgainst: 1.2, form: 'DDDDD', corners: 5.0, cards: 1.8,
        cleanSheetPct: 25, failedToScorePct: 25, played: 10, wins: 4, draws: 3, losses: 3
      };
      
      const goals = stats.goals || {};
      const fixtures = stats.fixtures || {};
      const played = (side === 'home' ? fixtures.played?.home : fixtures.played?.away) || fixtures.played?.total || 10;
      const wins = (side === 'home' ? fixtures.wins?.home : fixtures.wins?.away) || fixtures.wins?.total || 4;
      const draws = (side === 'home' ? fixtures.draws?.home : fixtures.draws?.away) || fixtures.draws?.total || 3;
      const losses = (side === 'home' ? fixtures.loses?.home : fixtures.loses?.away) || fixtures.loses?.total || 3;
      
      const forAvg = side === 'home' 
        ? (goals.for?.average?.home || goals.for?.average?.total || 1.3)
        : (goals.for?.average?.away || goals.for?.average?.total || 1.1);
      const againstAvg = side === 'home'
        ? (goals.against?.average?.home || goals.against?.average?.total || 1.2)
        : (goals.against?.average?.away || goals.against?.average?.total || 1.3);
      
      const cleanSheetPct = stats.clean_sheet ? 
        ((side === 'home' ? stats.clean_sheet.home : stats.clean_sheet.away) || stats.clean_sheet.total || 0) / played * 100 : 25;
      const failedToScorePct = stats.failed_to_score ?
        ((side === 'home' ? stats.failed_to_score.home : stats.failed_to_score.away) || stats.failed_to_score.total || 0) / played * 100 : 25;
      
      return {
        goalsFor: parseFloat(forAvg) || 1.3,
        goalsAgainst: parseFloat(againstAvg) || 1.2,
        form: stats.form || 'DDDDD',
        corners: 5.0,
        cards: parseFloat(stats.cards?.yellow?.total) / (played || 1) || 1.8,
        cleanSheetPct: cleanSheetPct || 25,
        failedToScorePct: failedToScorePct || 25,
        played, wins, draws, losses,
        winRate: played > 0 ? (wins / played) * 100 : 40
      };
    }

    function calculateXG(teamData, oppData, side, apiPred, fsMatch) {
      const attackStrength = teamData.goalsFor / 1.25;
      const defenseWeakness = oppData.goalsAgainst / 1.25;
      
      let xg = 1.25 * attackStrength * defenseWeakness;
      
      const formMultiplier = calculateFormMultiplier(teamData.form);
      xg = xg * 0.80 + xg * formMultiplier * 0.20;
      
      if (teamData.winRate > 60) xg *= 1.08;
      else if (teamData.winRate < 30) xg *= 0.90;
      
      if (oppData.cleanSheetPct > 40) xg *= 0.88;
      else if (oppData.cleanSheetPct < 20) xg *= 1.10;
      
      if (teamData.failedToScorePct > 35) xg *= 0.85;
      else if (teamData.failedToScorePct < 15) xg *= 1.08;
      
      if (apiPred?.predictions?.goals) {
        const apiGoal = side === 'home' ? parseFloat(apiPred.predictions.goals.home) : parseFloat(apiPred.predictions.goals.away);
        if (apiGoal > 0) xg = (xg * 0.65) + (apiGoal * 0.35);
      }
      
      if (fsMatch) {
        const fsXg = side === 'home' ? fsMatch.home_xg : fsMatch.away_xg;
        const fsPpg = side === 'home' ? fsMatch.home_ppg : fsMatch.away_ppg;
        const fsAvgGoals = side === 'home' ? fsMatch.avg_goals_home : fsMatch.avg_goals_away;
        
        if (fsXg && fsXg > 0) {
          xg = (xg * 0.60) + (fsXg * 0.40);
        } else if (fsAvgGoals && fsAvgGoals > 0) {
          xg = (xg * 0.65) + (fsAvgGoals * 0.35);
        } else if (fsPpg && fsPpg > 0) {
          xg = (xg * 0.75) + (fsPpg * 0.6 * 0.25);
        }
      }
      
      return xg;
    }

    function calculateFormMultiplier(form) {
      if (!form || form.length === 0) return 1.0;
      
      const recent = form.slice(0, 5).split('');
      let score = 0;
      let totalWeight = 0;
      
      recent.forEach((r, i) => {
        const weight = Math.pow(0.8, i);
        totalWeight += weight;
        
        if (r === 'W') score += 1.0 * weight;
        else if (r === 'D') score += 0.35 * weight;
        else if (r === 'L') score += 0.0 * weight;
      });
      
      const avgScore = totalWeight > 0 ? score / totalWeight : 0.5;
      return 0.80 + (avgScore * 0.40);
    }

    function analyzeH2H(h2h, homeId) {
      if (!h2h || h2h.length === 0) return { homeMultiplier: 1.0, awayMultiplier: 1.0 };
      
      let hg = 0, ag = 0, totalWeight = 0;
      
      h2h.forEach((m, index) => {
        const weight = Math.pow(0.85, index);
        totalWeight += weight;
        
        const homeGoals = m.goals?.home || 0;
        const awayGoals = m.goals?.away || 0;
        
        if (m.teams?.home?.id === homeId) {
          hg += homeGoals * weight;
          ag += awayGoals * weight;
        } else {
          hg += awayGoals * weight;
          ag += homeGoals * weight;
        }
      });
      
      const avgHome = totalWeight > 0 ? hg / totalWeight : 1.2;
      const avgAway = totalWeight > 0 ? ag / totalWeight : 1.0;
      const avgTotal = (avgHome + avgAway) / 2;
      
      const homeMultiplier = avgTotal > 0.1 ? clamp(0.85, avgHome / avgTotal, 1.15) : 1.0;
      const awayMultiplier = avgTotal > 0.1 ? clamp(0.85, avgAway / avgTotal, 1.15) : 1.0;
      
      return { homeMultiplier, awayMultiplier };
    }

    function summarizeH2H(h2h, homeId) {
      const info = { matches: h2h.length, homeWins: 0, draws: 0, awayWins: 0, totalGoals: 0 };
      h2h.forEach(m => {
        const hg = m.goals?.home || 0, ag = m.goals?.away || 0;
        info.totalGoals += hg + ag;
        if (m.teams?.home?.id === homeId) {
          if (hg > ag) info.homeWins++; else if (hg < ag) info.awayWins++; else info.draws++;
        } else {
          if (ag > hg) info.homeWins++; else if (ag < hg) info.awayWins++; else info.draws++;
        }
      });
      info.avgGoals = info.matches ? (info.totalGoals / info.matches).toFixed(1) : '2.5';
      return info;
    }

    function calcCorners(homeData, awayData, fsMatch) {
      let h = 5.2, a = 4.3;
      
      if (fsMatch) {
        if (fsMatch.home_corners && fsMatch.home_corners > 0) h = fsMatch.home_corners;
        else if (fsMatch.team_a_corners_avg && fsMatch.team_a_corners_avg > 0) h = fsMatch.team_a_corners_avg;
        
        if (fsMatch.away_corners && fsMatch.away_corners > 0) a = fsMatch.away_corners;
        else if (fsMatch.team_b_corners_avg && fsMatch.team_b_corners_avg > 0) a = fsMatch.team_b_corners_avg;
        
        if (fsMatch.corners_avg && fsMatch.corners_avg > 0) {
          const fsTotal = fsMatch.corners_avg;
          const ratio = h / (h + a);
          h = fsTotal * ratio;
          a = fsTotal * (1 - ratio);
        }
      }
      
      const total = h + a;
      const probs = {};
      
      [8.5, 9.5, 10.5, 11.5, 12.5].forEach(line => {
        const diff = total - line;
        const stdDev = 2.5;
        const zScore = diff / stdDev;
        const overProb = 50 + (zScore * 30);
        probs[line] = { 
          over: clamp(12, overProb, 88), 
          under: clamp(12, 100 - overProb, 88) 
        };
      });
      
      return { home: h, away: a, total, probs };
    }

    function calcCards(homeData, awayData, fsMatch) {
      let h = homeData.cards, a = awayData.cards;
      if (fsMatch) {
        if (fsMatch.home_cards) h = fsMatch.home_cards;
        if (fsMatch.away_cards) a = fsMatch.away_cards;
      }
      const total = h + a;
      const probs = {};
      [2.5, 3.5, 4.5, 5.5, 6.5].forEach(line => {
        const diff = total - line;
        probs[line] = { 
          over: clamp(15, 50 + diff * 13, 85), 
          under: clamp(15, 50 - diff * 13, 85) 
        };
      });
      return { home: h, away: a, total, probs };
    }

    // === NUOVA FUNZIONE: EXPECTED SHOTS ===
    function calcExpectedShots(homeXG, awayXG) {
      // Ratio storico: shot on target = xG √ó 1.8
      const homeShots = homeXG * 1.8;
      const awayShots = awayXG * 1.8;
      const totalShots = homeShots + awayShots;
      
      const probs = {};
      [2.5, 3.5, 4.5, 5.5].forEach(line => {
        const diff = totalShots - line;
        const stdDev = 1.5;
        const zScore = diff / stdDev;
        const overProb = 50 + (zScore * 25);
        probs[line] = {
          over: clamp(10, overProb, 90),
          under: clamp(10, 100 - overProb, 90)
        };
      });
      
      return { home: homeShots, away: awayShots, total: totalShots, probs };
    }

    function calc1X2(lH, lA) {
      let pH = 0, pD = 0, pA = 0;
      for (let i = 0; i <= 6; i++) {
        for (let j = 0; j <= 6; j++) {
          const p = poisson(lH, i) * poisson(lA, j);
          if (i > j) pH += p; else if (i === j) pD += p; else pA += p;
        }
      }
      const t = pH + pD + pA;
      return { home: (pH/t)*100, draw: (pD/t)*100, away: (pA/t)*100 };
    }

    function calcBTTS(lH, lA) {
      return clamp(15, (1 - poisson(lH, 0)) * (1 - poisson(lA, 0)) * 100, 85);
    }

    function calcOU(lH, lA) {
      const result = {};
      [1.5, 2.5, 3.5, 4.5].forEach(line => {
        let pU = 0;
        for (let i = 0; i <= 6; i++) {
          for (let j = 0; j <= 6; j++) {
            if (i + j <= Math.floor(line)) pU += poisson(lH, i) * poisson(lA, j);
          }
        }
        result[line] = { over: clamp(5, (1 - pU) * 100, 95), under: clamp(5, pU * 100, 95) };
      });
      return result;
    }

    function calcExactScores(lH, lA) {
      const scores = [];
      const rho = 0.13;
      
      for (let i = 0; i <= 5; i++) {
        for (let j = 0; j <= 5; j++) {
          let p = poisson(lH, i) * poisson(lA, j);
          
          if (i === 0 && j === 0) {
            p *= (1 + lH * lA * rho);
          } else if (i === 0 && j === 1) {
            p *= (1 + lH * rho);
          } else if (i === 1 && j === 0) {
            p *= (1 + lA * rho);
          } else if (i === 1 && j === 1) {
            p *= (1 - rho);
          }
          
          scores.push({ h: i, a: j, p: p * 100 });
        }
      }
      
      const total = scores.reduce((sum, s) => sum + s.p, 0);
      scores.forEach(s => s.p = (s.p / total) * 100);
      
      return scores.sort((a, b) => b.p - a.p);
    }

    function calcMultigol(lH, lA, min, max) {
      let prob = 0;
      for (let i = 0; i <= 6; i++) {
        for (let j = 0; j <= 6; j++) {
          const t = i + j;
          if (t >= min && t <= max) prob += poisson(lH, i) * poisson(lA, j);
        }
      }
      return prob * 100;
    }
    
    function calcAllMultigol(homeXG, awayXG) {
      const ranges = [
        { name: '0-2', min: 0, max: 2 },
        { name: '0-3', min: 0, max: 3 },
        { name: '1-3', min: 1, max: 3 },
        { name: '1-4', min: 1, max: 4 },
        { name: '2-4', min: 2, max: 4 },
        { name: '2-5', min: 2, max: 5 },
        { name: '3-5', min: 3, max: 5 },
        { name: '3-6', min: 3, max: 6 }
      ];
      
      return ranges.map(r => ({
        range: r.name,
        prob: calcMultigol(homeXG, awayXG, r.min, r.max),
        quota: (100 / calcMultigol(homeXG, awayXG, r.min, r.max)).toFixed(2)
      })).sort((a, b) => b.prob - a.prob);
    }
    
    function calcTemporalDistribution(homeXG, awayXG) {
      const homeXG_1T = homeXG * 0.42;
      const homeXG_2T = homeXG * 0.58;
      const awayXG_1T = awayXG * 0.42;
      const awayXG_2T = awayXG * 0.58;
      
      const totXG_1T = homeXG_1T + awayXG_1T;
      const totXG_2T = homeXG_2T + awayXG_2T;
      
      const over05_1T = calcMultigol(homeXG_1T, awayXG_1T, 1, 6);
      const over15_1T = calcMultigol(homeXG_1T, awayXG_1T, 2, 6);
      const over05_2T = calcMultigol(homeXG_2T, awayXG_2T, 1, 6);
      const over15_2T = calcMultigol(homeXG_2T, awayXG_2T, 2, 6);
      
      const piuGol1T = totXG_1T > totXG_2T;
      const probPiuGol = piuGol1T ? 
        (totXG_1T / (totXG_1T + totXG_2T)) * 100 :
        (totXG_2T / (totXG_1T + totXG_2T)) * 100;
      
      return {
        primoTempo: {
          xG: totXG_1T,
          over05: over05_1T,
          over15: over15_1T
        },
        secondoTempo: {
          xG: totXG_2T,
          over05: over05_2T,
          over15: over15_2T
        },
        tempoConPiuGol: piuGol1T ? '1¬∞ Tempo' : '2¬∞ Tempo',
        probTempoConPiuGol: probPiuGol
      };
    }

    function calcTeamMultigol(l, min, max) {
      let prob = 0;
      for (let i = min; i <= max; i++) prob += poisson(l, i);
      return prob * 100;
    }

    function buildPredictions(match, homeXG, awayXG, p1X2, pOU, pBTTS, exactScores, corners, cards) {
      const preds = [];
      const totXG = homeXG + awayXG;
      
      const homeXG_1T = homeXG * 0.45;
      const awayXG_1T = awayXG * 0.45;
      
      const max1X2 = Math.max(p1X2.home, p1X2.draw, p1X2.away);
      let esito = p1X2.home === max1X2 ? '1' : (p1X2.away === max1X2 ? '2' : 'X');
      preds.push({ market: 'Esito 1X2', value: esito, prob: max1X2 });
      
      preds.push({ market: 'GG/NG', value: pBTTS >= 50 ? 'GG' : 'NG', prob: pBTTS >= 50 ? pBTTS : 100-pBTTS });
      
      preds.push({ market: 'O/U 2.5', value: pOU[2.5].over >= 50 ? 'Over 2.5' : 'Under 2.5', prob: Math.max(pOU[2.5].over, pOU[2.5].under) });
      
      preds.push({ market: 'O/U 1.5', value: pOU[1.5].over >= 50 ? 'Over 1.5' : 'Under 1.5', prob: Math.max(pOU[1.5].over, pOU[1.5].under) });
      
      const pOver05_1T = calcOver1T(homeXG_1T, awayXG_1T, 0.5);
      const pOver15_1T = calcOver1T(homeXG_1T, awayXG_1T, 1.5);
      
      preds.push({ market: 'O/U 0.5 1T', value: pOver05_1T >= 50 ? 'Over 0.5 1T' : 'Under 0.5 1T', prob: Math.max(pOver05_1T, 100 - pOver05_1T) });
      
      if (totXG >= 2.5) {
        preds.push({ market: 'O/U 1.5 1T', value: pOver15_1T >= 50 ? 'Over 1.5 1T' : 'Under 1.5 1T', prob: Math.max(pOver15_1T, 100 - pOver15_1T) });
      }
      
      const mg13 = calcMultigol(homeXG, awayXG, 1, 3);
      const mg24 = calcMultigol(homeXG, awayXG, 2, 4);
      preds.push({ market: 'Multigol', value: totXG < 2.8 ? '1-3' : '2-4', prob: totXG < 2.8 ? mg13 : mg24 });
      
      const mgH = calcTeamMultigol(homeXG, 1, 3);
      preds.push({ market: 'MG Casa', value: '1-3', prob: mgH });
      
      const mgA = calcTeamMultigol(awayXG, 1, 3);
      preds.push({ market: 'MG Ospite', value: '1-3', prob: mgA });
      
      const cProb = corners.probs[9.5];
      preds.push({ market: 'Corner', value: cProb.over >= 50 ? 'Over 9.5' : 'Under 9.5', prob: Math.max(cProb.over, cProb.under) });
      
      const cardLine = cards.total > 4 ? 4.5 : 3.5;
      const cardProb = cards.probs[cardLine];
      preds.push({ market: 'Cartellini', value: cardProb.over >= 50 ? `Over ${cardLine}` : `Under ${cardLine}`, prob: Math.max(cardProb.over, cardProb.under) });
      
      preds.push({ market: 'Ris. Esatto', value: `${exactScores[0].h}-${exactScores[0].a}`, prob: exactScores[0].p });
      
      return preds.sort((a, b) => b.prob - a.prob);
    }
    
    function calcOver1T(homeXG_1T, awayXG_1T, line) {
      let pUnder = 0;
      for (let i = 0; i <= 4; i++) {
        for (let j = 0; j <= 4; j++) {
          if (i + j <= Math.floor(line)) {
            pUnder += poisson(homeXG_1T, i) * poisson(awayXG_1T, j);
          }
        }
      }
      return clamp(10, (1 - pUnder) * 100, 90);
    }

    function buildCombos(p1X2, pOU, pBTTS) {
      const combos = [];
      
      const p1X = p1X2.home + p1X2.draw;
      const o15 = pOU[1.5].over;
      combos.push({ value: '1X + Over 1.5', prob: (p1X * o15) / 100, odds: (100 / ((p1X * o15) / 100)).toFixed(2) });
      
      combos.push({ value: '1 + Over 1.5', prob: (p1X2.home * o15) / 100, odds: (100 / ((p1X2.home * o15) / 100)).toFixed(2) });
      
      const u35 = pOU[3.5].under;
      combos.push({ value: 'GG + Under 3.5', prob: (pBTTS * u35) / 100, odds: (100 / ((pBTTS * u35) / 100)).toFixed(2) });
      
      const o25 = pOU[2.5].over;
      combos.push({ value: 'GG + Over 2.5', prob: (pBTTS * o25) / 100, odds: (100 / ((pBTTS * o25) / 100)).toFixed(2) });
      
      return combos.sort((a, b) => b.prob - a.prob);
    }

    // === AI ADVICE ===
    function generateAIAdvice(match, analysis) {
      const { xG, p1X2, pOU, pBTTS, exactScores } = analysis;
      const homeXG = xG.home;
      const awayXG = xG.away;
      const totXG = xG.total;
      
      const advice = {
        pick: '',
        prob: 0,
        confidence: 'medium',
        reasons: [],
        alternatives: []
      };
      
      const homeStrong = homeXG > 1.8;
      const awayWeak = awayXG < 0.8;
      const awayStrong = awayXG > 1.5;
      const homeWeak = homeXG < 1.0;
      const highScoring = totXG >= 3.0;
      const veryHighScoring = totXG >= 3.8;
      const lowScoring = totXG < 2.2;
      const balanced = Math.abs(homeXG - awayXG) < 0.5;
      const ggLikely = pBTTS >= 55 && homeXG > 0.9 && awayXG > 0.9;
      
      if (homeStrong && awayWeak && p1X2.home >= 65) {
        advice.pick = '1 (Vittoria Casa)';
        advice.prob = p1X2.home;
        advice.confidence = p1X2.home >= 75 ? 'high' : 'medium';
        advice.reasons.push({ text: `xG Casa ${homeXG.toFixed(2)} molto superiore`, type: 'positive' });
        advice.reasons.push({ text: `xG Ospite solo ${awayXG.toFixed(2)}`, type: 'positive' });
        advice.reasons.push({ text: `Probabilit√† ${p1X2.home.toFixed(0)}% favorevole`, type: 'positive' });
        
        if (highScoring) {
          advice.alternatives.push({ pick: '1 + Over 1.5', prob: ((p1X2.home * pOU[1.5].over) / 100).toFixed(0) });
        }
        advice.alternatives.push({ pick: '1X', prob: (p1X2.home + p1X2.draw).toFixed(0) });
      }
      else if (awayStrong && homeWeak && p1X2.away >= 60) {
        advice.pick = '2 (Vittoria Ospite)';
        advice.prob = p1X2.away;
        advice.confidence = p1X2.away >= 70 ? 'high' : 'medium';
        advice.reasons.push({ text: `xG Ospite ${awayXG.toFixed(2)} superiore`, type: 'positive' });
        advice.reasons.push({ text: `xG Casa debole ${homeXG.toFixed(2)}`, type: 'positive' });
        
        advice.alternatives.push({ pick: 'X2', prob: (p1X2.away + p1X2.draw).toFixed(0) });
      }
      else if (veryHighScoring && pOU[2.5].over >= 70) {
        advice.pick = 'Over 2.5';
        advice.prob = pOU[2.5].over;
        advice.confidence = pOU[2.5].over >= 80 ? 'high' : 'medium';
        advice.reasons.push({ text: `xG Totale ${totXG.toFixed(2)} molto alto`, type: 'positive' });
        advice.reasons.push({ text: `Entrambe le squadre segnano regolarmente`, type: 'positive' });
        
        advice.alternatives.push({ pick: 'Over 1.5 1T', prob: '60+' });
        advice.alternatives.push({ pick: 'Over 3.5', prob: pOU[3.5].over.toFixed(0) });
        if (ggLikely) advice.alternatives.push({ pick: 'GG', prob: pBTTS.toFixed(0) });
      }
      else if (ggLikely && pBTTS >= 60) {
        advice.pick = 'GG (Entrambe Segnano)';
        advice.prob = pBTTS;
        advice.confidence = pBTTS >= 70 ? 'high' : 'medium';
        advice.reasons.push({ text: `xG Casa ${homeXG.toFixed(2)} - segner√†`, type: 'positive' });
        advice.reasons.push({ text: `xG Ospite ${awayXG.toFixed(2)} - segner√†`, type: 'positive' });
        
        if (highScoring) advice.alternatives.push({ pick: 'GG + Over 2.5', prob: ((pBTTS * pOU[2.5].over) / 100).toFixed(0) });
        advice.alternatives.push({ pick: 'Over 2.5', prob: pOU[2.5].over.toFixed(0) });
      }
      else if (pOU[1.5].over >= 80) {
        advice.pick = 'Over 1.5';
        advice.prob = pOU[1.5].over;
        advice.confidence = 'high';
        advice.reasons.push({ text: `Probabilit√† ${pOU[1.5].over.toFixed(0)}% molto alta`, type: 'positive' });
        advice.reasons.push({ text: `xG Totale ${totXG.toFixed(2)} supporta gol`, type: 'positive' });
        
        advice.alternatives.push({ pick: '1X + Over 1.5', prob: (((p1X2.home + p1X2.draw) * pOU[1.5].over) / 100).toFixed(0) });
      }
      else if ((p1X2.home + p1X2.draw) >= 80) {
        advice.pick = '1X (Casa o Pareggio)';
        advice.prob = p1X2.home + p1X2.draw;
        advice.confidence = 'high';
        advice.reasons.push({ text: `Casa forte con xG ${homeXG.toFixed(2)}`, type: 'positive' });
        advice.reasons.push({ text: `Vittoria ospite improbabile (${p1X2.away.toFixed(0)}%)`, type: 'positive' });
        
        advice.alternatives.push({ pick: '1', prob: p1X2.home.toFixed(0) });
        if (highScoring) advice.alternatives.push({ pick: '1X + Over 1.5', prob: (((p1X2.home + p1X2.draw) * pOU[1.5].over) / 100).toFixed(0) });
      }
      else if (balanced && p1X2.draw >= 28) {
        advice.pick = 'Under 3.5';
        advice.prob = pOU[3.5].under;
        advice.confidence = lowScoring ? 'medium' : 'low';
        advice.reasons.push({ text: `Partita equilibrata (xG simili)`, type: 'neutral' });
        advice.reasons.push({ text: `Possibile pareggio (${p1X2.draw.toFixed(0)}%)`, type: 'neutral' });
        
        advice.alternatives.push({ pick: 'X', prob: p1X2.draw.toFixed(0) });
        advice.alternatives.push({ pick: 'Under 2.5', prob: pOU[2.5].under.toFixed(0) });
      }
      else {
        advice.pick = 'Over 1.5';
        advice.prob = pOU[1.5].over;
        advice.confidence = pOU[1.5].over >= 70 ? 'medium' : 'low';
        advice.reasons.push({ text: `Pronostico pi√π sicuro per questa partita`, type: 'neutral' });
        advice.reasons.push({ text: `xG Totale ${totXG.toFixed(2)}`, type: 'neutral' });
        
        if (p1X2.home >= 55) advice.alternatives.push({ pick: '1X', prob: (p1X2.home + p1X2.draw).toFixed(0) });
      }
      
      if (analysis.quality === 'base') {
        advice.reasons.push({ text: 'Dati statistici limitati', type: 'negative' });
        if (advice.confidence === 'high') advice.confidence = 'medium';
      }
      
      return advice;
    }

    function generateStatisticalAdvice(match, analysis) {
      const { predictions } = analysis;
      const bestPrediction = predictions.reduce((best, current) => {
        return current.prob > best.prob ? current : best;
      }, predictions[0]);
      let confidence = 'medium';
      if (bestPrediction.prob >= 70) confidence = 'high';
      else if (bestPrediction.prob < 55) confidence = 'low';
      const alternatives = predictions
        .filter(p => p.market !== bestPrediction.market)
        .sort((a, b) => b.prob - a.prob)
        .slice(0, 3)
        .map(p => ({ pick: p.value, prob: p.prob.toFixed(0) }));
      return {
        pick: bestPrediction.value,
        market: bestPrediction.market,
        prob: bestPrediction.prob,
        confidence,
        alternatives
      };
    }

    function getProbClass(prob) {
      if (prob >= 65) return 'high';
      if (prob >= 50) return 'mid';
      return 'low';
    }

    // === RENDER FUNCTIONS ===
    function render() {
      document.getElementById('app').innerHTML = `
        ${renderHeader()}
        <main class="main">
          ${state.loading ? renderLoading() :
            state.view === 'leagues' ? renderLeagues() :
            state.view === 'matches' ? renderMatches() :
            renderAnalysis()}
        </main>
        ${renderSlipFloating()}
        ${state.slipModal ? renderSlipModal() : ''}
      `;
      attachEvents();
    }

    function renderHeader() {
      return `
        <header class="header">
          <div class="header-inner">
            <div class="brand">
              <div class="brand-icon">‚öΩ</div>
              <span class="brand-name">BettingPro</span>
            </div>
            <div class="header-right">
              <div class="status-bar">
                <div class="status-item">
                  <span class="status-dot ${state.api.football}"></span>
                  <span>API</span>
                </div>
                <div class="status-item">
                  <span class="status-dot ${state.api.footystats}"></span>
                  <span>Stats</span>
                </div>
              </div>
              <button class="settings-btn" onclick="toggleSettingsPanel()">
                ‚öôÔ∏è <span style="display:none">Impostazioni</span>
              </button>
              <div class="slip-badge" id="openSlip">
                üé´ ${state.slip.length} pronostici
              </div>
            </div>
          </div>
        </header>
        ${renderSettingsPanel()}
      `;
    }
    
    function renderSettingsPanel() {
      const s = state.settings;
      const stats = getTrackingStats();
      return `
        <div class="settings-overlay ${state.settingsOpen ? 'open' : ''}" onclick="toggleSettingsPanel()"></div>
        <div class="settings-panel ${state.settingsOpen ? 'open' : ''}">
          <div class="settings-header">
            <span class="settings-title">‚öôÔ∏è Impostazioni</span>
            <button class="settings-close" onclick="toggleSettingsPanel()">√ó</button>
          </div>
          
          <div class="settings-section">
            <div class="settings-section-title">üìä Win Rate per Segno</div>
            ${renderWinRateByPick(stats)}
          </div>
          
          <div class="settings-section">
            <div class="settings-section-title">üîß Funzionalit√†</div>
            <div class="settings-row">
              <span class="settings-label">Mostra Classifica</span>
              <div class="settings-toggle ${s.showStandings ? 'active' : ''}" 
                onclick="toggleSetting('showStandings')"></div>
            </div>
            <div class="settings-row">
              <span class="settings-label">Mostra Infortunati</span>
              <div class="settings-toggle ${s.showInjuries ? 'active' : ''}" 
                onclick="toggleSetting('showInjuries')"></div>
            </div>
            <div class="settings-row">
              <span class="settings-label">Auto-refresh</span>
              <div class="settings-toggle ${s.autoRefresh ? 'active' : ''}" 
                onclick="toggleSetting('autoRefresh')"></div>
            </div>
          </div>
          
          <div class="settings-section">
            <button class="settings-btn" style="width:100%;margin-top:10px" onclick="resetAllData()">
              üóëÔ∏è Reset tutti i dati
            </button>
          </div>
        </div>
      `;
    }
    
    function renderWinRateByPick(stats) {
      const picks = Object.entries(stats.byPick);
      if (picks.length === 0) {
        return '<div style="text-align:center; color:var(--text-dark); padding:20px;">Nessun pronostico tracciato</div>';
      }
      
      picks.sort((a, b) => b[1].total - a[1].total);
      
      return `
        <div class="winrate-grid">
          ${picks.map(([label, data]) => `
            <div class="winrate-item">
              <div class="winrate-label">${label}</div>
              <div class="winrate-stats">
                <span class="winrate-played">${data.total} giocate</span>
                <span class="winrate-won">‚úÖ ${data.won}</span>
                <span class="winrate-lost">‚ùå ${data.lost}</span>
              </div>
              <div class="winrate-bar">
                <div class="winrate-bar-fill ${parseFloat(data.winRate) >= 50 ? 'good' : 'bad'}" 
                  style="width: ${data.winRate}%"></div>
              </div>
              <div class="winrate-percent">${data.winRate}%</div>
            </div>
          `).join('')}
        </div>
        
        <div class="winrate-summary">
          <div class="winrate-summary-item">
            <span>Totale</span>
            <strong>${stats.total}</strong>
          </div>
          <div class="winrate-summary-item">
            <span>Vinte</span>
            <strong style="color: var(--accent-green)">${stats.won}</strong>
          </div>
          <div class="winrate-summary-item">
            <span>Perse</span>
            <strong style="color: var(--accent-red)">${stats.lost}</strong>
          </div>
          <div class="winrate-summary-item">
            <span>Win Rate</span>
            <strong style="color: var(--accent-cyan)">${stats.winRate}%</strong>
          </div>
        </div>
      `;
    }

    function toggleSetting(key) {
      state.settings[key] = !state.settings[key];
      saveSettings();
      render();
    }
    
    function resetAllData() {
      if (confirm('Sei sicuro di voler cancellare TUTTI i dati?')) {
        localStorage.removeItem('bp2_tracked');
        localStorage.removeItem('bp2_settings');
        localStorage.removeItem('bp2_history');
        localStorage.removeItem('bp2_bankroll');
        localStorage.removeItem('bp2_slip');
        state.trackedBets = [];
        state.slip = [];
        state.settings = {
          thresholds: { '1': 50, 'X': 28, '2': 50, 'GG': 55, 'Over 2.5': 50, 'Over 1.5': 65 },
          showInjuries: true, showStandings: true, autoRefresh: true
        };
        render();
        alert('‚úÖ Dati cancellati');
      }
    }

    function renderLoading() {
      return `<div class="loading"><div class="spinner"></div><div class="loading-text">Caricamento...</div></div>`;
    }

    function renderLeagues() {
      const dayAdvices = state.dayAdvices;
      
      return `
        <div class="date-tabs">
          ${[-1, 0, 1, 2].map(d => `
            <div class="date-tab ${state.selectedDate === d ? 'active' : ''}" data-date="${d}">
              ${getDateLabel(d)} ${d !== 0 ? `(${formatDate(getDateString(d))})` : ''}
            </div>
          `).join('')}
        </div>
        
        <!-- SELEZIONA CAMPIONATO -->
        <div class="panel" style="margin-bottom: 16px;">
          <div class="panel-title">üìã Seleziona Campionato (${state.matches.length} partite)</div>
          ${state.leagues.length === 0 ? `<div class="empty"><div class="empty-icon">üì≠</div>Nessuna partita</div>` : `
            <select class="select-field" id="leagueSelect">
              <option value="">-- Scegli un campionato --</option>
              ${state.leagues.map(l => `<option value="${l.id}">${esc(l.country)} - ${esc(l.name)} (${l.matchCount})</option>`).join('')}
            </select>
          `}
        </div>
        
        <!-- NUOVA SEZIONE: CONSIGLI DEL GIORNO CON TABS -->
        ${(dayAdvices.gg.length > 0 || dayAdvices.one.length > 0 || dayAdvices.two.length > 0 || dayAdvices.x.length > 0) ? `
        <div class="advice-section">
          <div class="advice-tabs">
            <button class="advice-tab ${state.adviceTab === 'gg' ? 'active' : ''}" onclick="switchAdviceTab('gg')">
              ‚öΩ GG (${dayAdvices.gg.length})
            </button>
            <button class="advice-tab ${state.adviceTab === 'one' ? 'active' : ''}" onclick="switchAdviceTab('one')">
              1Ô∏è‚É£ 1 (${dayAdvices.one.length})
            </button>
            <button class="advice-tab ${state.adviceTab === 'two' ? 'active' : ''}" onclick="switchAdviceTab('two')">
              2Ô∏è‚É£ 2 (${dayAdvices.two.length})
            </button>
            <button class="advice-tab ${state.adviceTab === 'x' ? 'active' : ''}" onclick="switchAdviceTab('x')">
              üé≤ X (${dayAdvices.x.length})
            </button>
          </div>
          
          <div class="advice-content ${state.adviceTab === 'gg' ? 'active' : ''}">
            <div class="advice-grid">
              ${dayAdvices.gg.map((advice, idx) => `
                <div class="advice-card" onclick="selectMatch(${advice.match.id})">
                  <div class="advice-card-match">${esc(advice.matchName)}</div>
                  <div class="advice-card-league">${advice.league} ‚Ä¢ ${advice.time}</div>
                  <div class="advice-card-pick">
                    <span class="advice-card-value">GG</span>
                    <span class="advice-card-prob">${advice.prob}%</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
          
          <div class="advice-content ${state.adviceTab === 'one' ? 'active' : ''}">
            <div class="advice-grid">
              ${dayAdvices.one.map((advice, idx) => `
                <div class="advice-card" onclick="selectMatch(${advice.match.id})">
                  <div class="advice-card-match">${esc(advice.matchName)}</div>
                  <div class="advice-card-league">${advice.league} ‚Ä¢ ${advice.time}</div>
                  <div class="advice-card-pick">
                    <span class="advice-card-value">1</span>
                    <span class="advice-card-prob">${advice.prob}%</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
          
          <div class="advice-content ${state.adviceTab === 'two' ? 'active' : ''}">
            <div class="advice-grid">
              ${dayAdvices.two.map((advice, idx) => `
                <div class="advice-card" onclick="selectMatch(${advice.match.id})">
                  <div class="advice-card-match">${esc(advice.matchName)}</div>
                  <div class="advice-card-league">${advice.league} ‚Ä¢ ${advice.time}</div>
                  <div class="advice-card-pick">
                    <span class="advice-card-value">2</span>
                    <span class="advice-card-prob">${advice.prob}%</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
          
          <div class="advice-content ${state.adviceTab === 'x' ? 'active' : ''}">
            <div class="advice-grid">
              ${dayAdvices.x.map((advice, idx) => `
                <div class="advice-card" onclick="selectMatch(${advice.match.id})">
                  <div class="advice-card-match">${esc(advice.matchName)}</div>
                  <div class="advice-card-league">${advice.league} ‚Ä¢ ${advice.time}</div>
                  <div class="advice-card-pick">
                    <span class="advice-card-value">X</span>
                    <span class="advice-card-prob">${advice.prob}%</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        </div>
        ` : ''}
        
        <!-- RADDOPPI DEL GIORNO -->
        ${state.dailyPicks.raddoppi.length > 0 ? `
        <div class="picks-section raddoppi">
          <div class="picks-header">
            <div class="picks-title"><span class="picks-title-icon">üí∞</span> Raddoppi del Giorno</div>
            <span class="picks-count">${state.dailyPicks.raddoppi.length} combo</span>
          </div>
          <div class="raddoppi-grid">
            ${state.dailyPicks.raddoppi.map((r, idx) => `
              <div class="raddoppio-card" data-raddoppio="${idx}">
                <div class="raddoppio-header">
                  <span class="raddoppio-badge">üéØ ${r.size} partite</span>
                  <span class="raddoppio-odds">@${r.totalOdds}</span>
                </div>
                <div class="raddoppio-bets">
                  ${r.bets.map(b => `
                    <div class="raddoppio-bet">
                      <span class="raddoppio-match">${esc(b.shortName)}</span>
                      <span class="raddoppio-pick">${b.bet}</span>
                    </div>
                  `).join('')}
                </div>
                <div class="raddoppio-footer">
                  <span class="raddoppio-prob">${r.totalProb}% prob</span>
                </div>
              </div>
            `).join('')}
          </div>
        </div>
        ` : ''}
      `;
    }

    function switchAdviceTab(tab) {
      state.adviceTab = tab;
      render();
    }

    function renderMatches() {
      const matches =
              const matches = state.matches.filter(m => m.league.id === state.selectedLeague.id).sort((a, b) => a.timestamp - b.timestamp);
      
      return `
        <div class="back-btn" id="backToLeagues">‚Üê Campionati</div>
        <div class="panel">
          <div class="panel-title">‚öΩ ${esc(state.selectedLeague.country)} - ${esc(state.selectedLeague.name)}</div>
          <div class="matches-list">
            ${matches.map(m => {
              const isLive = ['1H','2H','HT','ET','P','LIVE'].includes(m.status);
              return `
                <div class="match-item" data-id="${m.id}">
                  <div class="match-item-left">
                    <div class="match-item-time">${isLive ? m.elapsed+"'" : formatTime(m.date)}</div>
                    <div class="match-item-teams">${esc(m.home.name)} vs ${esc(m.away.name)}</div>
                  </div>
                  <div class="match-item-badge ${isLive ? 'live' : ''}">${isLive ? 'LIVE' : formatDate(m.date)}</div>
                </div>
              `;
            }).join('')}
          </div>
        </div>
      `;
    }

    function renderAnalysis() {
      const m = state.selectedMatch;
      const d = state.analysis;
      if (!d) return `<div class="back-btn" id="backToMatches">‚Üê Partite</div><div class="empty">Errore analisi</div>`;
      
      const ai = generateAIAdvice(m, d);
      const stat = generateStatisticalAdvice(m, d);

      return `
        <div class="back-btn" id="backToMatches">‚Üê Partite</div>
        
        <div class="analysis-hero">
          <div class="hero-league">${esc(m.league.country)} ‚Ä¢ ${esc(m.league.name)} ‚Ä¢ ${formatDateFull(m.date)} ${formatTime(m.date)}</div>
          <div class="hero-match">
            <div class="hero-team">
              ${m.home.logo ? `<img src="${m.home.logo}" class="hero-team-logo" onerror="this.style.display='none'">` : `<div class="hero-team-logo-fallback">${getInitials(m.home.name)}</div>`}
              <div class="hero-team-name">${esc(m.home.name)}</div>
            </div>
            <div class="hero-prediction">
              <div class="hero-score-box">${d.exactScores[0].h}</div>
              <div class="hero-vs">VS</div>
              <div class="hero-score-box">${d.exactScores[0].a}</div>
            </div>
            <div class="hero-team">
              ${m.away.logo ? `<img src="${m.away.logo}" class="hero-team-logo" onerror="this.style.display='none'">` : `<div class="hero-team-logo-fallback">${getInitials(m.away.name)}</div>`}
              <div class="hero-team-name">${esc(m.away.name)}</div>
            </div>
          </div>
        </div>
        
        <!-- DUAL ADVICE: AI + STATISTICAL -->
        <div class="dual-advice-container">

          <!-- AI CONSIGLIO -->
          <div class="ai-advice">
          <div class="ai-header">
            <div class="ai-icon">ü§ñ</div>
            <div class="ai-title-group">
              <div class="ai-title">Consiglio AI</div>
              <div class="ai-subtitle">Analisi basata su xG, statistiche e probabilit√†</div>
            </div>
            <div class="ai-confidence ${ai.confidence}">${ai.confidence === 'high' ? 'üéØ Alta' : ai.confidence === 'medium' ? '‚úì Media' : '‚ö†Ô∏è Bassa'}</div>
          </div>
          
          <div class="ai-pick">
            <div class="ai-pick-label">Pronostico Consigliato</div>
            <div class="ai-pick-value">${ai.pick}</div>
            <div class="ai-pick-prob">${ai.prob.toFixed(0)}% probabilit√†</div>
          </div>
          
          <div class="ai-reasoning">
            <div class="ai-reasoning-title">üí° Perch√© questo pronostico</div>
            <div class="ai-reasoning-list">
              ${ai.reasons.map(r => `
                <div class="ai-reason ${r.type}">
                  <span class="ai-reason-icon">${r.type === 'positive' ? '‚úÖ' : r.type === 'negative' ? '‚ö†Ô∏è' : 'üìä'}</span>
                  <span>${r.text}</span>
                </div>
              `).join('')}
            </div>
          </div>
          
          ${ai.alternatives.length > 0 ? `
            <div class="ai-alternatives">
              <div class="ai-alt-title">Alternative valide:</div>
              <div class="ai-alt-grid">
                ${ai.alternatives.map(a => `
                  <div class="ai-alt-chip">${a.pick}<span>${a.prob}%</span></div>
                `).join('')}
              </div>
            </div>
          ` : ''}
          
          <button class="track-btn ${state.trackedBets.some(b => b.matchId === m.id && b.type === 'prematch') ? 'tracked' : ''}" 
                  onclick="trackPrematchBet(${m.id}, '${esc(m.home.name)} vs ${esc(m.away.name)}', '${esc(ai.pick)}', ${ai.prob.toFixed(0)}, event)"
                  ${state.trackedBets.some(b => b.matchId === m.id && b.type === 'prematch') ? 'disabled' : ''}>
            ${state.trackedBets.some(b => b.matchId === m.id && b.type === 'prematch') ? '‚úÖ Pronostico Tracciato' : 'üéØ GIOCATO - Traccia questo pronostico'}
          </button>
        </div>

        <!-- PRONOSTICO STATISTICO -->
        <div class="statistical-advice">
          <div class="ai-header">
            <div class="ai-icon">üìä</div>
            <div class="ai-title-group">
              <div class="ai-title" style="background: linear-gradient(135deg, var(--accent-cyan), var(--accent-green)); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Pronostico Statistico</div>
              <div class="ai-subtitle">Basato solo sulla probabilit√† pi√π alta</div>
            </div>
            <div class="ai-confidence ${stat.confidence}">${stat.confidence === 'high' ? 'üéØ Alta' : stat.confidence === 'medium' ? '‚úì Media' : '‚ö†Ô∏è Bassa'}</div>
          </div>

          <div class="ai-pick">
            <div class="ai-pick-label">Pronostico con Prob. Massima</div>
            <div class="ai-pick-value">${stat.pick}</div>
            <div class="ai-pick-prob">${stat.prob.toFixed(0)}% probabilit√†</div>
          </div>

          <div class="ai-reasoning">
            <div class="ai-reasoning-title">üìà Dettagli Statistici</div>
            <div class="ai-reasoning-list">
              <div class="ai-reason positive">
                <span class="ai-reason-icon">‚úÖ</span>
                <span>Mercato: ${stat.market}</span>
              </div>
              <div class="ai-reason positive">
                <span class="ai-reason-icon">üìä</span>
                <span>Probabilit√† pi√π alta tra tutti i pronostici</span>
              </div>
              <div class="ai-reason neutral">
                <span class="ai-reason-icon">üî¢</span>
                <span>Basato su calcoli Poisson e xG</span>
              </div>
            </div>
          </div>

          ${stat.alternatives.length > 0 ? `
            <div class="ai-alternatives">
              <div class="ai-alt-title">Top 3 alternative:</div>
              <div class="ai-alt-grid">
                ${stat.alternatives.map(a => `
                  <div class="ai-alt-chip">${a.pick}<span>${a.prob}%</span></div>
                `).join('')}
              </div>
            </div>
          ` : ''}
        </div>

      </div>
      
      <!-- STORICO VARIAZIONI -->
      ${renderHistorySection(m.id)}
        
        <div class="combo-panel">
          <div class="combo-title">üî• Combo Suggerite</div>
          <div class="combo-grid">
            ${d.combos.map(c => `
              <div class="combo-card ${isInSlip(m.id, 'combo_'+c.value) ? 'selected' : ''}" data-market="combo_${c.value}" data-value="${c.value}" data-prob="${c.prob.toFixed(0)}">
                <div class="combo-value">${c.value}</div>
                <div class="combo-stats">
                  <span class="combo-prob">${c.prob.toFixed(0)}%</span>
                  <span class="combo-odds">@${c.odds}</span>
                </div>
              </div>
            `).join('')}
          </div>
        </div>
        
        <div class="analysis-grid">
          <div class="analysis-card">
            <div class="card-title">
              <div class="card-title-icon">üìä</div>
              <span>Expected Goals</span>
              <span class="card-title-badge">${d.xG.total.toFixed(2)}</span>
            </div>
            <div class="prob-row">
              <span class="prob-label">${m.home.name.split(' ')[0]}</span>
              <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${(d.xG.home/3)*100}%"></div></div>
              <span class="prob-value">${d.xG.home.toFixed(2)}</span>
            </div>
            <div class="prob-row">
              <span class="prob-label">${m.away.name.split(' ')[0]}</span>
              <div class="prob-bar-track"><div class="prob-bar-fill green" style="width:${(d.xG.away/3)*100}%"></div></div>
              <span class="prob-value">${d.xG.away.toFixed(2)}</span>
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">üéØ</div><span>1X2</span></div>
            <div class="prob-row">
              <span class="prob-label">1 Casa</span>
              <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${d.p1X2.home}%"></div></div>
              <span class="prob-value">${d.p1X2.home.toFixed(0)}%</span>
            </div>
            <div class="prob-row">
              <span class="prob-label">X Pari</span>
              <div class="prob-bar-track"><div class="prob-bar-fill yellow" style="width:${d.p1X2.draw}%"></div></div>
              <span class="prob-value">${d.p1X2.draw.toFixed(0)}%</span>
            </div>
            <div class="prob-row">
              <span class="prob-label">2 Ospite</span>
              <div class="prob-bar-track"><div class="prob-bar-fill purple" style="width:${d.p1X2.away}%"></div></div>
              <span class="prob-value">${d.p1X2.away.toFixed(0)}%</span>
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">‚öΩ</div><span>Over/Under & GG</span></div>
            ${[1.5, 2.5, 3.5].map(l => `
              <div class="prob-row">
                <span class="prob-label">O/U ${l}</span>
                <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${d.pOU[l].over}%"></div></div>
                <span class="prob-value">${d.pOU[l].over.toFixed(0)}%</span>
              </div>
            `).join('')}
            <div class="prob-row">
              <span class="prob-label">GG</span>
              <div class="prob-bar-track"><div class="prob-bar-fill green" style="width:${d.pBTTS}%"></div></div>
              <span class="prob-value">${d.pBTTS.toFixed(0)}%</span>
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">üö©</div><span>Corner</span></div>
            <div class="stat-grid">
              <div class="stat-box"><div class="stat-box-label">Casa</div><div class="stat-box-value">${d.corners.home.toFixed(1)}</div><div class="stat-box-sub">corner</div></div>
              <div class="stat-box"><div class="stat-box-label">Tot</div><div class="stat-box-value">${d.corners.total.toFixed(1)}</div><div class="stat-box-sub">corner</div></div>
              <div class="stat-box"><div class="stat-box-label">Ospite</div><div class="stat-box-value">${d.corners.away.toFixed(1)}</div><div class="stat-box-sub">corner</div></div>
            </div>
            <div style="margin-top:12px">
              ${[9.5, 10.5, 11.5].map(line => `
                <div class="prob-row" style="margin-bottom:8px">
                  <span class="prob-label">O/U ${line}</span>
                  <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${d.corners.probs[line].over}%"></div></div>
                  <span class="prob-value">${d.corners.probs[line].over.toFixed(0)}%</span>
                </div>
              `).join('')}
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">üé¥</div><span>Cartellini</span></div>
            <div class="stat-grid">
              <div class="stat-box"><div class="stat-box-label">Casa</div><div class="stat-box-value">${d.cards.home.toFixed(1)}</div><div class="stat-box-sub">cart.</div></div>
              <div class="stat-box"><div class="stat-box-label">Tot</div><div class="stat-box-value">${d.cards.total.toFixed(1)}</div><div class="stat-box-sub">cart.</div></div>
              <div class="stat-box"><div class="stat-box-label">Ospite</div><div class="stat-box-value">${d.cards.away.toFixed(1)}</div><div class="stat-box-sub">cart.</div></div>
            </div>
            <div style="margin-top:12px">
              ${[3.5, 4.5, 5.5].map(line => `
                <div class="prob-row" style="margin-bottom:8px">
                  <span class="prob-label">O/U ${line}</span>
                  <div class="prob-bar-track"><div class="prob-bar-fill yellow" style="width:${d.cards.probs[line].over}%"></div></div>
                  <span class="prob-value">${d.cards.probs[line].over.toFixed(0)}%</span>
                </div>
              `).join('')}
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">üéØ</div><span>Tiri in Porta</span></div>
            <div class="stat-grid">
              <div class="stat-box"><div class="stat-box-label">Casa</div><div class="stat-box-value">${d.shots.home.toFixed(1)}</div><div class="stat-box-sub">tiri</div></div>
              <div class="stat-box"><div class="stat-box-label">Tot</div><div class="stat-box-value">${d.shots.total.toFixed(1)}</div><div class="stat-box-sub">tiri</div></div>
              <div class="stat-box"><div class="stat-box-label">Ospite</div><div class="stat-box-value">${d.shots.away.toFixed(1)}</div><div class="stat-box-sub">tiri</div></div>
            </div>
            <div style="margin-top:12px">
              ${[2.5, 3.5, 4.5].map(line => `
                <div class="prob-row" style="margin-bottom:8px">
                  <span class="prob-label">O/U ${line}</span>
                  <div class="prob-bar-track"><div class="prob-bar-fill purple" style="width:${d.shots.probs[line].over}%"></div></div>
                  <span class="prob-value">${d.shots.probs[line].over.toFixed(0)}%</span>
                </div>
              `).join('')}
            </div>
          </div>
          
          <div class="analysis-card wide">
            <div class="card-title"><div class="card-title-icon">üé∞</div><span>Risultati Esatti</span></div>
            <div class="scores-grid">
              ${d.exactScores.map((s, i) => `
                <div class="score-box ${i === 0 ? 'highlight' : ''}">
                  <div class="score-box-value">${s.h}-${s.a}</div>
                  <div class="score-box-prob">${s.p.toFixed(1)}%</div>
                </div>
              `).join('')}
            </div>
            
            <!-- MG BOX SOTTO RISULTATI ESATTI -->
            <div class="mg-compact-grid">
              <div class="mg-compact-box">
                <div class="mg-compact-label">üè† ${m.home.name.split(' ')[0]}</div>
                <div class="mg-compact-range">${d.multigoalHome.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).range}</div>
                <div class="mg-compact-prob">${d.multigoalHome.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).prob.toFixed(0)}%</div>
              </div>
              <div class="mg-compact-box">
                <div class="mg-compact-label">‚úàÔ∏è ${m.away.name.split(' ')[0]}</div>
                <div class="mg-compact-range">${d.multigoalAway.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).range}</div>
                <div class="mg-compact-prob">${d.multigoalAway.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).prob.toFixed(0)}%</div>
              </div>
            </div>
          </div>
          
          <div class="analysis-card wide">
            <div class="card-title"><div class="card-title-icon">üìä</div><span>Multigoal Range</span></div>
            <div class="multigoal-grid">
              ${d.multigoal ? d.multigoal.slice(0, 6).map((mg, i) => `
                <div class="multigoal-box ${i === 0 ? 'best' : ''}">
                  <div class="multigoal-range">${mg.range}</div>
                  <div class="multigoal-prob">${mg.prob.toFixed(0)}%</div>
                  <div class="multigoal-quota">@${mg.quota}</div>
                </div>
              `).join('') : '<div>N/A</div>'}
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">‚è±Ô∏è</div><span>Gol per Tempo</span></div>
            ${d.temporalDistribution ? `
              <div class="prob-row">
                <span class="prob-label">Over 0.5 1¬∞T</span>
                <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${d.temporalDistribution.primoTempo.over05}%"></div></div>
                <span class="prob-value">${d.temporalDistribution.primoTempo.over05.toFixed(0)}%</span>
              </div>
              <div class="prob-row">
                <span class="prob-label">Over 0.5 2¬∞T</span>
                <div class="prob-bar-track"><div class="prob-bar-fill green" style="width:${d.temporalDistribution.secondoTempo.over05}%"></div></div>
                <span class="prob-value">${d.temporalDistribution.secondoTempo.over05.toFixed(0)}%</span>
              </div>
              <div class="prob-row">
                <span class="prob-label">Over 1.5 1¬∞T</span>
                <div class="prob-bar-track"><div class="prob-bar-fill yellow" style="width:${d.temporalDistribution.primoTempo.over15}%"></div></div>
                <span class="prob-value">${d.temporalDistribution.primoTempo.over15.toFixed(0)}%</span>
              </div>
              <div class="tempo-highlight">
                <span>‚ö° Tempo con pi√π gol:</span>
                <strong>${d.temporalDistribution.tempoConPiuGol}</strong>
                <span class="tempo-prob">(${d.temporalDistribution.probTempoConPiuGol.toFixed(0)}%)</span>
              </div>
            ` : '<div>N/A</div>'}
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">üìà</div><span>Forma + Info</span></div>
            <div class="form-display">
              <div class="form-team">
                <span class="form-team-name">${m.home.name.split(' ')[0]}</span>
                <span class="form-string">${d.homeForm ? d.homeForm.split('').map(c => 
                  c === 'W' ? '<span class="form-w">V</span>' : 
                  c === 'D' ? '<span class="form-d">P</span>' : 
                  '<span class="form-l">S</span>'
                ).join('') : 'N/A'}</span>
              </div>
              <div class="form-team">
                <span class="form-team-name">${m.away.name.split(' ')[0]}</span>
                <span class="form-string">${d.awayForm ? d.awayForm.split('').map(c => 
                  c === 'W' ? '<span class="form-w">V</span>' : 
                  c === 'D' ? '<span class="form-d">P</span>' : 
                  '<span class="form-l">S</span>'
                ).join('') : 'N/A'}</span>
              </div>
            </div>
          </div>
          
          <!-- CLASSIFICA E MOTIVAZIONE -->
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">üèÜ</div><span>Classifica</span></div>
            ${d.homePosition ? `
              <div class="standings-card">
                <div class="standings-header">
                  <div>
                    <span style="font-weight:600; font-size:0.85rem;">${m.home.name.split(' ')[0]}</span>
                    <span class="standings-position">${d.homePosition.position}¬∞<sup>/${d.homePosition.totalTeams}</sup></span>
                  </div>
                  <span class="motivation-badge ${d.homePosition.motivationColor}">${d.homePosition.motivationText}</span>
                </div>
                <div class="standings-stats">
                  <span class="standings-stat">üìä ${d.homePosition.points} pt</span>
                  <span class="standings-stat">‚úÖ ${d.homePosition.won}V</span>
                  <span class="standings-stat">‚ûñ ${d.homePosition.draw}P</span>
                  <span class="standings-stat">‚ùå ${d.homePosition.lost}S</span>
                </div>
              </div>
            ` : '<div class="standings-card"><span style="color:var(--text-dark)">Non disponibile</span></div>'}
            ${d.awayPosition ? `
              <div class="standings-card">
                <div class="standings-header">
                  <div>
                    <span style="font-weight:600; font-size:0.85rem;">${m.away.name.split(' ')[0]}</span>
                    <span class="standings-position">${d.awayPosition.position}¬∞<sup>/${d.awayPosition.totalTeams}</sup></span>
                  </div>
                  <span class="motivation-badge ${d.awayPosition.motivationColor}">${d.awayPosition.motivationText}</span>
                </div>
                <div class="standings-stats">
                  <span class="standings-stat">üìä ${d.awayPosition.points} pt</span>
                  <span class="standings-stat">‚úÖ ${d.awayPosition.won}V</span>
                  <span class="standings-stat">‚ûñ ${d.awayPosition.draw}P</span>
                  <span class="standings-stat">‚ùå ${d.awayPosition.lost}S</span>
                </div>
              </div>
            ` : ''}
          </div>
          
          <!-- INFORTUNATI -->
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">üè•</div><span>Assenze</span></div>
            <div class="injuries-card" style="margin-bottom: 8px;">
              <div class="injuries-header">
                <span>üè† ${m.home.name.split(' ')[0]}</span>
              </div>
              ${d.homeInjuries && d.homeInjuries.length > 0 ? `
                <div class="injuries-list">
                  ${d.homeInjuries.slice(0, 5).map(inj => `
                    <span class="injury-chip">‚ùå ${inj.player}</span>
                  `).join('')}
                  ${d.homeInjuries.length > 5 ? `<span class="injury-chip">+${d.homeInjuries.length - 5} altri</span>` : ''}
                </div>
              ` : '<span class="no-injuries">‚úÖ Rosa completa</span>'}
            </div>
            <div class="injuries-card">
              <div class="injuries-header">
                <span>‚úàÔ∏è ${m.away.name.split(' ')[0]}</span>
              </div>
              ${d.awayInjuries && d.awayInjuries.length > 0 ? `
                <div class="injuries-list">
                  ${d.awayInjuries.slice(0, 5).map(inj => `
                    <span class="injury-chip">‚ùå ${inj.player}</span>
                  `).join('')}
                  ${d.awayInjuries.length > 5 ? `<span class="injury-chip">+${d.awayInjuries.length - 5} altri</span>` : ''}
                </div>
              ` : '<span class="no-injuries">‚úÖ Rosa completa</span>'}
            </div>
          </div>
        </div>
        
        <div class="predictions-panel">
          <div class="predictions-header">
            <div class="predictions-title">‚öΩ PRONOSTICI AI</div>
            <div class="predictions-subtitle">Clicca per aggiungere alla schedina</div>
            <div class="predictions-legend">
              <div class="legend-item"><span class="legend-dot high"></span> Alta (>65%)</div>
              <div class="legend-item"><span class="legend-dot mid"></span> Media (50-65%)</div>
              <div class="legend-item"><span class="legend-dot low"></span> Bassa (<50%)</div>
            </div>
          </div>
          <div class="predictions-grid">
            ${d.predictions.map(p => `
              <div class="prediction-card ${isInSlip(m.id, p.market) ? 'selected' : ''}" data-market="${p.market}" data-value="${p.value}" data-prob="${p.prob.toFixed(0)}">
                <div class="prediction-market">${p.market}</div>
                <div class="prediction-value">${p.value}</div>
                <div class="prediction-prob ${getProbClass(p.prob)}">${p.prob.toFixed(0)}%</div>
              </div>
            `).join('')}
          </div>
        </div>
      `;
    }

    function renderSlipFloating() {
      if (state.slip.length === 0) return '';
      return `
        <div class="slip-floating">
          <div class="slip-count">üé´ ${state.slip.length} pronostici</div>
          <button class="slip-btn primary" id="viewSlip">üìã Vedi</button>
          <button class="slip-btn secondary" id="copySlip">üìã Copia</button>
          <button class="slip-btn danger" id="clearSlip">üóëÔ∏è</button>
        </div>
      `;
    }

    function renderSlipModal() {
      const totalProb = state.slip.reduce((acc, s) => acc * (s.prob / 100), 1) * 100;
      return `
        <div class="slip-modal" id="slipModal">
          <div class="slip-modal-content">
            <div class="slip-modal-header">
              <div class="slip-modal-title">üé´ La Tua Schedina</div>
              <button class="slip-modal-close" id="closeSlip">√ó</button>
            </div>
            <div class="slip-modal-body">
              ${state.slip.map(s => `
                <div class="slip-item">
                  <div class="slip-item-info">
                    <div class="slip-item-match">${esc(s.matchName)}</div>
                    <div class="slip-item-bet">${s.market}: ${s.value}</div>
                    <div class="slip-item-prob">${s.prob}%</div>
                  </div>
                  <button class="slip-item-remove" data-key="${s.key}">√ó</button>
                </div>
              `).join('')}
              <div class="slip-total">
                <div class="slip-total-label">Probabilit√† Combinata</div>
                <div class="slip-total-value">${totalProb.toFixed(2)}%</div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function attachEvents() {
      // Date tabs
      document.querySelectorAll('.date-tab[data-date]').forEach(tab => {
        tab.addEventListener('click', () => {
          loadMatches(parseInt(tab.dataset.date));
        });
      });
      
      // League select
      document.getElementById('leagueSelect')?.addEventListener('change', e => {
        const id = parseInt(e.target.value);
        if (id) {
          state.selectedLeague = state.leagues.find(l => l.id === id);
          state.view = 'matches';
          render();
        }
      });
      
      // Back buttons
      document.getElementById('backToLeagues')?.addEventListener('click', () => {
        state.view = 'leagues';
        state.selectedLeague = null;
        render();
      });
      
      document.getElementById('backToMatches')?.addEventListener('click', () => {
        state.view = 'matches';
        state.selectedMatch = null;
        state.analysis = null;
        render();
      });
      
      // Match items
      document.querySelectorAll('.match-item').forEach(el => {
        el.addEventListener('click', () => {
          const m = state.matches.find(x => x.id === parseInt(el.dataset.id));
          if (m) analyzeMatch(m);
        });
      });
      
      // Advice cards - clicca per analizzare
      document.querySelectorAll('.advice-card').forEach(el => {
        el.addEventListener('click', () => {
          // Il click √® gi√† gestito dal onclick inline
        });
      });
      
      // Predictions click to add
      document.querySelectorAll('.prediction-card, .combo-card').forEach(el => {
        el.addEventListener('click', () => {
          const m = state.selectedMatch;
          if (m) addToSlip(m, el.dataset.market, el.dataset.value, parseFloat(el.dataset.prob));
        });
      });
      
      // Raddoppi click
      document.querySelectorAll('.raddoppio-card').forEach(el => {
        el.addEventListener('click', () => {
          const idx = parseInt(el.dataset.raddoppio);
          const raddoppio = state.dailyPicks.raddoppi[idx];
          if (raddoppio) {
            raddoppio.bets.forEach(b => {
              addToSlip(b.match, 'radd_' + b.bet, b.bet, b.prob);
            });
          }
        });
      });
      
      // Slip actions
      document.getElementById('openSlip')?.addEventListener('click', () => { state.slipModal = true; render(); });
      document.getElementById('viewSlip')?.addEventListener('click', () => { state.slipModal = true; render(); });
      document.getElementById('closeSlip')?.addEventListener('click', () => { state.slipModal = false; render(); });
      document.getElementById('slipModal')?.addEventListener('click', e => { if (e.target.id === 'slipModal') { state.slipModal = false; render(); }});
      document.getElementById('clearSlip')?.addEventListener('click', clearSlip);
      
      document.getElementById('copySlip')?.addEventListener('click', () => {
        const text = state.slip.map(s => `${s.matchName}: ${s.market} ${s.value} (${s.prob}%)`).join('\n');
        navigator.clipboard.writeText(text);
        alert('Schedina copiata!');
      });
      
      // Remove from slip
      document.querySelectorAll('.slip-item-remove').forEach(btn => {
        btn.addEventListener('click', () => removeFromSlip(btn.dataset.key));
      });
    }

    // === INIT ===
    async function init() {
      console.log('üöÄ BettingPro v6 starting...');
      
      await checkAPIStatus();
      await loadSlipFromFirebase();
      await loadTrackingFromFirebase();
      
      render();
      await loadMatches(0);
      
      await checkPendingResults();
      
      setInterval(() => {
        checkPendingResults();
      }, 10 * 60 * 1000);
    }

    init();
  </script>
</body>
</html>

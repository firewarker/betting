<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BettingPro - AI Betting Intelligence</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  
  <!-- Chart.js per grafici interattivi -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  
  <style>
    :root {
      /* === ORACLE DARK THEME === */
      --bg-dark: #080c14;
      --bg-card: #0e1420;
      --bg-card-light: #111827;
      --bg-input: #1a2235;
      --accent-cyan: #00d4ff;
      --accent-blue: #3b82f6;
      --accent-green: #00e5a0;
      --accent-yellow: #fbbf24;
      --accent-red: #f87171;
      --accent-purple: #a78bfa;
      --accent-gold: #f59e0b;
      --accent-emerald: #10b981;
      --text: #e2e8f0;
      --text-white: #f8fafc;
      --text-gray: #94a3b8;
      --text-dark: #64748b;
      --border: rgba(255,255,255,0.07);
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.4);
      --shadow-md: 0 4px 16px rgba(0,0,0,0.5);
      --shadow-lg: 0 10px 30px rgba(0,0,0,0.6);
      --glow-cyan: 0 0 24px rgba(0,212,255,0.25);
      --glow-gold: 0 0 24px rgba(245,158,11,0.3);
      --glow-green: 0 0 24px rgba(0,229,160,0.25);
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, sans-serif;
      background: var(--bg-dark);
      background-image: 
        radial-gradient(ellipse at top left, rgba(0,212,255,0.06) 0%, transparent 55%),
        radial-gradient(ellipse at bottom right, rgba(0,229,160,0.05) 0%, transparent 55%),
        radial-gradient(ellipse at center, rgba(245,158,11,0.03) 0%, transparent 60%);
      color: var(--text);
      min-height: 100vh;
      padding-bottom: 100px;
    }
    .header {
      background: rgba(8,12,20,0.96);
      backdrop-filter: blur(24px);
      border-bottom: 1px solid rgba(0,212,255,0.12);
      padding: 12px 24px;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 2px 20px rgba(0,0,0,0.5), 0 1px 0 rgba(0,212,255,0.1);
    }
    .header-inner {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
    }
    .brand { display: flex; align-items: center; gap: 12px; }
    .brand-icon {
      width: 40px; height: 40px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      border-radius: 10px;
      display: flex; align-items: center; justify-content: center;
      font-size: 1.3rem;
    }
    .brand-name {
      font-size: 1.3rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .header-right { display: flex; align-items: center; gap: 16px; }
    .status-bar { display: flex; gap: 12px; }
    .status-item { display: flex; align-items: center; gap: 6px; font-size: 0.7rem; color: var(--text-dark); }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--text-dark); }
    .status-dot.online { background: var(--accent-green); box-shadow: 0 0 8px var(--accent-green); }
    .status-dot.loading { background: var(--accent-yellow); animation: blink 1s infinite; }
    @keyframes blink { 0%,100%{opacity:1} 50%{opacity:.3} }
    .slip-badge {
      display: flex; align-items: center; gap: 8px;
      padding: 8px 16px;
      background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
      border-radius: 20px;
      font-size: 0.8rem; font-weight: 700;
      cursor: pointer;
      color: white;
      box-shadow: 0 2px 8px rgba(16,185,129,0.3);
      transition: all 0.2s;
    }
    .slip-badge:hover { 
      transform: scale(1.05); 
      box-shadow: 0 4px 12px rgba(16,185,129,0.4);
    }
    .main { max-width: 1400px; margin: 0 auto; padding: 24px; }
    .date-tabs {
      display: flex; gap: 8px; margin-bottom: 20px; flex-wrap: wrap;
    }
    .date-tab {
      padding: 10px 20px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.85rem; font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .date-tab:hover { 
      border-color: var(--accent-cyan); 
      color: var(--accent-cyan);
      box-shadow: 0 2px 8px rgba(2,132,199,0.15);
    }
    .date-tab.active {
      background: linear-gradient(135deg, rgba(2,132,199,0.12), rgba(59,130,246,0.12));
      border-color: var(--accent-cyan);
      color: var(--accent-cyan);
      border-width: 2px;
      box-shadow: 0 2px 8px rgba(2,132,199,0.2);
    }
    .panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
      transition: box-shadow 0.2s;
    }
    .panel:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    }
    .panel-title { font-size: 1rem; font-weight: 700; margin-bottom: 16px; color: var(--accent-cyan); }
    .select-field {
      width: 100%;
      padding: 14px 18px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-white);
      font-size: 0.95rem;
      cursor: pointer;
    }
    .select-field:focus { outline: none; border-color: var(--accent-cyan); }
    .matches-list { display: flex; flex-direction: column; gap: 10px; }
    .match-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 18px;
      background: var(--bg-card-light);
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .match-item:hover {
      border-color: var(--accent-cyan);
      transform: translateX(4px);
      box-shadow: 0 2px 8px rgba(2,132,199,0.15);
      background: var(--bg-card);
    }
    .match-item-left { display: flex; align-items: center; gap: 14px; flex: 1; min-width: 0; }
    .match-item-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      color: var(--accent-cyan);
      min-width: 45px;
    }
    .match-item-teams { font-weight: 600; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .match-item-badge {
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.65rem;
      font-weight: 700;
      background: var(--bg-input);
      color: var(--text-gray);
      flex-shrink: 0;
    }
    .match-item-badge.live { background: var(--accent-red); color: white; }
    .back-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 20px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.85rem;
      cursor: pointer;
      margin-bottom: 20px;
      transition: all 0.2s;
    }
    .back-btn:hover { 
      border-color: var(--accent-cyan); 
      color: var(--accent-cyan); 
      box-shadow: 0 2px 8px rgba(2,132,199,0.15);
      transform: translateX(-2px);
    }
    .analysis-hero {
      background: linear-gradient(145deg, var(--bg-card), var(--bg-card-light));
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 30px;
      margin-bottom: 20px;
      text-align: center;
      box-shadow: 0 4px 16px rgba(0,0,0,0.06);
    }
    .hero-league { font-size: 0.8rem; color: var(--text-dark); margin-bottom: 20px; }
    .hero-match { display: flex; align-items: center; justify-content: center; gap: 24px; margin-bottom: 20px; flex-wrap: wrap; }
    .hero-team { display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .hero-team-logo { width: 60px; height: 60px; object-fit: contain; }
    .hero-team-logo-fallback {
      width: 60px; height: 60px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      border-radius: 14px;
      display: flex; align-items: center; justify-content: center;
      font-weight: 700; font-size: 1rem;
    }
    .hero-team-name { font-size: 1rem; font-weight: 700; max-width: 120px; text-align: center; }
    
    /* MG NELL'HERO */
    .hero-mg-section {
      display: flex;
      gap: 16px;
      justify-content: center;
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    .hero-mg-box {
      background: linear-gradient(135deg, rgba(217,119,6,0.1), rgba(16,185,129,0.1));
      border: 2px solid var(--accent-gold);
      border-radius: 12px;
      padding: 12px 20px;
      text-align: center;
      min-width: 120px;
      box-shadow: 0 2px 8px rgba(217,119,6,0.15);
    }
    .hero-mg-label {
      font-size: 0.75rem;
      color: #b45309;
      margin-bottom: 4px;
      font-weight: 600;
    }
    .hero-mg-value {
      font-size: 1.3rem;
      font-weight: 800;
      color: #d97706;
    }
    .hero-mg-prob {
      font-size: 0.85rem;
      color: var(--accent-emerald);
      font-family: 'JetBrains Mono', monospace;
      font-weight: 700;
    }
    
    .hero-prediction { display: flex; align-items: center; gap: 10px; }
    .hero-score-box {
      width: 50px; height: 50px;
      background: var(--bg-input);
      border: 2px solid var(--accent-cyan);
      border-radius: 12px;
      display: flex; align-items: center; justify-content: center;
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.5rem; font-weight: 700;
      box-shadow: 0 2px 8px rgba(2,132,199,0.2);
      color: var(--accent-cyan);
    }
    .hero-vs { 
      padding: 6px 12px; 
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue)); 
      border-radius: 6px; 
      font-weight: 700; 
      font-size: 0.8rem; 
      color: white;
      box-shadow: 0 2px 6px rgba(59,130,246,0.3);
    }
    .analysis-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; margin-bottom: 20px; }
    .analysis-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
      transition: all 0.2s;
    }
    .analysis-card:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      transform: translateY(-2px);
    }
    .analysis-card.wide { grid-column: 1 / -1; }
    .card-title {
      display: flex; align-items: center; gap: 10px;
      margin-bottom: 16px;
      font-size: 0.9rem; font-weight: 700;
    }
    .card-title-icon {
      width: 32px; height: 32px;
      background: linear-gradient(135deg, rgba(2,132,199,0.15), rgba(59,130,246,0.15));
      border-radius: 8px;
      display: flex; align-items: center; justify-content: center;
      font-size: 1rem;
      box-shadow: 0 2px 6px rgba(2,132,199,0.15);
    }
    .card-title-badge {
      margin-left: auto;
      padding: 4px 10px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      border-radius: 6px;
      font-size: 0.7rem; font-weight: 700;
      color: white;
      box-shadow: 0 2px 4px rgba(2,132,199,0.3);
    }
    .prob-row { display: flex; align-items: center; gap: 10px; margin-bottom: 12px; }
    .prob-row:last-child { margin-bottom: 0; }
    .prob-label { width: 80px; font-size: 0.8rem; color: var(--text-gray); font-weight: 600; }
    .prob-bar-track { flex: 1; height: 10px; background: var(--bg-input); border-radius: 6px; overflow: hidden; box-shadow: inset 0 1px 3px rgba(0,0,0,0.08); }
    .prob-bar-fill { height: 100%; border-radius: 6px; transition: width 0.3s; }
    .prob-bar-fill.cyan { background: linear-gradient(90deg, #0284c7, #3b82f6); box-shadow: 0 2px 4px rgba(2,132,199,0.3); }
    .prob-bar-fill.green { background: linear-gradient(90deg, #10b981, #059669); box-shadow: 0 2px 4px rgba(16,185,129,0.3); }
    .prob-bar-fill.yellow { background: linear-gradient(90deg, #f59e0b, #d97706); box-shadow: 0 2px 4px rgba(245,158,11,0.3); }
    .prob-bar-fill.purple { background: linear-gradient(90deg, #8b5cf6, #7c3aed); box-shadow: 0 2px 4px rgba(139,92,246,0.3); }
    .prob-value {
      width: 50px; text-align: right;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem; font-weight: 700;
      color: var(--accent-cyan);
    }
    .stat-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
    .stat-box {
      background: var(--bg-card-light);
      border-radius: 10px;
      padding: 12px;
      text-align: center;
      border: 1px solid var(--border);
      transition: all 0.2s;
    }
    .stat-box:hover {
      border-color: var(--accent-cyan);
      box-shadow: 0 2px 8px rgba(2,132,199,0.15);
    }
    .stat-box-label { font-size: 0.65rem; color: var(--text-gray); margin-bottom: 4px; text-transform: uppercase; font-weight: 600; }
    .stat-box-value { font-family: 'JetBrains Mono', monospace; font-size: 1.2rem; font-weight: 800; color: var(--accent-cyan); }
    .stat-box-sub { font-size: 0.6rem; color: var(--text-gray); margin-top: 2px; }
    .scores-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 8px; }
    .score-box {
      background: var(--bg-card-light);
      border-radius: 8px;
      padding: 10px 6px;
      text-align: center;
      border: 1px solid var(--border);
      transition: all 0.2s;
      cursor: pointer;
    }
    .score-box:hover {
      border-color: var(--accent-cyan);
      box-shadow: 0 2px 8px rgba(2,132,199,0.15);
    }
    .score-box.highlight { 
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue)); 
      border-color: var(--accent-blue);
      box-shadow: 0 2px 8px rgba(59,130,246,0.3);
    }
    .score-box-value { font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; font-weight: 700; }
    .score-box-prob { font-size: 0.6rem; color: var(--text-gray); margin-top: 2px; font-weight: 600; }
    .score-box.highlight .score-box-prob { color: rgba(255,255,255,0.9); }
    
    /* COMBO SUGGERITE */
    .combo-panel {
      background: linear-gradient(135deg, var(--bg-card), var(--bg-card-light));
      border: 2px solid var(--accent-purple);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 20px;
      box-shadow: 0 4px 16px rgba(139,92,246,0.12);
    }
    .combo-title { font-size: 1.1rem; font-weight: 700; color: var(--accent-purple); margin-bottom: 16px; }
    .combo-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 12px; }
    .combo-card {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    .combo-card:hover { 
      border-color: var(--accent-purple); 
      transform: translateY(-2px); 
      box-shadow: 0 4px 12px rgba(139,92,246,0.2);
    }
    .combo-card.selected { 
      border-color: var(--accent-green); 
      background: rgba(16,185,129,0.08); 
      border-width: 2px;
      box-shadow: 0 4px 12px rgba(16,185,129,0.2);
    }
    .combo-value { font-size: 1rem; font-weight: 700; margin-bottom: 8px; }
    .combo-stats { display: flex; justify-content: center; gap: 12px; font-size: 0.75rem; font-weight: 600; }
    .combo-prob { color: var(--accent-cyan); font-weight: 700; }
    .combo-odds { color: var(--accent-emerald); font-weight: 700; }
    
    /* MULTIGOAL GRID */
    .multigoal-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
      gap: 10px;
    }
    .multigoal-box {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 8px;
      text-align: center;
      transition: all 0.2s;
      cursor: pointer;
    }
    .multigoal-box:hover {
      border-color: var(--accent-cyan);
      box-shadow: 0 2px 8px rgba(2,132,199,0.15);
    }
    .multigoal-box.best {
      border-color: var(--accent-green);
      background: rgba(16,185,129,0.08);
      border-width: 2px;
      box-shadow: 0 2px 8px rgba(16,185,129,0.2);
    }
    .multigoal-range {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 4px;
    }
    .multigoal-prob {
      font-size: 0.9rem;
      color: var(--accent-cyan);
      font-weight: 700;
    }
    .multigoal-quota {
      font-size: 0.75rem;
      color: var(--accent-emerald);
      margin-top: 2px;
      font-weight: 600;
    }
    
    /* TEMPO GOL */
    .tempo-highlight {
      background: linear-gradient(135deg, rgba(139,92,246,0.08), rgba(59,130,246,0.08));
      border: 2px solid var(--accent-purple);
      border-radius: 10px;
      padding: 12px;
      margin-top: 12px;
      text-align: center;
      font-size: 0.85rem;
      box-shadow: 0 2px 6px rgba(139,92,246,0.15);
    }
    .tempo-highlight strong {
      color: var(--accent-cyan);
      margin: 0 6px;
      font-weight: 700;
    }
    .tempo-prob {
      color: var(--accent-emerald);
      font-weight: 700;
    }
    
    /* FORM DISPLAY */
    .form-display {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .form-team {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
    }
    .form-team:last-child { border-bottom: none; }
    .form-team-name {
      font-weight: 600;
      font-size: 0.85rem;
    }
    .form-string {
      display: flex;
      gap: 4px;
    }
    .form-w, .form-d, .form-l {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      font-weight: 700;
    }
    .form-w { background: var(--accent-green); color: white; box-shadow: 0 2px 4px rgba(16,185,129,0.2); }
    .form-d { background: var(--accent-yellow); color: white; box-shadow: 0 2px 4px rgba(245,158,11,0.2); }
    .form-l { background: var(--accent-red); color: white; box-shadow: 0 2px 4px rgba(239,68,68,0.2); }
    
    /* CLASSIFICA E MOTIVAZIONE */
    .standings-card {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 8px;
    }
    .standings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .standings-position {
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--accent-cyan);
    }
    .standings-position sup {
      font-size: 0.7rem;
      color: var(--text-dark);
    }
    .motivation-badge {
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.7rem;
      font-weight: 600;
    }
    .motivation-badge.gold { background: rgba(217,119,6,0.15); color: #d97706; border: 1px solid #d97706; font-weight: 700; }
    .motivation-badge.cyan { background: rgba(6,182,212,0.2); color: var(--accent-cyan); border: 1px solid var(--accent-cyan); }
    .motivation-badge.blue { background: rgba(59,130,246,0.2); color: var(--accent-blue); border: 1px solid var(--accent-blue); }
    .motivation-badge.red { background: rgba(239,68,68,0.2); color: var(--accent-red); border: 1px solid var(--accent-red); }
    .motivation-badge.orange { background: rgba(249,115,22,0.2); color: #f97316; border: 1px solid #f97316; }
    .motivation-badge.gray { background: rgba(156,163,175,0.2); color: var(--text-dark); border: 1px solid var(--border); }
    .standings-stats {
      display: flex;
      gap: 12px;
      font-size: 0.75rem;
      color: var(--text-dark);
    }
    .standings-stat {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    /* INFORTUNATI */
    .injuries-card {
      background: rgba(239,68,68,0.05);
      border: 1px solid rgba(239,68,68,0.3);
      border-radius: 12px;
      padding: 12px;
    }
    .injuries-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-weight: 600;
      color: var(--accent-red);
    }
    .injuries-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .injury-chip {
      background: rgba(239,68,68,0.1);
      border: 1px solid rgba(239,68,68,0.3);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.7rem;
      color: var(--text);
    }
    .no-injuries {
      color: var(--accent-green);
      font-size: 0.8rem;
    }
    
    /* PANNELLO IMPOSTAZIONI */
    .settings-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 320px;
      height: 100vh;
      background: var(--bg-card);
      border-left: 1px solid var(--border);
      padding: 20px;
      z-index: 1000;
      overflow-y: auto;
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }
    .settings-panel.open { transform: translateX(0); }
    .settings-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 999;
      display: none;
    }
    .settings-overlay.open { display: block; }
    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid var(--border);
    }
    .settings-title {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--text);
    }
    .settings-close {
      background: none;
      border: none;
      color: var(--text-dark);
      font-size: 1.5rem;
      cursor: pointer;
    }
    .settings-section {
      margin-bottom: 20px;
    }
    .settings-section-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--accent-cyan);
      margin-bottom: 12px;
    }
    .settings-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .settings-label {
      font-size: 0.85rem;
      color: var(--text);
    }
    .settings-input {
      width: 70px;
      padding: 6px 10px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      text-align: center;
    }
    .settings-toggle {
      position: relative;
      width: 44px;
      height: 24px;
      background: var(--bg-input);
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .settings-toggle.active { background: var(--accent-green); }
    .settings-toggle::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }
    .settings-toggle.active::after { transform: translateX(20px); }
    
    /* STORICO WIN RATE */
    .history-chart {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-top: 12px;
    }
    .history-bars {
      display: flex;
      align-items: flex-end;
      gap: 4px;
      height: 80px;
      margin-bottom: 8px;
    }
    .history-bar {
      flex: 1;
      background: var(--accent-cyan);
      border-radius: 4px 4px 0 0;
      min-height: 4px;
      position: relative;
    }
    .history-bar.won { background: var(--accent-green); }
    .history-bar.lost { background: var(--accent-red); }
    .history-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.65rem;
      color: var(--text-dark);
    }
    
    /* WIN RATE PER SEGNO */
    .winrate-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 16px;
    }
    .winrate-item {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
    }
    .winrate-label {
      font-weight: 700;
      font-size: 0.85rem;
      color: var(--text-white);
      margin-bottom: 6px;
    }
    .winrate-stats {
      display: flex;
      gap: 12px;
      font-size: 0.75rem;
      color: var(--text-gray);
      margin-bottom: 8px;
    }
    .winrate-won { color: var(--accent-green); }
    .winrate-lost { color: var(--accent-red); }
    .winrate-bar {
      height: 8px;
      background: var(--bg-dark);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 4px;
    }
    .winrate-bar-fill {
      height: 100%;
      border-radius: 4px;
      transition: width 0.3s;
    }
    .winrate-bar-fill.good { background: linear-gradient(90deg, var(--accent-green), var(--accent-cyan)); }
    .winrate-bar-fill.bad { background: linear-gradient(90deg, var(--accent-red), var(--accent-yellow)); }
    .winrate-percent {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      font-weight: 700;
      color: var(--accent-cyan);
      text-align: right;
    }
    .winrate-summary {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      padding: 12px;
      background: var(--bg-card);
      border-radius: 10px;
      border: 1px solid var(--border);
    }
    .winrate-summary-item {
      text-align: center;
    }
    .winrate-summary-item span {
      display: block;
      font-size: 0.65rem;
      color: var(--text-dark);
      margin-bottom: 2px;
    }
    .winrate-summary-item strong {
      font-size: 1rem;
      font-weight: 700;
    }
    
    /* SETTINGS BUTTON */
    .settings-btn {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      color: var(--text);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.85rem;
      transition: all 0.2s;
    }
    .settings-btn:hover {
      border-color: var(--accent-cyan);
      background: rgba(6,182,212,0.1);
    }
    
    /* BUTTON STYLES */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px 24px;
      font-size: 0.9rem;
      font-weight: 600;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      border: none;
      outline: none;
      position: relative;
      z-index: 10;
      user-select: none;
    }
    .btn-primary {
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      color: white;
      box-shadow: 0 4px 12px rgba(6,182,212,0.3);
    }
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(6,182,212,0.4);
    }
    .btn-primary:active {
      transform: translateY(0);
    }
    .btn-secondary {
      background: var(--bg-card-light);
      color: var(--text-white);
      border: 1px solid var(--border);
    }
    .btn-secondary:hover {
      background: var(--bg-input);
      border-color: var(--accent-cyan);
    }
    .btn-secondary:active {
      transform: scale(0.98);
    }
    
    /* MG PROBABILE BOX */
    .mg-best-box {
      background: linear-gradient(135deg, rgba(139,92,246,0.08), rgba(59,130,246,0.08));
      border: 2px solid var(--accent-purple);
      border-radius: 10px;
      padding: 10px 12px;
      margin-top: 10px;
      text-align: center;
      box-shadow: 0 2px 6px rgba(139,92,246,0.15);
    }
    .mg-best-label {
      font-size: 0.7rem;
      color: var(--text-gray);
      margin-bottom: 4px;
      font-weight: 600;
    }
    .mg-best-value {
      font-size: 1rem;
      font-weight: 800;
      color: var(--accent-cyan);
    }
    .mg-best-prob {
      font-size: 0.75rem;
      color: var(--accent-emerald);
      font-weight: 700;
    }
    
    /* MG SOTTO RISULTATI ESATTI */
    .mg-under-scores {
      display: flex;
      gap: 12px;
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }
    .mg-box-compact {
      flex: 1;
      background: linear-gradient(135deg, rgba(217,119,6,0.08), rgba(16,185,129,0.08));
      border: 2px solid var(--accent-gold);
      border-radius: 10px;
      padding: 10px;
      text-align: center;
      box-shadow: 0 2px 6px rgba(217,119,6,0.12);
    }
    .mg-box-compact .mg-box-label {
      font-size: 0.7rem;
      color: #b45309;
      margin-bottom: 4px;
      font-weight: 600;
    }
    .mg-box-compact .mg-box-value {
      font-size: 1.1rem;
      font-weight: 800;
      color: #d97706;
    }
    .mg-box-compact .mg-box-prob {
      font-size: 0.8rem;
      color: var(--accent-emerald);
      font-family: 'JetBrains Mono', monospace;
      font-weight: 700;
    }
    
    /* LINEE OVER/UNDER CORNER E CARTELLINI */
    .ou-lines {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .ou-line-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 10px;
      background: var(--bg-input);
      border-radius: 6px;
      font-size: 0.75rem;
    }
    .ou-line-label {
      color: var(--text-gray);
      font-weight: 500;
      flex: 1;
    }
    .ou-line-over, .ou-line-under {
      padding: 3px 8px;
      border-radius: 4px;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 600;
      margin-left: 6px;
    }
    .ou-line-over {
      background: rgba(16,185,129,0.12);
      color: var(--accent-emerald);
      font-weight: 700;
    }
    .ou-line-under {
      background: rgba(239,68,68,0.12);
      color: var(--accent-red);
      font-weight: 700;
    }
    .ou-line-over.highlight {
      background: rgba(16,185,129,0.25);
      border: 1px solid var(--accent-green);
      font-weight: 800;
    }
    .ou-line-under.highlight {
      background: rgba(239,68,68,0.25);
      border: 1px solid var(--accent-red);
      font-weight: 800;
    }
    
    /* PRONOSTICI AI */
    .predictions-panel {
      background: linear-gradient(135deg, var(--bg-card), var(--bg-card-light));
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 20px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.06);
    }
    .predictions-header { text-align: center; margin-bottom: 20px; }
    .predictions-title {
      font-size: 1.3rem; font-weight: 800; margin-bottom: 8px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .predictions-subtitle { font-size: 0.8rem; color: var(--text-dark); }
    .predictions-legend { display: flex; justify-content: center; gap: 16px; margin-top: 10px; font-size: 0.7rem; }
    .legend-item { display: flex; align-items: center; gap: 4px; }
    .legend-dot { width: 10px; height: 10px; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.15); }
    .legend-dot.high { background: var(--accent-green); box-shadow: 0 2px 6px rgba(16,185,129,0.4); }
    .legend-dot.mid { background: var(--accent-yellow); box-shadow: 0 2px 6px rgba(245,158,11,0.4); }
    .legend-dot.low { background: var(--accent-red); box-shadow: 0 2px 6px rgba(239,68,68,0.4); }
    .predictions-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 12px; }
    .prediction-card {
      background: var(--bg-input);
      border: 2px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .prediction-card:hover { 
      border-color: var(--accent-cyan); 
      transform: translateY(-2px); 
      box-shadow: 0 4px 12px rgba(2,132,199,0.2);
    }
    .prediction-card.selected { 
      border-color: var(--accent-green); 
      background: rgba(16,185,129,0.08); 
      box-shadow: 0 4px 12px rgba(16,185,129,0.25);
    }
    .prediction-card.selected::after {
      content: 'âœ“';
      position: absolute;
      top: 8px; right: 8px;
      width: 20px; height: 20px;
      background: var(--accent-green);
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 0.7rem; font-weight: 700;
    }
    .prediction-market { font-size: 0.65rem; color: var(--text-dark); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px; }
    .prediction-value { font-size: 1.1rem; font-weight: 800; margin-bottom: 8px; }
    .prediction-prob {
      display: inline-flex; align-items: center; gap: 4px;
      padding: 4px 10px;
      border-radius: 12px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem; font-weight: 600;
    }
    .prediction-prob.high { background: rgba(16,185,129,0.2); color: var(--accent-green); }
    .prediction-prob.mid { background: rgba(251,191,36,0.2); color: var(--accent-yellow); }
    .prediction-prob.low { background: rgba(239,68,68,0.2); color: var(--accent-red); }
    
    /* HOME SECTIONS - Picks del giorno */
    .home-sections { display: flex; flex-direction: column; gap: 20px; margin-bottom: 24px; }
    .picks-section {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      position: relative;
      overflow: hidden;
    }
    .picks-section::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 3px;
    }
    .picks-section.raddoppi::before { background: linear-gradient(90deg, var(--accent-green), var(--accent-cyan)); }
    .picks-section.gg::before { background: linear-gradient(90deg, var(--accent-yellow), var(--accent-green)); }
    .picks-section.over::before { background: linear-gradient(90deg, var(--accent-cyan), var(--accent-blue)); }
    .picks-section.pareggi::before { background: linear-gradient(90deg, var(--accent-purple), var(--accent-blue)); }
    .picks-section.over1t::before { background: linear-gradient(90deg, var(--accent-red), var(--accent-yellow)); }
    
    /* AI CONSIGLIO */
    .ai-advice {
      background: linear-gradient(135deg, rgba(168,85,247,0.15), rgba(34,211,238,0.15));
      border: 2px solid var(--accent-purple);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 20px;
      position: relative;
      overflow: hidden;
    }
    .ai-advice::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--accent-purple), var(--accent-cyan), var(--accent-green));
    }
    .ai-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .ai-icon {
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
    }
    .ai-title-group { flex: 1; }
    .ai-title {
      font-size: 1.1rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .ai-subtitle { font-size: 0.75rem; color: var(--text-dark); }
    .ai-confidence {
      padding: 6px 14px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 700;
    }
    .ai-confidence.high { background: rgba(16,185,129,0.2); color: var(--accent-green); }
    .ai-confidence.medium { background: rgba(251,191,36,0.2); color: var(--accent-yellow); }
    .ai-confidence.low { background: rgba(239,68,68,0.2); color: var(--accent-red); }
    .ai-pick {
      background: var(--bg-input);
      border-radius: 16px;
      padding: 20px;
      text-align: center;
      margin-bottom: 16px;
    }
    .ai-pick-label { font-size: 0.7rem; color: var(--text-dark); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
    .ai-pick-value {
      font-size: 1.8rem;
      font-weight: 800;
      color: var(--accent-cyan);
      margin-bottom: 4px;
    }
    .ai-pick-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1rem;
      color: var(--accent-green);
    }
    .ai-reasoning {
      background: var(--bg-card-light);
      border-radius: 12px;
      padding: 16px;
    }
    .ai-reasoning-title {
      font-size: 0.75rem;
      color: var(--text-dark);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .ai-reasoning-list { display: flex; flex-direction: column; gap: 8px; }
    .ai-reason {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.85rem;
      color: var(--text-gray);
    }
    .ai-reason-icon { font-size: 1rem; }
    .ai-reason.positive { color: var(--accent-green); }
    .ai-reason.negative { color: var(--accent-red); }
    .ai-reason.neutral { color: var(--accent-yellow); }
    .ai-alternatives {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    .ai-alt-title { font-size: 0.7rem; color: var(--text-dark); margin-bottom: 10px; }
    .ai-alt-grid { display: flex; gap: 10px; flex-wrap: wrap; }
    .ai-alt-chip {
      padding: 8px 14px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 20px;
      font-size: 0.8rem;
      color: var(--text-gray);
      cursor: pointer;
      transition: all 0.2s;
    }
    .ai-alt-chip:hover { border-color: var(--accent-cyan); color: var(--text-white); }
    
    /* LIVE BETTING */
    .live-tab { 
      background: linear-gradient(135deg, var(--accent-red), #ff6b6b) !important; 
      animation: livePulse 2s infinite;
    }
    .live-tab.active { box-shadow: 0 0 20px rgba(239,68,68,0.5); }
    @keyframes livePulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }
    .live-badge-count {
      background: white;
      color: var(--accent-red);
      font-size: 0.7rem;
      font-weight: 800;
      padding: 2px 6px;
      border-radius: 10px;
      margin-left: 6px;
    }
    .live-section {
      background: linear-gradient(145deg, rgba(239,68,68,0.08), rgba(251,191,36,0.08));
      border: 1px solid rgba(239,68,68,0.3);
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .live-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    .live-title {
      font-size: 1.1rem;
      font-weight: 800;
      color: var(--accent-red);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .live-dot {
      width: 10px;
      height: 10px;
      background: var(--accent-red);
      border-radius: 50%;
      animation: livePulse 1s infinite;
    }
    .live-refresh-btn {
      padding: 8px 16px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .live-refresh-btn:hover { border-color: var(--accent-cyan); color: var(--text-white); }
    .live-alerts-grid { display: flex; flex-direction: column; gap: 16px; }
    .live-alert-card {
      background: var(--bg-card);
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid var(--border);
      transition: all 0.3s;
    }
    .live-alert-card:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(0,0,0,0.3); }
    .live-alert-card.high { border-color: var(--accent-red); border-width: 2px; }
    .live-alert-card.medium { border-color: var(--accent-yellow); }
    .live-alert-card.low { border-color: var(--accent-cyan); }
    .live-alert-header {
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .live-alert-card.high .live-alert-header { background: rgba(239,68,68,0.15); }
    .live-alert-card.medium .live-alert-header { background: rgba(251,191,36,0.15); }
    .live-alert-card.low .live-alert-header { background: rgba(34,211,238,0.15); }
    .live-alert-level {
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .live-alert-card.high .live-alert-level { color: var(--accent-red); }
    .live-alert-card.medium .live-alert-level { color: var(--accent-yellow); }
    .live-alert-card.low .live-alert-level { color: var(--accent-cyan); }
    .live-alert-time {
      display: flex;
      align-items: center;
      gap: 6px;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 700;
      color: var(--accent-red);
    }
    .live-alert-body { padding: 16px; }
    .live-alert-match {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .live-alert-teams { font-weight: 600; color: var(--text-white); }
    .live-alert-score {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.2rem;
      font-weight: 800;
      color: var(--accent-cyan);
      background: var(--bg-input);
      padding: 6px 12px;
      border-radius: 8px;
    }
    .live-alert-stats {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      margin-bottom: 12px;
      padding: 10px;
      background: var(--bg-input);
      border-radius: 10px;
    }
    .live-stat {
      font-size: 0.8rem;
      color: var(--text-gray);
    }
    .live-stat strong { color: var(--text-white); }
    .live-alert-pick {
      background: linear-gradient(135deg, rgba(16,185,129,0.15), rgba(34,211,238,0.15));
      border: 1px solid var(--accent-green);
      border-radius: 12px;
      padding: 14px;
      text-align: center;
    }
    .live-pick-label { font-size: 0.7rem; color: var(--text-dark); margin-bottom: 6px; }
    .live-pick-value {
      font-size: 1.3rem;
      font-weight: 800;
      color: var(--accent-green);
    }
    .live-pick-details {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-top: 8px;
      font-size: 0.85rem;
    }
    .live-pick-prob { color: var(--accent-cyan); }
    .live-pick-reason {
      font-size: 0.8rem;
      color: var(--text-gray);
      margin-top: 10px;
      font-style: italic;
    }
    .live-empty {
      text-align: center;
      padding: 40px;
      color: var(--text-dark);
    }
    .live-empty-icon { font-size: 3rem; margin-bottom: 12px; }
    .live-filters {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .live-filter-btn {
      padding: 6px 14px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 20px;
      font-size: 0.8rem;
      color: var(--text-gray);
      cursor: pointer;
      transition: all 0.2s;
    }
    .live-filter-btn:hover { border-color: var(--accent-cyan); }
    .live-filter-btn.active { background: var(--accent-cyan); color: var(--bg-dark); border-color: var(--accent-cyan); }
    .live-auto-refresh {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.75rem;
      color: var(--text-dark);
    }
    .live-countdown {
      font-family: 'JetBrains Mono', monospace;
      color: var(--accent-cyan);
    }
    .ai-alt-chip span { color: var(--accent-green); margin-left: 6px; }

    /* DUAL ADVICE LAYOUT */
    .dual-advice-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }
    @media (max-width: 968px) {
      .dual-advice-container { grid-template-columns: 1fr; }
    }

    /* STATISTICAL ADVICE */
    .statistical-advice {
      background: linear-gradient(135deg, rgba(34,211,238,0.15), rgba(16,185,129,0.15));
      border: 2px solid var(--accent-cyan);
      border-radius: 20px;
      padding: 24px;
      position: relative;
      overflow: hidden;
    }
    .statistical-advice::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--accent-cyan), var(--accent-green), var(--accent-yellow));
    }

    /* SMART FILTERS */
    .smart-filters-section {
      background: linear-gradient(145deg, rgba(168,85,247,0.08), rgba(34,211,238,0.08));
      border: 1px solid rgba(168,85,247,0.3);
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 20px;
      position: relative;
    }
    .smart-filters-section::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--accent-purple), var(--accent-cyan), var(--accent-green));
    }
    .filters-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 10px;
    }
    .filters-title {
      font-size: 1.1rem;
      font-weight: 800;
      color: var(--accent-purple);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .filters-count {
      padding: 4px 12px;
      background: var(--bg-input);
      border-radius: 12px;
      font-size: 0.75rem;
      color: var(--text-gray);
    }
    .filter-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }
    .filter-btn {
      padding: 10px 20px;
      background: var(--bg-input);
      border: 2px solid var(--border);
      border-radius: 12px;
      color: var(--text-gray);
      font-size: 0.85rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }
    .filter-btn:hover {
      border-color: var(--accent-cyan);
      color: var(--text-white);
      transform: translateY(-2px);
    }
    .filter-btn.active {
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      border-color: var(--accent-purple);
      color: white;
      box-shadow: 0 4px 15px rgba(168,85,247,0.4);
    }
    .filtered-picks {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 500px;
      overflow-y: auto;
    }
    .filtered-pick-card {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .filtered-pick-card:hover {
      border-color: var(--accent-cyan);
      transform: translateX(4px);
    }
    .filtered-pick-rank {
      width: 28px;
      height: 28px;
      background: var(--bg-input);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      font-weight: 700;
      color: var(--text-gray);
      flex-shrink: 0;
    }
    .filtered-pick-left {
      flex: 1;
      min-width: 0;
    }
    .filtered-pick-match {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-white);
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .filtered-pick-league {
      font-size: 0.7rem;
      color: var(--text-dark);
    }
    .filtered-pick-right {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }
    .filtered-pick-bet {
      padding: 6px 14px;
      background: var(--accent-purple);
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 700;
      color: white;
    }
    .filtered-pick-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;
      font-weight: 800;
      color: var(--accent-green);
      min-width: 55px;
      text-align: right;
    }
    .picks-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; }
    .picks-title { display: flex; align-items: center; gap: 10px; font-size: 1rem; font-weight: 700; }
    .picks-title-icon { font-size: 1.3rem; }
    .picks-count { 
      padding: 4px 12px; 
      background: var(--bg-input); 
      border-radius: 12px; 
      font-size: 0.75rem; 
      color: var(--text-gray); 
    }
    .picks-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px; }
    .pick-card {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 16px;
      background: var(--bg-card-light);
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .pick-card:hover { border-color: var(--accent-cyan); transform: translateX(4px); }
    .pick-card.selected { border-color: var(--accent-green); background: rgba(16,185,129,0.1); }
    .pick-info { flex: 1; min-width: 0; }
    .pick-match { font-size: 0.8rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 4px; }
    .pick-league { font-size: 0.65rem; color: var(--text-dark); }
    .pick-bet { display: flex; flex-direction: column; align-items: flex-end; gap: 4px; }
    .pick-value { font-weight: 700; color: var(--accent-cyan); }
    .pick-prob { 
      font-family: 'JetBrains Mono', monospace; 
      font-size: 0.75rem; 
      padding: 2px 8px; 
      border-radius: 6px;
      background: rgba(16,185,129,0.2); 
      color: var(--accent-green); 
    }
    
    /* RADDOPPI COMBINATI */
    .raddoppi-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 14px; }
    .raddoppio-card {
      background: linear-gradient(145deg, var(--bg-card-light), var(--bg-input));
      border: 2px solid var(--accent-green);
      border-radius: 14px;
      padding: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .raddoppio-card:hover { transform: translateY(-3px); box-shadow: 0 8px 24px rgba(16,185,129,0.2); }
    .raddoppio-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .raddoppio-badge {
      background: var(--accent-green);
      color: var(--bg-dark);
      padding: 4px 10px;
      border-radius: 8px;
      font-size: 0.7rem;
      font-weight: 700;
    }
    .raddoppio-odds {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--accent-cyan);
    }
    .raddoppio-bets { display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; }
    .raddoppio-bet {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: var(--bg-input);
      border-radius: 8px;
    }
    .raddoppio-match { font-size: 0.8rem; color: var(--text-gray); }
    .raddoppio-pick { 
      font-weight: 700; 
      color: var(--accent-cyan);
      padding: 2px 8px;
      background: rgba(34,211,238,0.15);
      border-radius: 4px;
      font-size: 0.8rem;
    }
    .raddoppio-footer { text-align: center; }
    .raddoppio-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      color: var(--accent-green);
      font-weight: 600;
    }
    
    /* MONEY MANAGEMENT */
    .money-section {
      background: linear-gradient(135deg, var(--bg-card), var(--bg-card-light));
      border: 2px solid var(--accent-purple);
      border-radius: 20px;
      padding: 24px;
    }
    .money-header { text-align: center; margin-bottom: 20px; }
    .money-title { 
      font-size: 1.2rem; font-weight: 800; 
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 6px;
    }
    .money-subtitle { font-size: 0.8rem; color: var(--text-dark); }
    .money-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 20px; }
    .money-input-group { display: flex; flex-direction: column; gap: 6px; }
    .money-label { font-size: 0.75rem; color: var(--text-gray); text-transform: uppercase; letter-spacing: 0.5px; }
    .money-input {
      padding: 14px 16px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-white);
      font-size: 1.1rem;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 600;
    }
    .money-input:focus { outline: none; border-color: var(--accent-cyan); }
    .money-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; }
    .money-stat {
      background: var(--bg-input);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
    }
    .money-stat-label { font-size: 0.65rem; color: var(--text-dark); text-transform: uppercase; margin-bottom: 6px; }
    .money-stat-value { font-family: 'JetBrains Mono', monospace; font-size: 1.3rem; font-weight: 700; }
    .money-stat-value.green { color: var(--accent-green); }
    .money-stat-value.cyan { color: var(--accent-cyan); }
    .money-stat-value.yellow { color: var(--accent-yellow); }
    .money-stat-value.purple { color: var(--accent-purple); }
    .money-strategy { 
      margin-top: 16px; 
      padding: 16px; 
      background: var(--bg-card-light); 
      border-radius: 12px; 
      display: flex; 
      flex-wrap: wrap; 
      gap: 12px; 
      justify-content: center;
    }
    .strategy-btn {
      padding: 10px 20px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .strategy-btn:hover { border-color: var(--accent-cyan); color: var(--text-white); }
    .strategy-btn.active { background: var(--accent-purple); border-color: var(--accent-purple); color: white; }
    
    /* SISTEMA OBIETTIVO */
    .money-grid-4 { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); 
      gap: 12px; 
      margin-bottom: 20px; 
    }
    .progress-section { margin-bottom: 20px; }
    .progress-bar-container {
      position: relative;
      height: 32px;
      background: var(--bg-input);
      border-radius: 16px;
      overflow: hidden;
    }
    .progress-bar-fill {
      position: absolute;
      top: 0; left: 0; bottom: 0;
      background: linear-gradient(90deg, var(--accent-green), var(--accent-cyan));
      border-radius: 16px;
      transition: width 0.5s;
    }
    .progress-bar-text {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--text-white);
      text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }
    .stake-section {
      background: linear-gradient(145deg, rgba(34,211,238,0.1), rgba(59,130,246,0.1));
      border: 2px solid var(--accent-cyan);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      text-align: center;
    }
    .stake-section.warning { border-color: var(--accent-yellow); }
    .stake-section.reached { border-color: var(--accent-green); background: rgba(16,185,129,0.15); }
    .stake-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 16px;
      font-size: 0.85rem;
    }
    .stake-label { color: var(--text-gray); font-weight: 600; }
    .stake-remaining { color: var(--accent-cyan); }
    .stake-reached {
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--accent-green);
      padding: 20px;
    }
    .stake-value { margin-bottom: 12px; }
    .stake-amount {
      font-family: 'JetBrains Mono', monospace;
      font-size: 2.5rem;
      font-weight: 800;
      color: var(--accent-cyan);
      text-shadow: 0 0 20px rgba(34,211,238,0.5);
    }
    .stake-info { font-size: 0.85rem; color: var(--text-gray); margin-top: 8px; }
    .stake-warning { 
      font-size: 0.8rem; 
      color: var(--accent-yellow); 
      margin-top: 8px;
      padding: 6px 12px;
      background: rgba(251,191,36,0.1);
      border-radius: 8px;
      display: inline-block;
    }
    .stake-preview {
      font-size: 0.9rem;
      color: var(--text-gray);
      margin-bottom: 16px;
    }
    .stake-preview strong { color: var(--accent-green); }
    .stake-buttons { display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; }
    .stake-btn {
      padding: 12px 28px;
      border: none;
      border-radius: 10px;
      font-size: 0.95rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }
    .stake-btn.win { background: var(--accent-green); color: white; }
    .stake-btn.win:hover { transform: scale(1.05); box-shadow: 0 4px 16px rgba(16,185,129,0.4); }
    .stake-btn.loss { background: var(--accent-red); color: white; }
    .stake-btn.loss:hover { transform: scale(1.05); box-shadow: 0 4px 16px rgba(239,68,68,0.4); }
    .stake-btn.reset { background: var(--bg-card); border: 1px solid var(--border); color: var(--text-gray); }
    .stake-btn.reset:hover { border-color: var(--accent-cyan); color: var(--text-white); }
    
    /* SCHEDINA FLOATING */
    .slip-floating {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      background: rgba(12,18,34,0.98);
      backdrop-filter: blur(20px);
      border-top: 1px solid var(--border);
      padding: 12px 20px;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
    }
    .slip-count {
      display: flex; align-items: center; gap: 8px;
      padding: 8px 16px;
      background: var(--accent-cyan);
      border-radius: 20px;
      font-weight: 700;
      color: var(--bg-dark);
    }
    .slip-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 10px;
      font-size: 0.85rem; font-weight: 700;
      cursor: pointer;
      display: flex; align-items: center; gap: 6px;
    }
    .slip-btn.primary { background: var(--accent-green); color: white; }
    .slip-btn.secondary { background: var(--bg-card); border: 1px solid var(--border); color: var(--text-white); }
    .slip-btn.danger { background: transparent; border: 1px solid var(--accent-red); color: var(--accent-red); }
    
    /* SLIP MODAL */
    .slip-modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .slip-modal-content {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 20px;
      width: 100%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }
    .slip-modal-header {
      padding: 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .slip-modal-title { font-size: 1.2rem; font-weight: 700; }
    .slip-modal-close {
      width: 32px; height: 32px;
      background: var(--bg-input);
      border: none;
      border-radius: 8px;
      color: var(--text-gray);
      cursor: pointer;
      font-size: 1.2rem;
    }
    .slip-modal-body { padding: 20px; }
    .slip-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      background: var(--bg-card-light);
      border-radius: 10px;
      margin-bottom: 10px;
    }
    .slip-item-info { flex: 1; }
    .slip-item-match { font-size: 0.75rem; color: var(--text-dark); margin-bottom: 4px; }
    .slip-item-bet { font-weight: 700; }
    .slip-item-prob { font-size: 0.8rem; color: var(--accent-cyan); }
    .slip-item-remove {
      width: 28px; height: 28px;
      background: transparent;
      border: 1px solid var(--accent-red);
      border-radius: 6px;
      color: var(--accent-red);
      cursor: pointer;
    }
    .slip-total {
      padding: 16px;
      background: var(--bg-input);
      border-radius: 12px;
      text-align: center;
      margin-top: 16px;
    }
    .slip-total-label { font-size: 0.8rem; color: var(--text-dark); margin-bottom: 4px; }
    .slip-total-value { font-size: 1.5rem; font-weight: 800; color: var(--accent-green); }
    
    .loading { display: flex; flex-direction: column; align-items: center; padding: 40px; }
    .spinner { width: 40px; height: 40px; border: 3px solid var(--border); border-top-color: var(--accent-cyan); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 12px; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-text { color: var(--text-gray); font-size: 0.9rem; }
    .empty { text-align: center; padding: 40px; color: var(--text-dark); }
    .empty-icon { font-size: 2.5rem; margin-bottom: 12px; }
    
    @media (max-width: 768px) {
      .main { padding: 16px; }
      .header { padding: 10px 16px; }
      .brand-name { font-size: 1.1rem; }
      .status-bar { font-size: 0.65rem; }
      .hero-match { gap: 16px; }
      .hero-team-logo, .hero-team-logo-fallback { width: 50px; height: 50px; }
      .hero-score-box { width: 40px; height: 40px; font-size: 1.2rem; }
      .analysis-grid { grid-template-columns: 1fr; }
      .predictions-grid { grid-template-columns: repeat(2, 1fr); }
      .stat-grid { grid-template-columns: repeat(3, 1fr); }
      .combo-grid { grid-template-columns: repeat(2, 1fr); }
      .slip-floating { flex-wrap: wrap; gap: 10px; padding: 10px 16px; }
    }
    
    /* TRACKING & STATS */
    .track-btn {
      background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 10px;
      font-weight: 700;
      cursor: pointer;
      margin-top: 12px;
      width: 100%;
      font-size: 0.95rem;
      transition: all 0.3s;
    }
    .track-btn:hover { transform: scale(1.02); box-shadow: 0 4px 15px rgba(16,185,129,0.4); }
    .track-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    .track-btn.tracked { background: var(--text-dark); }
    
    .stats-section {
      background: linear-gradient(145deg, rgba(168,85,247,0.1), rgba(34,211,238,0.1));
      border: 1px solid rgba(168,85,247,0.3);
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .stats-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    .stats-title {
      font-size: 1.1rem;
      font-weight: 800;
      color: var(--accent-purple);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .stats-overview {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }
    .stats-card {
      background: var(--bg-card);
      padding: 16px;
      border-radius: 12px;
      text-align: center;
    }
    .stats-card-value {
      font-size: 1.8rem;
      font-weight: 800;
      color: var(--text-white);
    }
    .stats-card-value.green { color: var(--accent-green); }
    .stats-card-value.red { color: var(--accent-red); }
    .stats-card-value.yellow { color: var(--accent-yellow); }
    .stats-card-label {
      font-size: 0.75rem;
      color: var(--text-gray);
      margin-top: 4px;
    }
    .stats-winrate {
      background: var(--bg-card);
      padding: 20px;
      border-radius: 16px;
      text-align: center;
      margin-bottom: 20px;
    }
    .stats-winrate-value {
      font-size: 3rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .stats-winrate-label {
      font-size: 0.9rem;
      color: var(--text-gray);
    }
    .stats-breakdown {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .stats-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--bg-card);
      padding: 12px 16px;
      border-radius: 10px;
    }
    .stats-row-label {
      font-weight: 600;
      color: var(--text-white);
    }
    .stats-row-value {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .stats-row-wr {
      font-weight: 700;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.85rem;
    }
    .stats-row-wr.good { background: rgba(16,185,129,0.2); color: var(--accent-green); }
    .stats-row-wr.medium { background: rgba(251,191,36,0.2); color: var(--accent-yellow); }
    .stats-row-wr.bad { background: rgba(239,68,68,0.2); color: var(--accent-red); }
    .stats-row-count {
      font-size: 0.8rem;
      color: var(--text-dark);
    }
    .stats-toggle-btn {
      padding: 8px 16px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .stats-toggle-btn:hover { border-color: var(--accent-purple); color: var(--text-white); }
    .stats-toggle-btn.active { background: var(--accent-purple); color: white; border-color: var(--accent-purple); }
    
    .live-track-btn {
      background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      font-weight: 700;
      cursor: pointer;
      font-size: 0.85rem;
      margin-top: 10px;
      transition: all 0.2s;
    }
    .live-track-btn:hover { transform: scale(1.02); }
    .live-track-btn.tracked { background: var(--text-dark); }
    
    /* === CONSIGLI SECTION === */
    .consigli-section {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .consigli-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
    }
    .consigli-title {
      font-size: 1.2rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .consigli-badge {
      padding: 6px 14px;
      background: linear-gradient(135deg, var(--accent-gold), var(--accent-emerald));
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 700;
    }
    .consigli-category {
      background: var(--bg-card-light);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }
    .consigli-category-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border);
    }
    .consigli-category-icon {
      font-size: 1.2rem;
    }
    .consigli-category-title {
      font-weight: 700;
      font-size: 0.95rem;
      color: var(--accent-gold);
      flex: 1;
    }
    .consigli-category-count {
      padding: 4px 10px;
      background: var(--bg-input);
      border-radius: 8px;
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--text-gray);
    }
    .consigli-grid {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .consiglio-card {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .consiglio-card:hover {
      border-color: var(--accent-gold);
      transform: translateX(4px);
    }
    .consiglio-rank {
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, var(--accent-gold), var(--accent-emerald));
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 0.8rem;
      flex-shrink: 0;
    }
    .consiglio-info {
      flex: 1;
      min-width: 0;
    }
    .consiglio-match {
      font-weight: 600;
      font-size: 0.85rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .consiglio-league {
      font-size: 0.7rem;
      color: var(--text-dark);
    }
    .consiglio-bet {
      text-align: right;
      flex-shrink: 0;
    }
    .consiglio-value {
      display: block;
      font-weight: 700;
      font-size: 0.9rem;
      color: var(--accent-gold);
    }
    .consiglio-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      color: var(--accent-emerald);
    }
    .consigli-tab.active {
      background: linear-gradient(135deg, rgba(245,158,11,0.2), rgba(16,185,129,0.2));
      border-color: var(--accent-gold);
      color: var(--accent-gold);
    }
    
    /* === TRADER SECTION === */
    .trader-section {
      background: linear-gradient(135deg, rgba(245,158,11,0.08), rgba(16,185,129,0.08));
      border: 1px solid rgba(245,158,11,0.25);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .trader-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 12px;
    }
    .trader-title {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .trader-icon {
      width: 44px;
      height: 44px;
      background: linear-gradient(135deg, var(--accent-gold), var(--accent-emerald));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      box-shadow: var(--glow-gold);
    }
    .trader-title-text h3 {
      font-size: 1.1rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-gold), var(--accent-emerald));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .trader-title-text p {
      font-size: 0.7rem;
      color: var(--text-dark);
    }
    .trader-stats {
      display: flex;
      gap: 16px;
    }
    .trader-stat {
      text-align: center;
    }
    .trader-stat-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.3rem;
      font-weight: 800;
      color: var(--accent-gold);
    }
    .trader-stat-label {
      font-size: 0.6rem;
      color: var(--text-dark);
      text-transform: uppercase;
    }
    .trader-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    @media (max-width: 768px) {
      .trader-content { grid-template-columns: 1fr; }
    }
    .trader-box {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
    }
    .trader-box-title {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--accent-gold);
    }
    .trader-picks {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .trader-pick {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .trader-pick:hover {
      border-color: var(--accent-gold);
      transform: translateX(4px);
    }
    .trader-pick-info {
      flex: 1;
      min-width: 0;
    }
    .trader-pick-match {
      font-size: 0.8rem;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .trader-pick-league {
      font-size: 0.65rem;
      color: var(--text-dark);
    }
    .trader-pick-bet {
      text-align: right;
    }
    .trader-pick-value {
      font-weight: 700;
      color: var(--accent-gold);
      font-size: 0.9rem;
    }
    .trader-pick-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      color: var(--accent-emerald);
    }
    .trader-combined {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      background: linear-gradient(135deg, var(--accent-gold), var(--accent-emerald));
      border-radius: 10px;
      margin-top: 12px;
    }
    .trader-combined-label {
      font-size: 0.75rem;
      font-weight: 600;
    }
    .trader-combined-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.2rem;
      font-weight: 800;
    }
    .trader-strategy {
      font-size: 0.7rem;
      color: var(--text-gray);
      background: var(--bg-input);
      padding: 10px;
      border-radius: 8px;
      margin-top: 10px;
      line-height: 1.5;
    }
    .trader-strategy strong {
      color: var(--accent-gold);
    }
    
    /* === TRADER VERDICT (Analysis Page) === */
    .trader-verdict {
      background: linear-gradient(135deg, rgba(245,158,11,0.1), rgba(16,185,129,0.1));
      border: 2px solid rgba(245,158,11,0.3);
      border-radius: 16px;
      padding: 20px;
      margin-top: 20px;
      margin-bottom: 20px;
    }
    .verdict-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .verdict-icon {
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--accent-gold), var(--accent-emerald));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      box-shadow: var(--glow-gold);
    }
    .verdict-title {
      flex: 1;
    }
    .verdict-title h3 {
      font-size: 1.1rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-gold), var(--accent-emerald));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .verdict-title p {
      font-size: 0.7rem;
      color: var(--text-dark);
    }
    .verdict-badge {
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: 700;
      font-size: 0.85rem;
    }
    .verdict-badge.play { background: rgba(34,197,94,0.2); color: #22c55e; }
    .verdict-badge.caution { background: rgba(234,179,8,0.2); color: #eab308; }
    .verdict-badge.avoid { background: rgba(239,68,68,0.2); color: #ef4444; }
    .verdict-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    @media (max-width: 768px) {
      .verdict-content { grid-template-columns: 1fr; }
    }
    .verdict-box {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
    }
    .verdict-box-title {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--accent-gold);
    }
    .verdict-main-pick {
      text-align: center;
      padding: 16px;
      background: var(--bg-input);
      border-radius: 10px;
      margin-bottom: 12px;
    }
    .verdict-main-pick-label {
      font-size: 0.65rem;
      color: var(--text-dark);
      text-transform: uppercase;
      margin-bottom: 6px;
    }
    .verdict-main-pick-value {
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--accent-gold);
      margin-bottom: 4px;
    }
    .verdict-main-pick-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;
      color: var(--accent-emerald);
    }
    .verdict-stars {
      color: var(--accent-gold);
      font-size: 0.9rem;
      margin-top: 6px;
    }
    .verdict-suggestion {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      background: var(--bg-input);
      border-radius: 8px;
      margin-bottom: 8px;
    }
    .verdict-suggestion-icon {
      font-size: 1rem;
    }
    .verdict-suggestion-text {
      font-size: 0.8rem;
      color: var(--text-gray);
    }
    .verdict-suggestion-text strong {
      color: var(--text-white);
    }
    .verdict-warning {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 10px 12px;
      background: rgba(239,68,68,0.1);
      border: 1px solid rgba(239,68,68,0.2);
      border-radius: 8px;
      margin-top: 12px;
    }
    .verdict-warning-icon {
      font-size: 1rem;
      color: var(--accent-red);
    }
    .verdict-warning-text {
      font-size: 0.75rem;
      color: var(--text-gray);
      line-height: 1.4;
    }
    .verdict-warning-text strong {
      color: var(--accent-red);
    }
    
    /* Cache indicator */
    .cache-indicator {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      background: rgba(245,158,11,0.1);
      border-radius: 6px;
      font-size: 0.65rem;
      color: var(--accent-gold);
      margin-left: 10px;
    }
    
    /* === STORICO VARIAZIONI PRONOSTICI === */
    .history-section {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(59, 130, 246, 0.08));
      border: 1px solid rgba(139, 92, 246, 0.25);
      border-radius: 16px;
      padding: 20px;
      margin-top: 20px;
      margin-bottom: 20px;
    }
    .history-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .history-icon {
      width: 44px;
      height: 44px;
      background: linear-gradient(135deg, var(--accent-purple), #3b82f6);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.3rem;
    }
    .history-title h3 {
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-white);
    }
    .history-title p {
      font-size: 0.7rem;
      color: var(--text-dark);
    }
    .history-timeline {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .history-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
    }
    .history-item.current {
      border-color: var(--accent-gold);
      background: rgba(245, 158, 11, 0.08);
    }
    .history-item.significant {
      border-color: var(--accent-yellow);
      background: rgba(251, 191, 36, 0.08);
    }
    .history-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      color: var(--text-dark);
      min-width: 50px;
    }
    .history-pick {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .history-pick-value {
      font-weight: 700;
      color: var(--accent-gold);
      font-size: 0.85rem;
    }
    .history-pick-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      padding: 2px 8px;
      background: rgba(16, 185, 129, 0.2);
      color: var(--accent-green);
      border-radius: 4px;
    }
    .history-change {
      font-size: 0.65rem;
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: 600;
      white-space: nowrap;
    }
    .history-change.first { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
    .history-change.minor { background: rgba(100, 116, 139, 0.2); color: var(--text-gray); }
    .history-change.significant { background: rgba(251, 191, 36, 0.2); color: var(--accent-yellow); }
    .history-change.major { background: rgba(239, 68, 68, 0.2); color: var(--accent-red); }
    .history-empty {
      text-align: center;
      padding: 20px;
      color: var(--text-dark);
      font-size: 0.85rem;
    }
    .history-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    .history-stat {
      text-align: center;
    }
    .history-stat-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--accent-purple);
    }
    .history-stat-label {
      font-size: 0.6rem;
      color: var(--text-dark);
      text-transform: uppercase;
    }
    
    /* === PERFORMANCE & GRAFICI === */
    .chart-container {
      position: relative;
      background: var(--bg-card);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      border: 1px solid var(--border);
    }
    .chart-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }
    .chart-title {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--text-white);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .chart-filters {
      display: flex;
      gap: 8px;
    }
    .chart-filter-btn {
      padding: 6px 12px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-gray);
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .chart-filter-btn:hover {
      border-color: var(--accent-cyan);
      color: var(--text-white);
    }
    .chart-filter-btn.active {
      background: var(--accent-cyan);
      color: white;
      border-color: var(--accent-cyan);
    }
    .chart-canvas-wrapper {
      position: relative;
      height: 300px;
    }
    canvas {
      max-height: 100%;
    }
    .performance-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 16px;
      margin-bottom: 20px;
    }
    .performance-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
    }
    .performance-card-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }
    .performance-card-icon {
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
    }
    .performance-card-title {
      flex: 1;
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-white);
    }
    .ml-insights {
      background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(59,130,246,0.1));
      border: 2px solid rgba(139,92,246,0.3);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .ml-insights-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .ml-insights-icon {
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      box-shadow: 0 0 20px rgba(139,92,246,0.4);
    }
    .ml-insights-title {
      font-size: 1.2rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .ml-suggestion-card {
      background: var(--bg-card);
      border: 1px solid rgba(139,92,246,0.3);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
    }
    .ml-suggestion-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    .ml-suggestion-market {
      font-weight: 700;
      color: var(--accent-purple);
      font-size: 0.95rem;
    }
    .ml-suggestion-status {
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.7rem;
      font-weight: 600;
    }
    .ml-suggestion-status.improving {
      background: rgba(16,185,129,0.2);
      color: var(--accent-green);
    }
    .ml-suggestion-status.declining {
      background: rgba(239,68,68,0.2);
      color: var(--accent-red);
    }
    .ml-suggestion-status.stable {
      background: rgba(251,191,36,0.2);
      color: var(--accent-yellow);
    }
    .ml-suggestion-body {
      font-size: 0.85rem;
      color: var(--text-gray);
      line-height: 1.5;
    }
    .ml-suggestion-body strong {
      color: var(--text-white);
    }
    
    /* Box Confronto Prima vs Ora */
    .history-compare {
      background: linear-gradient(135deg, rgba(245,158,11,0.15), rgba(16,185,129,0.15));
      border: 2px solid rgba(245,158,11,0.4);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }
    .history-compare-title {
      font-size: 0.75rem;
      font-weight: 700;
      color: var(--accent-gold);
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .history-compare-grid {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 12px;
      align-items: center;
    }
    .history-compare-box {
      background: var(--bg-card);
      border-radius: 10px;
      padding: 12px;
      text-align: center;
    }
    .history-compare-box.first {
      border: 1px solid var(--text-dark);
    }
    .history-compare-box.current {
      border: 2px solid var(--accent-gold);
    }
    .history-compare-label {
      font-size: 0.65rem;
      color: var(--text-dark);
      margin-bottom: 4px;
    }
    .history-compare-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      color: var(--text-gray);
      margin-bottom: 6px;
    }
    .history-compare-pick {
      font-size: 1rem;
      font-weight: 700;
      color: var(--accent-gold);
      margin-bottom: 4px;
    }
    .history-compare-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      color: var(--accent-emerald);
    }
    .history-compare-arrow {
      font-size: 1.5rem;
      color: var(--text-dark);
    }
    .history-compare-arrow.changed {
      color: var(--accent-red);
    }
    .history-compare-arrow.stable {
      color: var(--accent-green);
    }
    .history-compare-verdict {
      text-align: center;
      margin-top: 12px;
      padding: 10px;
      border-radius: 8px;
      font-size: 0.8rem;
      font-weight: 600;
    }
    .history-compare-verdict.changed {
      background: rgba(239,68,68,0.15);
      color: var(--accent-red);
    }
    .history-compare-verdict.stable {
      background: rgba(34,197,94,0.15);
      color: var(--accent-green);
    }
    .history-compare-diff {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      margin-top: 4px;
    }
    
    /* === AUTH / LOGIN STYLES === */
    .auth-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
      border: none;
      border-radius: 10px;
      color: white;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .auth-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(139,92,246,0.3);
    }
    .auth-btn.logged-in {
      background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
    }
    .user-email {
      font-size: 0.75rem;
      color: var(--text-gray);
      padding: 4px 10px;
      background: var(--bg-card);
      border-radius: 8px;
      max-width: 100px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .login-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.2s ease;
    }
    .login-modal {
      background: var(--bg-card);
      border-radius: 20px;
      width: 90%;
      max-width: 420px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      animation: slideUp 0.3s ease;
    }
    @keyframes slideUp {
      from { transform: translateY(30px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    .login-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 24px;
      border-bottom: 1px solid var(--border);
    }
    .login-header h2 {
      margin: 0;
      font-size: 1.2rem;
      color: var(--text-white);
    }
    .login-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      color: var(--text-gray);
      cursor: pointer;
    }
    .login-body {
      padding: 24px;
    }
    .login-info {
      color: var(--text-gray);
      font-size: 0.9rem;
      margin-bottom: 20px;
      text-align: center;
    }
    .login-error {
      background: rgba(239,68,68,0.15);
      color: var(--accent-red);
      padding: 12px;
      border-radius: 10px;
      margin-bottom: 16px;
      font-size: 0.85rem;
      text-align: center;
    }
    .login-form {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .login-input {
      padding: 14px 16px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--bg-input);
      color: var(--text-white);
      font-size: 0.95rem;
      outline: none;
      transition: border-color 0.2s;
    }
    .login-input:focus {
      border-color: var(--accent-cyan);
    }
    .login-buttons {
      display: flex;
      gap: 10px;
      margin-top: 8px;
    }
    .login-btn {
      flex: 1;
      padding: 14px;
      border: none;
      border-radius: 10px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .login-btn.primary {
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      color: white;
    }
    .login-btn.primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(6,182,212,0.4);
    }
    .login-btn.secondary {
      background: var(--bg-input);
      color: var(--text-gray);
      border: 1px solid var(--border);
    }
    .login-btn.secondary:hover {
      border-color: var(--accent-cyan);
      color: var(--accent-cyan);
    }
    .login-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .login-note {
      margin-top: 20px;
      padding: 16px;
      background: var(--bg-input);
      border-radius: 10px;
      font-size: 0.8rem;
      color: var(--text-gray);
    }
    .login-note p { margin: 0 0 8px 0; }
    .login-note ul {
      margin: 0;
      padding-left: 20px;
    }
    .login-note li {
      margin: 4px 0;
    }
    
    /* === PRONOSTICI AI LIST === */
    .pronostici-ai-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 500px;
      overflow-y: auto;
    }
    .pronostico-ai-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: var(--bg-card-light);
      border: 1px solid var(--border);
      border-radius: 12px;
      transition: all 0.2s ease;
    }
    .pronostico-ai-item:hover {
      border-color: var(--accent-cyan);
      transform: translateX(4px);
      box-shadow: 0 4px 12px rgba(2,132,199,0.1);
    }
    .pronostico-ai-left {
      flex: 1;
      min-width: 0;
    }
    .pronostico-ai-league {
      font-size: 0.7rem;
      color: var(--text-dark);
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .pronostico-ai-match {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .pronostico-ai-time {
      font-size: 0.8rem;
      font-weight: 700;
      color: var(--accent-cyan);
      min-width: 45px;
    }
    .pronostico-ai-teams {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-white);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .pronostico-ai-right {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-shrink: 0;
    }
    .pronostico-ai-pick {
      padding: 6px 14px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 700;
      color: white;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .pronostico-ai-prob {
      font-size: 1rem;
      font-weight: 800;
      color: var(--accent-green);
      min-width: 45px;
      text-align: right;
    }
    
    @media (max-width: 600px) {
      .stats-overview { grid-template-columns: repeat(2, 1fr); }
      .history-stats { grid-template-columns: repeat(2, 1fr); }
      .history-compare-grid { grid-template-columns: 1fr; gap: 8px; }
      .history-compare-arrow { transform: rotate(90deg); }
      .auth-btn span { display: none; }
      .user-email { display: none; }
      .pronostico-ai-match { flex-direction: column; align-items: flex-start; gap: 2px; }
      .pronostico-ai-teams { font-size: 0.75rem; }
      .pronostico-ai-pick { padding: 4px 10px; font-size: 0.7rem; }
      .pronostico-ai-prob { font-size: 0.85rem; min-width: 35px; }
      .main { padding: 10px; }
      .header { padding: 10px 12px; }
      .brand-name { font-size: 1rem; }
      .status-bar { display: none; }
      .date-tabs { gap: 4px; }
      .date-tab { padding: 8px 12px; font-size: 0.75rem; }
      .panel { padding: 12px; border-radius: 12px; }
      .raddoppi-grid { grid-template-columns: 1fr !important; }
      .slip-badge { padding: 6px 10px; font-size: 0.7rem; }
    }

    /* === ANALIZZA BUTTON â€” ORACLE STYLE === */
    .analizza-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 11px 22px;
      background: linear-gradient(135deg, #0a1628, #0d1f3c);
      border: 1px solid rgba(0,212,255,0.4);
      border-radius: 10px;
      color: #00d4ff;
      font-size: 0.85rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.25s;
      box-shadow: 0 0 16px rgba(0,212,255,0.15), inset 0 1px 0 rgba(255,255,255,0.05);
      letter-spacing: 0.5px;
      text-transform: uppercase;
    }
    .analizza-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 28px rgba(0,212,255,0.35), 0 4px 20px rgba(0,0,0,0.5);
      border-color: rgba(0,212,255,0.7);
      background: linear-gradient(135deg, #0d1f3c, #0a2540);
      color: #7df4ff;
    }
    .analizza-btn.loading {
      opacity: 0.6;
      cursor: wait;
      animation: btnPulse 1.2s infinite;
    }
    @keyframes btnPulse { 0%,100%{box-shadow:0 0 16px rgba(0,212,255,0.15)} 50%{box-shadow:0 0 28px rgba(0,212,255,0.4)} }
    .analizza-btn-area {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 10px;
    }

    /* === SUPER ALGORITHM PANEL â€” ORACLE === */
    .super-algo-panel {
      background: linear-gradient(145deg, #04070f, #080d1a, #060c18);
      border: 1px solid rgba(0,212,255,0.2);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 20px;
      box-shadow: 
        0 0 0 1px rgba(245,158,11,0.08),
        0 8px 40px rgba(0,0,0,0.7),
        inset 0 1px 0 rgba(0,212,255,0.07),
        0 0 60px rgba(0,212,255,0.04);
      animation: oracleFadeIn 0.4s ease;
      position: relative;
      overflow: hidden;
    }
    .super-algo-panel::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(0,212,255,0.5), rgba(245,158,11,0.4), transparent);
    }
    @keyframes oracleFadeIn {
      from { opacity: 0; transform: translateY(-8px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .super-algo-header {
      display: flex;
      align-items: center;
      gap: 14px;
      margin-bottom: 22px;
      padding-bottom: 18px;
      border-bottom: 1px solid rgba(0,212,255,0.1);
    }
    .super-algo-icon {
      width: 48px; height: 48px;
      background: linear-gradient(135deg, rgba(0,212,255,0.15), rgba(245,158,11,0.1));
      border: 1px solid rgba(0,212,255,0.3);
      border-radius: 14px;
      display: flex; align-items: center; justify-content: center;
      font-size: 1.5rem;
      flex-shrink: 0;
      box-shadow: 0 0 20px rgba(0,212,255,0.15);
    }
    .super-algo-title-group { flex: 1; }
    .super-algo-title {
      font-size: 1.15rem;
      font-weight: 800;
      background: linear-gradient(135deg, #00d4ff, #f59e0b, #00e5a0);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 4px;
      letter-spacing: 0.3px;
    }
    .super-algo-subtitle { font-size: 0.73rem; color: rgba(148,163,184,0.7); }
    .super-algo-badge {
      padding: 5px 14px;
      background: linear-gradient(135deg, rgba(245,158,11,0.2), rgba(0,212,255,0.1));
      border: 1px solid rgba(245,158,11,0.4);
      border-radius: 20px;
      font-size: 0.68rem;
      font-weight: 800;
      color: #f59e0b;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    /* === PICKS GRID === */
    .super-picks-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 10px;
      margin-bottom: 18px;
    }
    .super-pick-card {
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.07);
      border-radius: 14px;
      padding: 14px 12px;
      text-align: center;
      transition: all 0.2s;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    .super-pick-card::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 2px;
    }
    /* GOLD #1 */
    .super-pick-card.rank-1 { 
      border-color: rgba(245,158,11,0.5); 
      background: rgba(245,158,11,0.05);
      box-shadow: 0 0 20px rgba(245,158,11,0.12), inset 0 0 20px rgba(245,158,11,0.03);
    }
    .super-pick-card.rank-1::before { background: linear-gradient(90deg, #f59e0b, #fcd34d, #f59e0b); }
    /* CYAN #2 */
    .super-pick-card.rank-2 { 
      border-color: rgba(0,212,255,0.35);
      background: rgba(0,212,255,0.04);
      box-shadow: 0 0 15px rgba(0,212,255,0.1);
    }
    .super-pick-card.rank-2::before { background: linear-gradient(90deg, #00d4ff, #67e8f9, #00d4ff); }
    /* GREEN #3 */
    .super-pick-card.rank-3 { 
      border-color: rgba(0,229,160,0.35);
      background: rgba(0,229,160,0.04);
    }
    .super-pick-card.rank-3::before { background: linear-gradient(90deg, #00e5a0, #34d399, #00e5a0); }
    /* Others */
    .super-pick-card.rank-other {
      border-color: rgba(255,255,255,0.07);
    }
    .super-pick-card.rank-other::before { background: linear-gradient(90deg, rgba(148,163,184,0.3), rgba(100,116,139,0.3)); }
    .super-pick-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 24px rgba(0,0,0,0.5);
      border-color: rgba(0,212,255,0.4);
    }
    .super-pick-rank {
      position: absolute;
      top: 8px; left: 10px;
      font-size: 0.62rem;
      font-weight: 800;
      color: rgba(148,163,184,0.5);
      font-family: 'JetBrains Mono', monospace;
    }
    .super-pick-market {
      font-size: 0.65rem;
      color: rgba(148,163,184,0.5);
      margin-bottom: 5px;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      margin-top: 10px;
    }
    .super-pick-value {
      font-size: 0.95rem;
      font-weight: 800;
      color: #e2e8f0;
      margin-bottom: 6px;
      line-height: 1.2;
    }
    .super-pick-prob {
      font-size: 1.55rem;
      font-weight: 900;
      font-family: 'JetBrains Mono', monospace;
      margin-bottom: 4px;
      letter-spacing: -1px;
    }
    .super-pick-prob.prob-high { 
      color: #00e5a0; 
      text-shadow: 0 0 16px rgba(0,229,160,0.4);
    }
    .super-pick-prob.prob-med { 
      color: #fbbf24;
      text-shadow: 0 0 12px rgba(251,191,36,0.3);
    }
    .super-pick-prob.prob-low { color: #64748b; }
    .super-pick-confidence {
      font-size: 0.63rem;
      padding: 2px 8px;
      border-radius: 10px;
      font-weight: 700;
      display: inline-block;
    }
    .super-pick-confidence.high { background: rgba(0,229,160,0.15); color: #00e5a0; }
    .super-pick-confidence.medium { background: rgba(251,191,36,0.15); color: #fbbf24; }
    .super-pick-confidence.low { background: rgba(100,116,139,0.15); color: #64748b; }
    .super-signals-row {
      display: flex;
      gap: 5px;
      justify-content: center;
      margin-top: 7px;
      flex-wrap: wrap;
    }
    .super-signal {
      width: 7px; height: 7px;
      border-radius: 50%;
      display: inline-block;
    }
    .super-signal.on { background: #00e5a0; box-shadow: 0 0 5px rgba(0,229,160,0.7); }
    .super-signal.off { background: rgba(255,255,255,0.08); }
    
    /* === SUMMARY BOX === */
    .super-algo-summary {
      background: rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 14px;
      padding: 14px;
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      align-items: center;
    }
    .super-summary-item { text-align: center; flex: 1; min-width: 70px; }
    .super-summary-num {
      font-size: 1.3rem;
      font-weight: 900;
      color: #00d4ff;
      font-family: 'JetBrains Mono', monospace;
      text-shadow: 0 0 12px rgba(0,212,255,0.4);
    }
    .super-summary-label {
      font-size: 0.63rem;
      color: rgba(148,163,184,0.55);
      margin-top: 3px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    /* === LOADING === */
    .super-loading {
      text-align: center;
      padding: 40px 20px;
      color: rgba(148,163,184,0.7);
    }
    .super-loading-spinner {
      display: inline-block;
      width: 36px; height: 36px;
      border: 2px solid rgba(0,212,255,0.15);
      border-top-color: #00d4ff;
      border-right-color: #f59e0b;
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
      margin-bottom: 14px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    
    /* === AI ORACLE SECTION === */
    .super-ai-section {
      margin-top: 18px;
      padding-top: 18px;
      border-top: 1px solid rgba(0,212,255,0.1);
    }
    .super-ai-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 0.88rem;
      color: #e2e8f0;
    }
    .super-ai-live {
      background: linear-gradient(135deg, rgba(0,212,255,0.2), rgba(245,158,11,0.15));
      border: 1px solid rgba(0,212,255,0.4);
      color: #00d4ff;
      font-size: 0.68rem;
      font-weight: 800;
      padding: 2px 9px;
      border-radius: 20px;
      letter-spacing: 0.8px;
      text-transform: uppercase;
    }
    .super-ai-tag {
      display: inline-block;
      background: rgba(0,212,255,0.07);
      border: 1px solid rgba(0,212,255,0.2);
      border-radius: 20px;
      padding: 3px 10px;
      font-size: 0.72rem;
      color: rgba(148,163,184,0.9);
    }
    /* Oracle verdict boxes */
    .oracle-verdict-box {
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 12px;
      padding: 12px 14px;
      flex: 1;
      min-width: 90px;
      text-align: center;
    }
    .oracle-news-item {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 7px 10px;
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
      margin-bottom: 5px;
      font-size: 0.79rem;
      color: #cbd5e1;
      line-height: 1.5;
    }
    .oracle-verdict-text {
      font-size: 0.86rem;
      color: #cbd5e1;
      line-height: 1.65;
      padding: 12px;
      background: rgba(0,0,0,0.25);
      border-radius: 10px;
      border-left: 2px solid #f59e0b;
      margin: 10px 0;
    }
    
    /* === ADVICE CARD (Consiglio AI per ogni partita) === */
    .advice-grid { display: flex; flex-direction: column; gap: 14px; }
    .advice-card {
      background: var(--bg-card); border: 1px solid var(--border);
      border-radius: 16px; overflow: hidden; transition: all 0.2s;
    }
    .advice-card:hover { box-shadow: var(--shadow-md); }
    .advice-card-head {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 16px; background: var(--bg-card-light);
      border-bottom: 1px solid var(--border); gap: 8px;
    }
    .advice-league { font-size: 0.7rem; color: var(--text-dark); display: flex; align-items: center; gap: 5px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .advice-league img { width: 16px; height: 16px; border-radius: 2px; }
    .advice-time { font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; color: var(--accent-cyan); font-weight: 600; flex-shrink: 0; }
    .advice-body { padding: 14px; }
    .advice-teams {
      display: flex; align-items: center; justify-content: space-between;
      margin-bottom: 10px; gap: 6px;
    }
    .advice-team { display: flex; align-items: center; gap: 6px; font-weight: 600; font-size: 0.85rem; min-width: 0; }
    .advice-team img { width: 22px; height: 22px; flex-shrink: 0; }
    .advice-team-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .advice-vs { font-size: 0.65rem; color: var(--text-dark); font-weight: 700; padding: 2px 8px; background: var(--bg-input); border-radius: 6px; flex-shrink: 0; }
    .advice-xg-bar {
      display: flex; align-items: center; justify-content: center; gap: 14px;
      padding: 5px 10px; background: var(--bg-input); border-radius: 8px;
      font-size: 0.7rem; color: var(--text-gray); margin-bottom: 10px;
    }
    .advice-xg-val { font-weight: 700; color: var(--accent-cyan); }
    .advice-main {
      padding: 12px; border-radius: 10px; margin-bottom: 8px;
      background: linear-gradient(135deg, rgba(16,185,129,0.06), rgba(2,132,199,0.06));
      border: 1px solid rgba(16,185,129,0.15);
    }
    .advice-main-top { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 6px; }
    .advice-main-label { font-size: 0.6rem; color: var(--text-dark); text-transform: uppercase; font-weight: 700; letter-spacing: 0.5px; }
    .advice-main-conf { font-size: 0.6rem; padding: 2px 8px; border-radius: 8px; font-weight: 700; }
    .advice-main-conf.high { background: rgba(16,185,129,0.15); color: var(--accent-green); }
    .advice-main-conf.medium { background: rgba(245,158,11,0.15); color: var(--accent-yellow); }
    .advice-main-conf.low { background: rgba(148,163,184,0.15); color: var(--text-dark); }
    .advice-main-row { display: flex; align-items: center; justify-content: space-between; }
    .advice-main-pick { font-size: 1.15rem; font-weight: 800; color: var(--text-white); }
    .advice-main-prob { font-size: 1.4rem; font-weight: 800; }
    .advice-main-prob.high { color: var(--accent-green); }
    .advice-main-prob.medium { color: var(--accent-yellow); }
    .advice-main-prob.low { color: var(--text-gray); }
    .advice-reasons { margin-bottom: 8px; }
    .advice-reason { font-size: 0.72rem; color: var(--text-gray); padding: 2px 0; display: flex; align-items: center; gap: 6px; }
    .advice-reason.positive { color: var(--accent-green); }
    .advice-reason.negative { color: var(--accent-red); }
    .advice-reason.neutral { color: var(--text-dark); }
    .advice-alts {
      display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 10px;
    }
    .advice-alt-chip {
      padding: 4px 10px; background: var(--bg-input); border: 1px solid var(--border);
      border-radius: 8px; font-size: 0.72rem; font-weight: 600; color: var(--text-gray);
    }
    .advice-alt-chip b { color: var(--accent-cyan); }
    .advice-footer { display: flex; gap: 8px; }
    .btn-giocato {
      flex: 1; padding: 10px; border: none; border-radius: 8px; color: white;
      font-size: 0.8rem; font-weight: 700; cursor: pointer; transition: all 0.2s;
      display: flex; align-items: center; justify-content: center; gap: 6px;
      background: linear-gradient(135deg, var(--accent-green), #059669);
    }
    .btn-giocato:hover { transform: scale(1.02); box-shadow: 0 2px 8px rgba(16,185,129,0.3); }
    .btn-giocato.tracked { background: linear-gradient(135deg, #94a3b8, #64748b); cursor: default; }
    .btn-dettaglio {
      padding: 10px 14px; background: var(--bg-input); border: 1px solid var(--border);
      border-radius: 8px; color: var(--text-gray); font-size: 0.8rem; font-weight: 600;
      cursor: pointer; transition: all 0.2s;
    }
    .btn-dettaglio:hover { border-color: var(--accent-cyan); color: var(--accent-cyan); }

    /* === SCHEDINA VIRTUALE === */
    .schedina-section {
      background: var(--bg-card); border: 2px solid var(--accent-gold);
      border-radius: 16px; padding: 18px; margin-bottom: 20px;
      box-shadow: 0 0 20px rgba(217,119,6,0.1);
    }
    .schedina-head { display: flex; align-items: center; justify-content: space-between; margin-bottom: 14px; flex-wrap: wrap; gap: 8px; }
    .schedina-title { font-size: 1rem; font-weight: 800; color: var(--accent-gold); display: flex; align-items: center; gap: 8px; }
    .schedina-stats { display: flex; gap: 10px; }
    .schedina-stat { text-align: center; padding: 4px 10px; background: var(--bg-input); border-radius: 8px; }
    .schedina-stat-n { font-size: 1rem; font-weight: 800; }
    .schedina-stat-n.g { color: var(--accent-green); }
    .schedina-stat-n.r { color: var(--accent-red); }
    .schedina-stat-n.y { color: var(--accent-yellow); }
    .schedina-stat-l { font-size: 0.6rem; color: var(--text-dark); }
    .schedina-wr {
      display: flex; align-items: center; gap: 12px; padding: 10px;
      background: var(--bg-input); border-radius: 10px; margin-bottom: 12px;
    }
    .schedina-wr-bar { flex: 1; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden; }
    .schedina-wr-fill { height: 100%; border-radius: 4px; transition: width 0.5s; }
    .schedina-list { display: flex; flex-direction: column; gap: 5px; }
    .schedina-item {
      display: flex; align-items: center; justify-content: space-between;
      padding: 9px 12px; border-radius: 8px; background: var(--bg-card-light);
      border: 1px solid var(--border); gap: 6px;
    }
    .schedina-item.won { background: rgba(16,185,129,0.06); border-color: rgba(16,185,129,0.25); }
    .schedina-item.lost { background: rgba(239,68,68,0.06); border-color: rgba(239,68,68,0.25); }
    .schedina-item.pending { border-left: 3px solid var(--accent-yellow); }
    .schedina-item-left { display: flex; flex-direction: column; gap: 1px; min-width: 0; flex: 1; }
    .schedina-item-match { font-size: 0.78rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .schedina-item-info { font-size: 0.65rem; color: var(--text-dark); }
    .schedina-item-right { display: flex; align-items: center; gap: 8px; flex-shrink: 0; }
    .schedina-item-pick { padding: 3px 8px; background: var(--accent-cyan); color: white; border-radius: 6px; font-size: 0.7rem; font-weight: 700; }
    .schedina-item-status { font-size: 1.1rem; }

    @media (max-width: 600px) {
      .advice-teams { gap: 4px; }
      .advice-team { font-size: 0.78rem; }
      .advice-team img { width: 18px; height: 18px; }
      .advice-main-pick { font-size: 1rem; }
      .advice-main-prob { font-size: 1.2rem; }
      .advice-alts { gap: 4px; }
      .advice-alt-chip { padding: 3px 7px; font-size: 0.65rem; }
      .advice-xg-bar { font-size: 0.65rem; gap: 8px; }
      .advice-reason { font-size: 0.65rem; }
      .schedina-stats { gap: 6px; }
      .schedina-stat { padding: 3px 6px; }
      .schedina-item { padding: 7px 10px; }
      .schedina-item-match { font-size: 0.7rem; }
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <script>
    // ===================================================
    // BETTINGPRO v6 - CON ML AVANZATO E FIREBASE AUTH
    // ===================================================
    
    // ============================================
    // CONFIG
    // ============================================
    const CONFIG = {
      API_FOOTBALL: {
        key: 'aeb2864a3d4dbb8395fa53c83a876a93',
        baseURL: 'https://v3.football.api-sports.io'
      },
      FOOTYSTATS: {
        key: 'bec59b6f83404b0bd79c40076be71f6f3abec62afdacf5eeba296f2357993f3e',
        baseURL: 'https://api.footystats.org'
      },
      FIREBASE: {
        url: 'https://bettingpro2-9f1d9-default-rtdb.europe-west1.firebasedatabase.app',
        apiKey: 'AIzaSyDYmw4z8H1F3FoOBkVNjbQrs-GTnpHwSD4',
        authDomain: 'bettingpro2-9f1d9.firebaseapp.com',
        databaseURL: 'https://bettingpro2-9f1d9-default-rtdb.europe-west1.firebasedatabase.app',
        projectId: 'bettingpro2-9f1d9',
        storageBucket: 'bettingpro2-9f1d9.firebasestorage.app',
        messagingSenderId: '858898850393',
        appId: '1:858898850393:web:78b6ba896c29921e85c748'
      }
    };

    // ============================================
    // AUTHENTICATION STATE
    // ============================================
    let authState = {
      isLoggedIn: false,
      user: null,
      email: null,
      showLoginModal: false,
      loginError: null,
      isLoading: false
    };

    // User ID - usa email se loggato, altrimenti ID casuale locale
    const getUserId = () => {
      // Se loggato, usa l'email hashata come ID
      if (authState.isLoggedIn && authState.email) {
        return 'auth_' + btoa(authState.email).replace(/[^a-zA-Z0-9]/g, '').substring(0, 20);
      }
      // Altrimenti usa ID locale (per utenti non registrati)
      let id = localStorage.getItem('bettingpro_uid');
      if (!id) {
        id = 'local_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('bettingpro_uid', id);
      }
      return id;
    };
    
    // USER_ID sarÃ  aggiornato dopo il login
    let USER_ID = getUserId();
    
    // ============================================
    // FIREBASE AUTHENTICATION FUNCTIONS
    // ============================================
    
    // Login con Email/Password usando Firebase REST API
    async function firebaseLogin(email, password) {
      authState.isLoading = true;
      authState.loginError = null;
      render();
      
      try {
        const response = await fetch(
          `https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=${CONFIG.FIREBASE.apiKey}`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              email: email,
              password: password,
              returnSecureToken: true
            })
          }
        );
        
        const data = await response.json();
        
        if (data.error) {
          throw new Error(data.error.message);
        }
        
        // Login riuscito
        authState.isLoggedIn = true;
        authState.user = data;
        authState.email = data.email;
        authState.showLoginModal = false;
        authState.loginError = null;
        
        // Aggiorna USER_ID
        USER_ID = getUserId();
        
        // Salva stato login
        localStorage.setItem('bettingpro_auth', JSON.stringify({
          email: data.email,
          idToken: data.idToken,
          refreshToken: data.refreshToken,
          expiresAt: Date.now() + (parseInt(data.expiresIn) * 1000)
        }));
        
        console.log('âœ… Login riuscito:', data.email);
        
        // Ricarica i dati da Firebase con il nuovo USER_ID
        await loadAllDataFromFirebase();
        
      } catch (error) {
        console.error('âŒ Login fallito:', error);
        authState.loginError = translateFirebaseError(error.message);
      } finally {
        authState.isLoading = false;
        render();
      }
    }
    
    // Registrazione nuovo utente
    async function firebaseRegister(email, password) {
      authState.isLoading = true;
      authState.loginError = null;
      render();
      
      try {
        const response = await fetch(
          `https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=${CONFIG.FIREBASE.apiKey}`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              email: email,
              password: password,
              returnSecureToken: true
            })
          }
        );
        
        const data = await response.json();
        
        if (data.error) {
          throw new Error(data.error.message);
        }
        
        // Registrazione riuscita - effettua login automatico
        authState.isLoggedIn = true;
        authState.user = data;
        authState.email = data.email;
        authState.showLoginModal = false;
        
        USER_ID = getUserId();
        
        localStorage.setItem('bettingpro_auth', JSON.stringify({
          email: data.email,
          idToken: data.idToken,
          refreshToken: data.refreshToken,
          expiresAt: Date.now() + (parseInt(data.expiresIn) * 1000)
        }));
        
        console.log('âœ… Registrazione riuscita:', data.email);
        
        // Migra dati locali al nuovo account cloud
        await migrateLocalDataToCloud();
        
      } catch (error) {
        console.error('âŒ Registrazione fallita:', error);
        authState.loginError = translateFirebaseError(error.message);
      } finally {
        authState.isLoading = false;
        render();
      }
    }
    
    // Logout
    function firebaseLogout() {
      authState.isLoggedIn = false;
      authState.user = null;
      authState.email = null;
      localStorage.removeItem('bettingpro_auth');
      
      // Torna all'ID locale
      USER_ID = getUserId();
      
      console.log('&#x1F44B; Logout effettuato');
      render();
    }
    
    // Ripristina sessione salvata
    async function restoreAuthSession() {
      const savedAuth = localStorage.getItem('bettingpro_auth');
      if (!savedAuth) return false;
      
      try {
        const auth = JSON.parse(savedAuth);
        
        // Verifica se il token Ã¨ scaduto
        if (auth.expiresAt < Date.now()) {
          // Prova a rinnovare il token
          const response = await fetch(
            `https://securetoken.googleapis.com/v1/token?key=${CONFIG.FIREBASE.apiKey}`,
            {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                grant_type: 'refresh_token',
                refresh_token: auth.refreshToken
              })
            }
          );
          
          const data = await response.json();
          
          if (data.error) {
            throw new Error('Token refresh failed');
          }
          
          // Aggiorna token
          auth.idToken = data.id_token;
          auth.refreshToken = data.refresh_token;
          auth.expiresAt = Date.now() + (parseInt(data.expires_in) * 1000);
          
          localStorage.setItem('bettingpro_auth', JSON.stringify(auth));
        }
        
        authState.isLoggedIn = true;
        authState.email = auth.email;
        USER_ID = getUserId();
        
        console.log('&#x1F504; Sessione ripristinata:', auth.email);
        return true;
        
      } catch (error) {
        console.warn('âš ï¸ Ripristino sessione fallito:', error);
        localStorage.removeItem('bettingpro_auth');
        return false;
      }
    }
    
    // Migra dati locali al cloud dopo registrazione
    async function migrateLocalDataToCloud() {
      console.log('&#x1F4E4; Migrazione dati locali al cloud...');
      
      // Salva tutti i dati esistenti con il nuovo USER_ID
      if (state.trackedBets.length > 0) {
        await saveToFirebase('trackedBets', state.trackedBets);
      }
      if (Object.keys(state.mlThresholds).length > 0) {
        await saveToFirebase('mlThresholds', state.mlThresholds);
      }
      if (Object.keys(state.mlStats).length > 0) {
        await saveToFirebase('mlStats', state.mlStats);
      }
      if (state.performanceHistory.length > 0) {
        await saveToFirebase('performanceHistory', state.performanceHistory);
      }
      
      console.log('âœ… Migrazione completata');
    }
    
    // Carica tutti i dati da Firebase
    async function loadAllDataFromFirebase() {
      console.log('&#x1F4E5; Caricamento dati da Firebase...');
      
      try {
        const [tracked, ml, mlStats, perf] = await Promise.all([
          loadFromFirebase('trackedBets'),
          loadFromFirebase('mlThresholds'),
          loadFromFirebase('mlStats'),
          loadFromFirebase('performanceHistory')
        ]);
        
        if (tracked) state.trackedBets = tracked;
        if (ml) state.mlThresholds = ml;
        if (mlStats) state.mlStats = mlStats;
        if (perf) state.performanceHistory = perf;
        
        console.log('âœ… Dati caricati da Firebase');
      } catch (error) {
        console.warn('âš ï¸ Errore caricamento dati:', error);
      }
    }
    
    // Traduci errori Firebase in italiano
    function translateFirebaseError(error) {
      const errors = {
        'EMAIL_NOT_FOUND': 'Email non trovata',
        'INVALID_PASSWORD': 'Password errata',
        'INVALID_EMAIL': 'Email non valida',
        'WEAK_PASSWORD': 'Password troppo debole (minimo 6 caratteri)',
        'EMAIL_EXISTS': 'Email giÃ  registrata',
        'TOO_MANY_ATTEMPTS_TRY_LATER': 'Troppi tentativi. Riprova piÃ¹ tardi',
        'INVALID_LOGIN_CREDENTIALS': 'Credenziali non valide'
      };
      return errors[error] || error;
    }
    
    // Mostra/nascondi modal login
    function toggleLoginModal() {
      authState.showLoginModal = !authState.showLoginModal;
      authState.loginError = null;
      render();
    }

    // ============================================
    // FIREBASE CONFIGURATION (REST API - piÃ¹ affidabile)
    // ============================================
    let firebaseEnabled = true;
    
    // Funzioni Firebase per salvare/caricare dati utente via REST API
    async function saveToFirebase(path, data) {
      try {
        // Sanifica i dati prima di salvare (rimuove NaN, Infinity, funzioni)
        const sanitizedData = JSON.parse(JSON.stringify(data, (key, value) => {
          if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
            return 0;
          }
          if (typeof value === 'function') {
            return undefined;
          }
          return value;
        }));
        
        const response = await fetch(`${CONFIG.FIREBASE.url}/users/${USER_ID}/${path}.json`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(sanitizedData)
        });
        if (response.ok) {
          console.log(`âœ… Salvato su Firebase: ${path}`);
          return true;
        }
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText}`);
      } catch (e) {
        console.warn(`âŒ Errore salvataggio Firebase (${path}):`, e.message);
        return false;
      }
    }
    
    async function loadFromFirebase(path) {
      try {
        const response = await fetch(`${CONFIG.FIREBASE.url}/users/${USER_ID}/${path}.json`);
        if (response.ok) {
          const data = await response.json();
          if (data) {
            console.log(`âœ… Caricato da Firebase: ${path}`);
          }
          return data;
        }
        throw new Error(`HTTP ${response.status}`);
      } catch (e) {
        console.warn(`âŒ Errore caricamento Firebase (${path}):`, e.message);
        return null;
      }
    }
    
    console.log('âœ… Firebase REST API configurato');
    console.log(`&#x1F464; User ID: ${USER_ID}`);

    let state = {
      view: 'leagues', // 'leagues', 'matches', 'analysis', 'performance'
      selectedDate: 0, // 0=oggi, -1=ieri, 1=domani, 2=dopodomani
      leagues: [],
      matches: [],
      selectedLeague: null,
      selectedMatch: null,
      analysis: null,
      loading: false,
      api: { 
        football: localStorage.getItem('api_football_status') || 'offline', 
        footystats: localStorage.getItem('api_footystats_status') || 'offline'
      },
      fsData: new Map(),
      slip: [], // Schedina
      slipModal: false,
      // Picks del giorno
      dailyPicks: { raddoppi: [], gg: [], over25: [], pareggi: [], over1T: [], vittorieCasa: [], vittorieOspite: [], matchAdvices: [] },
      // Money Management - Sistema Obiettivo
      money: {
        bankroll: parseFloat(localStorage.getItem('bp2_bankroll')) || 100,
        target: parseFloat(localStorage.getItem('bp2_target')) || 500,
        totalBets: parseInt(localStorage.getItem('bp2_totalbets')) || 10,
        currentBet: parseInt(localStorage.getItem('bp2_currentbet')) || 1,
        currentOdds: parseFloat(localStorage.getItem('bp2_odds')) || 1.80,
        history: JSON.parse(localStorage.getItem('bp2_history') || '[]')
      },
      // LIVE Betting (deprecato - mantengo variabili per compatibilitÃ )
      consigliMode: false,
      liveMode: false,
      liveMatches: [],
      liveAlerts: [],
      liveLoading: false,
      liveInterval: null,
      liveBackgroundInterval: null,
      countdownInterval: null,
      liveCountdown: 60,
      // Tracking Pronostici
      trackedBets: [],
      // Machine Learning Stats - NUOVO
      mlStats: JSON.parse(localStorage.getItem('bp2_ml_stats') || '{}'),
      // Machine Learning Thresholds - AMPLIATO con piÃ¹ mercati
      mlThresholds: JSON.parse(localStorage.getItem('bp2_ml_thresholds') || JSON.stringify({
        '1': { threshold: 55, accuracy: 0, totalPredictions: 0, correctPredictions: 0, streak: 0, lastResults: [] },
        'X': { threshold: 28, accuracy: 0, totalPredictions: 0, correctPredictions: 0, streak: 0, lastResults: [] },
        '2': { threshold: 55, accuracy: 0, totalPredictions: 0, correctPredictions: 0, streak: 0, lastResults: [] },
        'GG': { threshold: 55, accuracy: 0, totalPredictions: 0, correctPredictions: 0, streak: 0, lastResults: [] },
        'NG': { threshold: 50, accuracy: 0, totalPredictions: 0, correctPredictions: 0, streak: 0, lastResults: [] },
        'Over 2.5': { threshold: 55, accuracy: 0, totalPredictions: 0, correctPredictions: 0, streak: 0, lastResults: [] },
        'Under 2.5': { threshold: 55, accuracy: 0, totalPredictions: 0, correctPredictions: 0, streak: 0, lastResults: [] },
        'Over 1.5': { threshold: 65, accuracy: 0, totalPredictions: 0, correctPredictions: 0, streak: 0, lastResults: [] },
        'Over 3.5': { threshold: 60, accuracy: 0, totalPredictions: 0, correctPredictions: 0, streak: 0, lastResults: [] },
        '1X': { threshold: 70, accuracy: 0, totalPredictions: 0, correctPredictions: 0, streak: 0, lastResults: [] },
        'X2': { threshold: 70, accuracy: 0, totalPredictions: 0, correctPredictions: 0, streak: 0, lastResults: [] }
      })),
      // Performance Charts Data
      performanceHistory: JSON.parse(localStorage.getItem('bp2_performance_history') || '[]'),
      // NUOVO: Cache Classifica e Infortunati
      standingsCache: new Map(),
      injuriesCache: new Map(),
      // NUOVO: Impostazioni soglie configurabili (queste sono le soglie MANUALI, separate dal ML)
      settings: JSON.parse(localStorage.getItem('bp2_settings') || JSON.stringify({
        thresholds: {
          '1': 50,
          'X': 28,
          '2': 50,
          'GG': 55,
          'Over 2.5': 50,
          'Over 1.5': 65
        },
        showInjuries: true,
        showStandings: true,
        autoRefresh: true,
        useMLThresholds: true // NUOVO: usa soglie ML invece di manuali
      })),
      settingsOpen: false,

  smartFilters: {
    active: '1',
    results: []
  },
      statsView: false,
      // TRADER Section
      traderPicks: {
        raddoppio: [],
        singole: []
      },
      superAnalysis: null,    // Super Algoritmo result (locale)
      superAIAnalysis: null,  // Analisi AI Claude con news
      superAnalysisRunning: false,
      superAIRunning: false,
      // STORICO VARIAZIONI PRONOSTICI
      predictionHistory: JSON.parse(localStorage.getItem('bp2_prediction_history') || '{}')
    };

    // === FUNZIONI STORICO VARIAZIONI ===
    
    function savePredictionToHistory(matchId, matchName, prediction) {
      const key = String(matchId);
      const now = new Date();
      const timestamp = now.toLocaleTimeString('it-IT', {hour:'2-digit', minute:'2-digit'});
      const fullTimestamp = now.getTime();
      
      if (!state.predictionHistory[key]) {
        state.predictionHistory[key] = {
          matchName: matchName,
          date: getDateString(state.selectedDate),
          predictions: []
        };
      }
      
      const history = state.predictionHistory[key].predictions;
      const lastPred = history.length > 0 ? history[history.length - 1] : null;
      
      let changeType = 'first';
      if (lastPred) {
        const pickChanged = lastPred.pick !== prediction.pick;
        const probDiff = Math.abs(prediction.prob - lastPred.prob);
        
        if (pickChanged) {
          changeType = 'major';
        } else if (probDiff >= 10) {
          changeType = 'significant';
        } else if (probDiff >= 3) {
          changeType = 'minor';
        } else {
          return; // Nessun cambiamento rilevante (< 3%)
        }
      }
      
      history.push({
        time: timestamp,
        fullTime: fullTimestamp,
        pick: prediction.pick,
        prob: prediction.prob,
        changeType: changeType
      });
      
      if (history.length > 10) {
        state.predictionHistory[key].predictions = history.slice(-10);
      }
      
      savePredictionHistory();
      console.log('&#x1F4DC; Storico:', matchName, changeType, prediction.pick, prediction.prob + '%');
    }
    
    function savePredictionHistory() {
      try {
        const twoDaysAgo = new Date();
        twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);
        const cutoffDate = twoDaysAgo.toISOString().split('T')[0];
        
        Object.keys(state.predictionHistory).forEach(key => {
          if (state.predictionHistory[key].date < cutoffDate) {
            delete state.predictionHistory[key];
          }
        });
        
        localStorage.setItem('bp2_prediction_history', JSON.stringify(state.predictionHistory));
      } catch(e) { console.warn('Errore salvataggio storico:', e); }
    }
    
    function getPredictionHistory(matchId) {
      return state.predictionHistory[String(matchId)]?.predictions || [];
    }
    
    function getHistoryStats(matchId) {
      const history = getPredictionHistory(matchId);
      if (history.length === 0) return null;
      
      return {
        totalChanges: history.length - 1,
        majorChanges: history.filter(h => h.changeType === 'major').length,
        significantChanges: history.filter(h => h.changeType === 'significant').length,
        pickChanged: history.length > 1 ? history[0].pick !== history[history.length - 1].pick : false
      };
    }
    
    function renderHistorySection(matchId) {
      const history = getPredictionHistory(matchId);
      const stats = getHistoryStats(matchId);
      
      // Caso: Prima analisi
      if (!history || history.length === 0) {
        return '<div class="history-section">' +
          '<div class="history-header">' +
            '<div class="history-icon">&#x1F4DC;</div>' +
            '<div class="history-title">' +
              '<h3>Storico Variazioni</h3>' +
              '<p>Traccia le variazioni dei pronostici nel tempo</p>' +
            '</div>' +
          '</div>' +
          '<div class="history-empty">' +
            '&#x1F4CA; <strong>Prima analisi registrata!</strong><br>' +
            '<span style="font-size:0.75rem;color:var(--text-dark);">Riapri questa partita tra qualche ora per vedere eventuali variazioni del pronostico.</span>' +
          '</div>' +
        '</div>';
      }
      
      // Box CONFRONTO PRIMA vs ORA (solo se ci sono almeno 2 registrazioni o 1 con cambio)
      let compareHtml = '';
      const first = history[0];
      const last = history[history.length - 1];
      
      if (history.length >= 1) {
        const pickChanged = first.pick !== last.pick;
        const probDiff = last.prob - first.prob;
        const probDiffAbs = Math.abs(probDiff);
        const hasChanges = history.length > 1;
        
        let arrowClass = 'stable';
        let verdictClass = 'stable';
        let verdictText = 'âœ… Pronostico stabile - Nessuna variazione rilevata';
        
        if (pickChanged) {
          arrowClass = 'changed';
          verdictClass = 'changed';
          verdictText = 'âš ï¸ ATTENZIONE: Il pronostico Ã¨ cambiato!';
        } else if (hasChanges && probDiffAbs >= 10) {
          arrowClass = 'changed';
          verdictClass = 'changed';
          verdictText = 'âš ï¸ Variazione significativa della probabilitÃ ';
        } else if (hasChanges) {
          verdictText = 'âœ… Pronostico confermato con piccole variazioni';
        }
        
        let diffText = '';
        if (hasChanges) {
          if (probDiff > 0) {
            diffText = '<span style="color:var(--accent-green);">+' + probDiff.toFixed(0) + '%</span>';
          } else if (probDiff < 0) {
            diffText = '<span style="color:var(--accent-red);">' + probDiff.toFixed(0) + '%</span>';
          } else {
            diffText = '<span style="color:var(--text-gray);">Â±0%</span>';
          }
        }
        
        compareHtml = '<div class="history-compare">' +
          '<div class="history-compare-title">&#x1F4CA; CONFRONTO PRONOSTICI</div>' +
          '<div class="history-compare-grid">' +
            '<div class="history-compare-box first">' +
              '<div class="history-compare-label">PRIMA ANALISI</div>' +
              '<div class="history-compare-time">&#x1F550; ' + first.time + '</div>' +
              '<div class="history-compare-pick">' + first.pick + '</div>' +
              '<div class="history-compare-prob">' + first.prob.toFixed(0) + '%</div>' +
            '</div>' +
            '<div class="history-compare-arrow ' + arrowClass + '">' + (hasChanges ? 'â†’' : 'â€¢') + '</div>' +
            '<div class="history-compare-box current">' +
              '<div class="history-compare-label">ORA</div>' +
              '<div class="history-compare-time">&#x1F550; ' + last.time + '</div>' +
              '<div class="history-compare-pick">' + last.pick + '</div>' +
              '<div class="history-compare-prob">' + last.prob.toFixed(0) + '%</div>' +
            '</div>' +
          '</div>' +
          '<div class="history-compare-verdict ' + verdictClass + '">' +
            verdictText +
            (hasChanges ? '<div class="history-compare-diff">Differenza: ' + diffText + '</div>' : '') +
          '</div>' +
        '</div>';
      }
      
      // Timeline dettagliata (solo se piÃ¹ di 1 registrazione)
      let historyHtml = '';
      if (history.length > 1) {
        historyHtml = '<div style="font-size:0.75rem;color:var(--text-dark);margin-bottom:10px;font-weight:600;">&#x1F4DC; CRONOLOGIA COMPLETA</div>';
        history.forEach(function(item, index) {
          const isLast = index === history.length - 1;
          const isFirst = index === 0;
          const itemClass = isLast ? 'current' : (item.changeType === 'major' || item.changeType === 'significant' ? 'significant' : '');
          
          let changeLabel = '', changeClass = '';
          if (item.changeType === 'first') { changeLabel = '1Â° ANALISI'; changeClass = 'first'; }
          else if (item.changeType === 'minor') { changeLabel = 'â†• Â±3-9%'; changeClass = 'minor'; }
          else if (item.changeType === 'significant') { changeLabel = 'âš ï¸ Â±10%+'; changeClass = 'significant'; }
          else if (item.changeType === 'major') { changeLabel = '&#x1F504; CAMBIO!'; changeClass = 'major'; }
          
          historyHtml += '<div class="history-item ' + itemClass + '">' +
            '<span class="history-time">&#x1F550; ' + item.time + '</span>' +
            '<div class="history-pick">' +
              '<span class="history-pick-value">' + item.pick + '</span>' +
              '<span class="history-pick-prob">' + item.prob.toFixed(0) + '%</span>' +
            '</div>' +
            '<span class="history-change ' + changeClass + '">' + changeLabel + '</span>' +
          '</div>';
        });
      }
      
      // Statistiche
      let statsHtml = '';
      if (stats && stats.totalChanges > 0) {
        statsHtml = '<div class="history-stats">' +
          '<div class="history-stat"><div class="history-stat-value">' + stats.totalChanges + '</div><div class="history-stat-label">Variazioni</div></div>' +
          '<div class="history-stat"><div class="history-stat-value">' + stats.majorChanges + '</div><div class="history-stat-label">Cambi Pick</div></div>' +
          '<div class="history-stat"><div class="history-stat-value">' + (stats.pickChanged ? 'âš ï¸' : 'âœ…') + '</div><div class="history-stat-label">' + (stats.pickChanged ? 'Cambiato' : 'Stabile') + '</div></div>' +
        '</div>';
      }
      
      return '<div class="history-section">' +
        '<div class="history-header">' +
          '<div class="history-icon">&#x1F4DC;</div>' +
          '<div class="history-title"><h3>Storico Variazioni</h3><p>Monitora i cambiamenti del pronostico</p></div>' +
        '</div>' +
        compareHtml +
        (history.length > 1 ? '<div class="history-timeline">' + historyHtml + '</div>' : '') +
        statsHtml +
      '</div>';
    }

    // === UTILITIES ===
    const esc = t => String(t || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]));
    const clamp = (min, v, max) => Math.max(min, Math.min(max, v));
    const formatTime = d => d ? new Date(d).toLocaleTimeString('it-IT', {hour:'2-digit', minute:'2-digit'}) : '--:--';
    const formatDate = d => d ? new Date(d).toLocaleDateString('it-IT', {day:'2-digit', month:'2-digit'}) : '--/--';
    const formatDateFull = d => d ? new Date(d).toLocaleDateString('it-IT', {weekday:'short', day:'2-digit', month:'short'}) : '';
    const getInitials = n => n ? n.split(' ').map(w => w[0]).join('').slice(0,3).toUpperCase() : '??';
    
    function getDateString(offset = 0) {
      const d = new Date();
      d.setDate(d.getDate() + offset);
      return d.toISOString().split('T')[0];
    }
    
    function getDateLabel(offset) {
      if (offset === -1) return 'Ieri';
      if (offset === 0) return 'Oggi';
      if (offset === 1) return 'Domani';
      if (offset === 2) return 'Dopodomani';
      return '';
    }

    // Poisson (con validazione anti-NaN)
    const factorial = n => { 
      if (n > 170) return Infinity; // Evita overflow
      let r = 1; 
      for (let i = 2; i <= n; i++) r *= i; 
      return r; 
    };
    const poisson = (l, k) => {
      // Validazione input
      if (isNaN(l) || isNaN(k) || l < 0 || k < 0) return 0;
      if (l <= 0) return (k === 0 ? 1 : 0);
      
      const result = (Math.pow(l, k) * Math.exp(-l)) / factorial(k);
      
      // Validazione output
      if (isNaN(result) || !isFinite(result)) return 0;
      return result;
    };

    // === SMART FILTERS - Filtri intelligenti con prob combinata AI + Statistica ===
    function calculateSmartFilters(filterType) {
      if (state.matches.length === 0) return [];
      const results = [];

      state.matches.forEach(match => {
        if (['1H','2H','HT','ET','P','LIVE','FT','AET','PEN'].includes(match.status)) return;

        // xG variabili basati su campionato (stima)
        let homeXG = 1.50, awayXG = 1.15;
        
        // Boost per campionati offensivi noti
        const offensiveLeagues = [39, 140, 135, 78, 61, 88, 94]; // PL, LaLiga, SerieA, Bundesliga, L1, Eredivisie, Primeira
        if (offensiveLeagues.includes(match.league.id)) {
          homeXG = 1.60;
          awayXG = 1.25;
        }
        
        // FootyStats data
        const fsKeys = [
          `${match.home.name.toLowerCase()}${match.away.name.toLowerCase()}`,
          `${match.home.name.toLowerCase().replace(/\s/g, '')}${match.away.name.toLowerCase().replace(/\s/g, '')}`
        ];
        let fsMatch = null;
        for (const k of fsKeys) {
          if (state.fsData.has(k)) {
            fsMatch = state.fsData.get(k);
            break;
          }
        }

        if (fsMatch) {
          if (fsMatch.homexg) homeXG = fsMatch.homexg;
          else if (fsMatch.homeppg) homeXG = fsMatch.homeppg * 0.85;
          else if (fsMatch.avggoalshome) homeXG = fsMatch.avggoalshome;

          if (fsMatch.awayxg) awayXG = fsMatch.awayxg;
          else if (fsMatch.awayppg) awayXG = fsMatch.awayppg * 0.75;
          else if (fsMatch.avggoalsaway) awayXG = fsMatch.avggoalsaway;
        }

        // Home advantage (realistico: studi mostrano ~+6% casa, ~-5% trasferta)
        homeXG *= 1.06;
        awayXG *= 0.95;
        
        // Validazione anti-NaN
        if (isNaN(homeXG) || homeXG < 0) homeXG = 1.2;
        if (isNaN(awayXG) || awayXG < 0) awayXG = 1.0;
        
        homeXG = clamp(0.4, homeXG, 3.5);
        awayXG = clamp(0.25, awayXG, 3.0);

        const p1X2 = quickCalc1X2(homeXG, awayXG);
        const pGG = quickCalcBTTS(homeXG, awayXG);
        const pNG = 100 - pGG; // No Goal = 100% - GG
        const pOver15 = quickCalcOver(homeXG, awayXG, 1.5);
        const pOver25 = quickCalcOver(homeXG, awayXG, 2.5);
        const pUnder25 = 100 - pOver25; // Under = 100% - Over

        let prob = 0, pick = '';

        if (filterType === '1') {
          prob = p1X2.home;
          pick = '1';
        } else if (filterType === 'X') {
          prob = p1X2.draw;
          pick = 'X';
        } else if (filterType === '2') {
          prob = p1X2.away;
          pick = '2';
        } else if (filterType === 'GG') {
          prob = pGG;
          pick = 'GG';
        } else if (filterType === 'NG') {
          prob = pNG;
          pick = 'NG';
        } else if (filterType === 'Over 2.5') {
          prob = pOver25;
          pick = 'O 2.5';
        } else if (filterType === 'Under 2.5') {
          prob = pUnder25;
          pick = 'U 2.5';
        } else if (filterType === 'Over 1.5') {
          prob = pOver15;
          pick = 'O 1.5';
        }

        // Aggiungi TUTTE le partite (nessuna soglia)
        results.push({
          match,
          pick,
          prob: prob.toFixed(1),
          time: formatTime(match.date),
          league: `${match.league.country} - ${match.league.name}`
        });
      });

      // Ordina per probabilitÃ  decrescente e prendi le prime 40
      return results.sort((a, b) => parseFloat(b.prob) - parseFloat(a.prob)).slice(0, 40);
    }

    function setSmartFilter(type) {
      state.smartFilters.active = type;
      state.smartFilters.results = calculateSmartFilters(type);
      render();
    }
    
    // Seleziona una partita dal filtro e avvia l'analisi
    function selectMatch(matchId) {
      const match = state.matches.find(m => m.id === matchId);
      if (match) {
        state.superAnalysis = null;
        state.superAIAnalysis = null;
        state.superAnalysisRunning = false;
        state.superAIRunning = false;
      } else {
        console.warn('Partita non trovata:', matchId);
      }
    }

    // === DAILY PICKS - Analisi rapida di tutte le partite ===
    
    // Campionati TOP con dati affidabili (IDs API-Football)
    const TOP_LEAGUES = [
      // Italia
      135, 136, // Serie A, Serie B
      // Inghilterra
      39, 40, 41, // Premier, Championship, League One
      // Spagna
      140, 141, // La Liga, Segunda
      // Germania
      78, 79, // Bundesliga, 2. Bundesliga
      // Francia
      61, 62, // Ligue 1, Ligue 2
      // Altri top
      88,  // Eredivisie (Olanda)
      94,  // Primeira Liga (Portogallo)
      144, // Jupiler Pro (Belgio)
      203, // Super Lig (Turchia)
      // Coppe europee
      2, 3, 848, // Champions, Europa League, Conference
    ];
    
    // ============================================
    // ML THRESHOLD HELPER - Ottiene la soglia adattiva
    // ============================================
    function getMLThreshold(market) {
      // Se useMLThresholds Ã¨ attivo E abbiamo dati ML per questo mercato
      if (state.settings.useMLThresholds && state.mlThresholds[market]) {
        const ml = state.mlThresholds[market];
        
        // Se abbiamo almeno 10 predizioni, usa la soglia calibrata
        if (ml.totalPredictions >= 10) {
          return ml.threshold;
        }
      }
      
      // Altrimenti usa le soglie di default
      const defaults = {
        '1': 55, '2': 55, 'X': 28,
        'GG': 55, 'NG': 50,
        'Over 2.5': 55, 'Under 2.5': 55,
        'Over 1.5': 65, 'Over 3.5': 60,
        '1X': 70, 'X2': 70
      };
      return defaults[market] || 50;
    }
    
    // Ottiene la confidence basata su storico ML
    function getMLConfidence(market, prob) {
      const ml = state.mlThresholds[market];
      if (!ml || ml.totalPredictions < 10) return 'medium';
      
      const accuracy = parseFloat(ml.accuracy);
      const streak = ml.streak || 0;
      
      // Alta confidence se:
      // - ProbabilitÃ  molto sopra la soglia
      // - Buona accuracy storica
      // - Streak positivo recente
      if (prob >= ml.threshold + 15 && accuracy >= 60 && streak >= 2) {
        return 'high';
      } else if (prob >= ml.threshold + 5 && accuracy >= 50) {
        return 'medium';
      } else if (accuracy < 45 || streak <= -3) {
        return 'low';
      }
      return 'medium';
    }
    
    function calculateDailyPicks() {
      if (!state.matches || state.matches.length === 0) {
        console.log('âš ï¸ calculateDailyPicks: Nessuna partita disponibile');
        return;
      }
      
      console.log(`&#x1F504; calculateDailyPicks: Analisi di ${state.matches.length} partite...`);
      console.log(`&#x1F916; ML Attivo: ${state.settings.useMLThresholds ? 'SÃŒ' : 'NO'}`);
      
      const picks = { raddoppi: [], gg: [], over25: [], pareggi: [], over1T: [], vittorieCasa: [], vittorieOspite: [], matchAdvices: [] };
      const safeBets = []; // Per costruire i raddoppi
      
      // Raccogli i consigli AI per tutte le partite
      const allAdvices = [];
      let processedCount = 0;
      let skippedCount = 0;
      let errorCount = 0;
      
      state.matches.forEach(match => {
        try {
          // Skip partite giÃ  iniziate o finite o senza dati validi
          if (!match || !match.home || !match.away) {
            skippedCount++;
            return;
          }
          if (['1H','2H','HT','ET','P','LIVE','FT','AET','PEN'].includes(match.status)) {
            skippedCount++;
            return;
          }
          
          processedCount++;
        
        // Calcolo rapido basato su FootyStats se disponibile
        let fsMatch = null;
        const fsKeys = [
          `${match.home.name.toLowerCase()}_${match.away.name.toLowerCase()}`,
          match.home.name.toLowerCase().replace(/\s+/g, '') + '_' + match.away.name.toLowerCase().replace(/\s+/g, '')
        ];
        for (const k of fsKeys) {
          if (state.fsData.has(k)) { fsMatch = state.fsData.get(k); break; }
        }
        
        // Stima xG base
        let homeXG = 1.55, awayXG = 1.25;
        let homeFormMultiplier = 1.0, awayFormMultiplier = 1.0;
        let dataQuality = 'low'; // low, medium, high
        
        if (fsMatch) {
          if (fsMatch.home_xg) {
            homeXG = fsMatch.home_xg;
            dataQuality = 'high';
          } else if (fsMatch.home_ppg) {
            homeXG = fsMatch.home_ppg * 0.8;
            dataQuality = 'medium';
          } else if (fsMatch.avg_goals_home) {
            homeXG = fsMatch.avg_goals_home;
            dataQuality = 'medium';
          }
          
          if (fsMatch.away_xg) {
            awayXG = fsMatch.away_xg;
          } else if (fsMatch.away_ppg) {
            awayXG = fsMatch.away_ppg * 0.7;
          } else if (fsMatch.avg_goals_away) {
            awayXG = fsMatch.avg_goals_away;
          }
          
          // PATTERN CASA/TRASFERTA AVANZATO
          // Analizza performance specifica casa vs trasferta
          if (fsMatch.home_ppg && fsMatch.away_ppg) {
            // Se casa ha ppg alto in casa â†’ boost
            if (fsMatch.home_ppg >= 2.0) homeFormMultiplier = 1.12;
            else if (fsMatch.home_ppg >= 1.5) homeFormMultiplier = 1.06;
            else if (fsMatch.home_ppg <= 0.8) homeFormMultiplier = 0.90;
            
            // Se ospite ha ppg alto in trasferta â†’ boost
            if (fsMatch.away_ppg >= 1.8) awayFormMultiplier = 1.10;
            else if (fsMatch.away_ppg >= 1.2) awayFormMultiplier = 1.04;
            else if (fsMatch.away_ppg <= 0.6) awayFormMultiplier = 0.88;
          }
        }
        
        // Applica moltiplicatori forma
        homeXG *= homeFormMultiplier;
        awayXG *= awayFormMultiplier;
        
        // Home advantage (realistico: studi mostrano ~+6% casa, ~-5% trasferta)
        homeXG *= 1.06;
        awayXG *= 0.95;
        
        // Validazione anti-NaN
        if (isNaN(homeXG) || homeXG < 0) homeXG = 1.2;
        if (isNaN(awayXG) || awayXG < 0) awayXG = 1.0;
        
        homeXG = clamp(0.3, homeXG, 3.5);
        awayXG = clamp(0.2, awayXG, 3.0);
        
        const totXG = homeXG + awayXG;
        
        // Calcola probabilitÃ 
        const p1X2 = quickCalc1X2(homeXG, awayXG);
        const pOver15 = quickCalcOver(homeXG, awayXG, 1.5);
        const pOver25 = quickCalcOver(homeXG, awayXG, 2.5);
        const pOver35 = quickCalcOver(homeXG, awayXG, 3.5);
        const pUnder25 = 100 - pOver25;
        const pBTTS = quickCalcBTTS(homeXG, awayXG);
        
        const matchInfo = {
          match,
          matchName: `${match.home.name} vs ${match.away.name}`,
          shortName: `${match.home.name.substring(0,12)} - ${match.away.name.substring(0,12)}`,
          league: `${match.league.country} - ${match.league.name}`,
          time: formatTime(match.date),
          xgTotal: totXG.toFixed(2),
          totXG: totXG.toFixed(2),
          homeXG: homeXG.toFixed(2),
          awayXG: awayXG.toFixed(2)
        };
        
        // === GENERA CONSIGLIO AI REALE (identico alla pagina dettaglio) ===
        try {
          const miniAnalysis = {
            xG: { home: homeXG, away: awayXG, total: totXG },
            p1X2,
            pOU: calcOU(homeXG, awayXG),
            pBTTS,
            exactScores: calcExactScores(homeXG, awayXG).slice(0, 6),
            quality: dataQuality === 'high' ? 'enhanced' : 'base'
          };
          const aiAdvice = generateAIAdvice(match, miniAnalysis);
          if (aiAdvice && aiAdvice.pick) {
            picks.matchAdvices.push({
              match,
              matchId: match.id,
              matchName: matchInfo.matchName,
              homeName: match.home.name,
              awayName: match.away.name,
              homeLogo: match.home.logo || '',
              awayLogo: match.away.logo || '',
              league: matchInfo.league,
              leagueLogo: match.league.logo || '',
              time: matchInfo.time,
              pick: aiAdvice.pick,
              prob: aiAdvice.prob,
              confidence: aiAdvice.confidence,
              reasons: aiAdvice.reasons || [],
              alternatives: aiAdvice.alternatives || [],
              dataQuality,
              xgHome: homeXG.toFixed(2),
              xgAway: awayXG.toFixed(2),
              xgTotal: totXG.toFixed(2)
            });
          }
        } catch (advErr) {
          console.warn('Advice generation failed for', match.home?.name, advErr.message);
        }
        
        // === GENERA CONSIGLIO AI RAPIDO (simile a generateAIAdvice) ===
        const homeStrong = homeXG > 1.8;
        const awayWeak = awayXG < 0.8;
        const awayStrong = awayXG > 1.5;
        const homeWeak = homeXG < 1.0;
        const highScoring = totXG >= 3.0;
        const veryHighScoring = totXG >= 3.8;
        const lowScoring = totXG < 2.2;
        const balanced = Math.abs(homeXG - awayXG) < 0.5;
        const ggLikely = pBTTS >= 55 && homeXG > 0.9 && awayXG > 0.9;
        
        // Multigoal per squadra (per calcolo X intelligente)
        const mgHome = quickCalcOver(homeXG, 0, 0.5); // Prob che casa segni almeno 1
        const mgAway = quickCalcOver(awayXG, 0, 0.5); // Prob che ospite segni almeno 1
        
        let aiPick = '';
        let aiProb = 0;
        let confidence = 'low';
        
        // === SOGLIE ML ADATTIVE ===
        const th1 = getMLThreshold('1');
        const th2 = getMLThreshold('2');
        const thX = getMLThreshold('X');
        const thGG = getMLThreshold('GG');
        const thOver25 = getMLThreshold('Over 2.5');
        const thOver15 = getMLThreshold('Over 1.5');
        const th1X = getMLThreshold('1X');
        
        // Logica di selezione CON SOGLIE ML ADATTIVE
        if (homeStrong && awayWeak && p1X2.home >= th1 + 13) {
          aiPick = '1 (Vittoria Casa)';
          aiProb = p1X2.home;
          confidence = getMLConfidence('1', p1X2.home);
        }
        else if (awayStrong && homeWeak && p1X2.away >= th2 + 8) {
          aiPick = '2 (Vittoria Ospite)';
          aiProb = p1X2.away;
          confidence = getMLConfidence('2', p1X2.away);
        }
        else if (veryHighScoring && pOver25 >= thOver25 + 17) {
          aiPick = 'Over 2.5';
          aiProb = pOver25;
          confidence = getMLConfidence('Over 2.5', pOver25);
        }
        else if (ggLikely && pBTTS >= thGG + 8) {
          aiPick = 'GG (Entrambe Segnano)';
          aiProb = pBTTS;
          confidence = getMLConfidence('GG', pBTTS);
        }
        else if (pOver15 >= thOver15 + 17) {
          aiPick = 'Over 1.5';
          aiProb = pOver15;
          confidence = getMLConfidence('Over 1.5', pOver15);
        }
        else if ((p1X2.home + p1X2.draw) >= th1X + 12) {
          aiPick = '1X (Casa o Pareggio)';
          aiProb = p1X2.home + p1X2.draw;
          confidence = getMLConfidence('1X', aiProb);
        }
        // CALCOLO INTELLIGENTE PER X
        // Se % X Ã¨ alta, MG squadre basse, Under alto â†’ potrebbe essere X
        else if (balanced && p1X2.draw >= thX + 2 && mgHome < 68 && mgAway < 68 && pUnder25 >= 58) {
          aiPick = 'X (Pareggio)';
          aiProb = p1X2.draw;
          confidence = getMLConfidence('X', p1X2.draw);
        }
        else if (pOver15 >= thOver15 + 10) {
          aiPick = 'Over 1.5';
          aiProb = pOver15;
          confidence = 'medium';
        }
        
        // CALCOLO CONFIDENCE FINALE basato su qualitÃ  dati + probabilitÃ 
        if (dataQuality === 'high' && aiProb >= 75) confidence = 'high';
        else if (dataQuality === 'high' && aiProb >= 65) {
          if (confidence === 'low') confidence = 'medium';
        }
        else if (dataQuality === 'low' && confidence === 'high') confidence = 'medium';
        
        // Skip pick se probabilitÃ  troppo bassa (usa soglia ML minima)
        const minThreshold = Math.min(th1, th2, thX, thGG, thOver25) - 5;
        if (!aiPick || aiProb < minThreshold) return;
        
        // Salva il consiglio AI
        allAdvices.push({
          ...matchInfo,
          aiPick,
          aiProb,
          confidence,
          dataQuality,
          p1X2,
          pOver25,
          pBTTS
        });
        
        // === COSTRUISCI RADDOPPI (solo campionati top) ===
        const isTopLeague = TOP_LEAGUES.includes(match.league.id);
        if (isTopLeague) {
          const p1X = p1X2.home + p1X2.draw;
          const pX2 = p1X2.draw + p1X2.away;
          
          if (p1X >= 72) safeBets.push({ ...matchInfo, bet: '1X', prob: p1X, odds: (100 / p1X).toFixed(2) });
          if (pX2 >= 72) safeBets.push({ ...matchInfo, bet: 'X2', prob: pX2, odds: (100 / pX2).toFixed(2) });
          if (pOver15 >= 75) safeBets.push({ ...matchInfo, bet: 'Over 1.5', prob: pOver15, odds: (100 / pOver15).toFixed(2) });
          if (p1X2.home >= 65) safeBets.push({ ...matchInfo, bet: '1', prob: p1X2.home, odds: (100 / p1X2.home).toFixed(2) });
          if (p1X2.away >= 60) safeBets.push({ ...matchInfo, bet: '2', prob: p1X2.away, odds: (100 / p1X2.away).toFixed(2) });
        }
        } catch (err) {
          errorCount++;
          console.warn('Errore analisi partita (primo ciclo):', match?.home?.name, 'vs', match?.away?.name, err.message);
        }
      });
      
      // === RAGGRUPPA TUTTE LE PROBABILITÃ€ (NON SOLO IL CONSIGLIO PRINCIPALE) ===
      // Questa logica prende TUTTE le probabilitÃ  dalla sezione "PRONOSTICI AI"
      // e le raggruppa per categoria (1, X, 2, GG, Over 2.5)
      allAdvices.forEach(advice => {
        const { p1X2, pOver25, pBTTS, matchInfo, match, confidence, dataQuality } = advice;
        
        // Aggiungi 1 (Vittoria Casa) se probabilitÃ  >= 50%
        if (p1X2.home >= 50) {
          picks.vittorieCasa.push({
            ...matchInfo,
            match,
            bet: '1',
            prob: p1X2.home,
            confidence: p1X2.home >= 70 ? 'high' : (p1X2.home >= 60 ? 'medium' : 'low'),
            dataQuality
          });
        }
        
        // === LOGICA AVANZATA PER X (PAREGGIO) ===
        // Condizioni per un buon pareggio:
        // 1. ProbabilitÃ  X alta (>= 25%)
        // 2. Partita equilibrata (differenza 1X2 bassa)
        // 3. Risultato esatto 0-0 o 1-1 probabile
        // 4. Under consigliato (xG totale basso)
        // 5. Multigol squadre bassi (entrambe faticano a segnare)
        
        // Usa le variabili da matchInfo (non da scope esterno)
        const totXGVal = parseFloat(matchInfo?.totXG || matchInfo?.xgTotal || 2.5);
        const homeXGVal = parseFloat(matchInfo?.homeXG || 1.3);
        const awayXGVal = parseFloat(matchInfo?.awayXG || 1.2);
        
        // Calcola "equilibrio" - differenza tra le 3 probabilitÃ 
        const maxProb = Math.max(p1X2.home, p1X2.draw, p1X2.away);
        const minProb = Math.min(p1X2.home, p1X2.draw, p1X2.away);
        const isBalanced = (maxProb - minProb) < 15; // Partita molto equilibrata
        
        // Calcola probabilitÃ  0-0 e 1-1 (risultati esatti da pareggio)
        const p00 = poisson(homeXGVal, 0) * poisson(awayXGVal, 0) * 100;
        const p11 = poisson(homeXGVal, 1) * poisson(awayXGVal, 1) * 100;
        const pDrawScores = p00 + p11; // ProbabilitÃ  combinata 0-0 o 1-1
        
        // Calcola multigol squadre (prob di segnare 0 gol)
        const pHome0 = poisson(homeXGVal, 0) * 100;
        const pAway0 = poisson(awayXGVal, 0) * 100;
        const lowScoringMatch = pHome0 > 25 || pAway0 > 25; // Almeno una squadra ha alta prob di 0 gol
        
        // Under 2.5 consigliato?
        const pUnder25Calc = 100 - pOver25;
        const underSuggested = pUnder25Calc > 50;
        
        // SCORE X: Somma ponderata dei fattori
        let xScore = 0;
        
        // Base: probabilitÃ  X
        xScore += p1X2.draw * 2; // Peso 2x
        
        // Equilibrio 1X2
        if (isBalanced) xScore += 15;
        else if ((maxProb - minProb) < 20) xScore += 10;
        
        // Risultati esatti pareggio (0-0, 1-1)
        if (pDrawScores >= 18) xScore += 20; // 0-0 o 1-1 molto probabili
        else if (pDrawScores >= 12) xScore += 12;
        else if (pDrawScores >= 8) xScore += 6;
        
        // Under consigliato
        if (underSuggested && totXGVal < 2.2) xScore += 15;
        else if (underSuggested) xScore += 8;
        
        // Basso xG totale
        if (totXGVal < 1.8) xScore += 12;
        else if (totXGVal < 2.2) xScore += 6;
        
        // Multigol bassi (squadre non segnano)
        if (lowScoringMatch) xScore += 10;
        
        // DECISIONE: Aggiungi X solo se score >= 55 (soglia stringente per pareggi)
        if (xScore >= 55 && p1X2.draw >= 23) {
          picks.pareggi.push({
            ...matchInfo,
            match,
            bet: 'X',
            prob: p1X2.draw,
            confidence: xScore >= 75 ? 'high' : (xScore >= 65 ? 'medium' : 'low'),
            dataQuality,
            xScore: xScore.toFixed(0), // Score per debug
            pDrawScores: pDrawScores.toFixed(1), // Prob 0-0 + 1-1
            under: underSuggested
          });
        }
        
        // Aggiungi 2 (Vittoria Ospite) se probabilitÃ  >= 45% (in trasferta Ã¨ piÃ¹ difficile)
        if (p1X2.away >= 45) {
          picks.vittorieOspite.push({
            ...matchInfo,
            match,
            bet: '2',
            prob: p1X2.away,
            confidence: p1X2.away >= 65 ? 'high' : (p1X2.away >= 55 ? 'medium' : 'low'),
            dataQuality
          });
        }
        
        // Aggiungi GG se probabilitÃ  >= 52%
        if (pBTTS >= 52) {
          picks.gg.push({
            ...matchInfo,
            match,
            bet: 'GG',
            prob: pBTTS,
            confidence: pBTTS >= 70 ? 'high' : (pBTTS >= 60 ? 'medium' : 'low'),
            dataQuality
          });
        }
        
        // Aggiungi Over 2.5 se probabilitÃ  >= 50%
        if (pOver25 >= 50) {
          picks.over25.push({
            ...matchInfo,
            match,
            bet: 'Over 2.5',
            prob: pOver25,
            confidence: pOver25 >= 70 ? 'high' : (pOver25 >= 60 ? 'medium' : 'low'),
            dataQuality
          });
        }
      });
      
      console.log(`&#x1F4CA; calculateDailyPicks: Processate ${processedCount}, Skipped ${skippedCount}, Errori ${errorCount}`);
      
      // === ORDINA E PRENDI I TOP 20 PER OGNI CATEGORIA ===
      // Ordina per confidence (high > medium) e poi per probabilitÃ 
      const sortByConfidence = (a, b) => {
        const confScore = { high: 3, medium: 2, low: 1 };
        if (confScore[a.confidence] !== confScore[b.confidence]) {
          return confScore[b.confidence] - confScore[a.confidence];
        }
        return b.prob - a.prob;
      };
      
      picks.gg = picks.gg.sort(sortByConfidence).slice(0, 20);
      picks.over25 = picks.over25.sort(sortByConfidence).slice(0, 20);
      picks.vittorieCasa = picks.vittorieCasa.sort(sortByConfidence).slice(0, 20);
      picks.vittorieOspite = picks.vittorieOspite.sort(sortByConfidence).slice(0, 20);
      picks.pareggi = picks.pareggi.sort(sortByConfidence).slice(0, 20);
      
      // Ordina matchAdvices per probabilitÃ  decrescente
      picks.matchAdvices.sort((a, b) => b.prob - a.prob);
      
      // === COSTRUISCI RADDOPPI ===
      picks.raddoppi = buildRaddoppi(safeBets);
      
      state.dailyPicks = picks;
      console.log('&#x1F3AF; Daily picks (AI):', Object.keys(picks).map(k => `${k}: ${picks[k].length}`).join(', '));
    }
    
    // Costruisce combinazioni per raddoppi (quota target ~2.00)
    function buildRaddoppi(safeBets) {
      if (safeBets.length < 2) return [];
      
      const raddoppi = [];
      const targetOdds = 2.0;
      const tolerance = 0.25; // quota tra 1.75 e 2.25
      
      // Ordina per probabilitÃ  decrescente
      safeBets.sort((a, b) => b.prob - a.prob);
      
      // Prova combinazioni di 2, 3, 4 partite
      for (let size = 2; size <= Math.min(4, safeBets.length); size++) {
        const combos = getCombinations(safeBets, size);
        
        for (const combo of combos) {
          // Verifica che non ci siano partite duplicate
          const matchIds = combo.map(c => c.match.id);
          if (new Set(matchIds).size !== matchIds.length) continue;
          
          // Calcola quota totale e probabilitÃ  combinata
          const totalOdds = combo.reduce((acc, c) => acc * parseFloat(c.odds), 1);
          const totalProb = combo.reduce((acc, c) => acc * (c.prob / 100), 1) * 100;
          
          // Se la quota Ã¨ vicina a 2.00
          if (totalOdds >= targetOdds - tolerance && totalOdds <= targetOdds + tolerance) {
            raddoppi.push({
              bets: combo,
              totalOdds: totalOdds.toFixed(2),
              totalProb: totalProb.toFixed(1),
              size: combo.length
            });
          }
        }
      }
      
      // Ordina per probabilitÃ  combinata e prendi i migliori 6
      return raddoppi
        .sort((a, b) => parseFloat(b.totalProb) - parseFloat(a.totalProb))
        .slice(0, 6);
    }
    
    // Genera combinazioni di k elementi da un array
    function getCombinations(arr, k) {
      if (k === 1) return arr.map(x => [x]);
      if (k === arr.length) return [arr];
      if (k > arr.length) return [];
      
      const result = [];
      const n = arr.length;
      
      // Limita per performance
      const maxCombos = 500;
      let count = 0;
      
      function combine(start, combo) {
        if (count >= maxCombos) return;
        if (combo.length === k) {
          result.push([...combo]);
          count++;
          return;
        }
        for (let i = start; i < n && count < maxCombos; i++) {
          combo.push(arr[i]);
          combine(i + 1, combo);
          combo.pop();
        }
      }
      
      combine(0, []);
      return result;
    }
    
    // Calcoli rapidi per picks (senza Dixon-Coles per velocitÃ )
    function quickCalc1X2(lH, lA) {
      // Validazione input
      if (isNaN(lH) || isNaN(lA) || lH < 0 || lA < 0) {
        return { home: 33.33, draw: 33.33, away: 33.33 };
      }
      
      let pH = 0, pD = 0, pA = 0;
      for (let i = 0; i <= 5; i++) {
        for (let j = 0; j <= 5; j++) {
          const p = poisson(lH, i) * poisson(lA, j);
          if (isNaN(p)) continue;
          if (i > j) pH += p; else if (i === j) pD += p; else pA += p;
        }
      }
      const t = pH + pD + pA;
      if (t === 0 || isNaN(t)) return { home: 33.33, draw: 33.33, away: 33.33 };
      return { home: (pH/t)*100, draw: (pD/t)*100, away: (pA/t)*100 };
    }
    
    function quickCalcOver(lH, lA, line) {
      // Validazione input
      if (isNaN(lH) || isNaN(lA) || lH < 0 || lA < 0) return 50;
      
      let pUnder = 0;
      for (let i = 0; i <= 5; i++) {
        for (let j = 0; j <= 5; j++) {
          if (i + j <= Math.floor(line)) {
            const p = poisson(lH, i) * poisson(lA, j);
            if (!isNaN(p)) pUnder += p;
          }
        }
      }
      const over = (1 - pUnder) * 100;
      if (isNaN(over)) return 50;
      return clamp(10, over, 90);
    }
    
    function quickCalcBTTS(lH, lA) {
      // Validazione input
      if (isNaN(lH) || isNaN(lA) || lH < 0 || lA < 0) return 50;
      
      const btts = (1 - poisson(lH, 0)) * (1 - poisson(lA, 0)) * 100;
      if (isNaN(btts)) return 50;
      return clamp(15, btts, 85);
    }
    
    // === TRADER PICKS ===
    // Calcola i migliori picks per il trader con strategia
    function calculateTraderPicks() {
      if (state.matches.length === 0) return;
      
      const MIN_PROB_RADDOPPIO = 72;
      const MIN_PROB_SINGOLA = 60;
      
      const raddoppioPicks = [];
      const singolePicks = [];
      
      // Win rate storici dai tuoi dati (per warning)
      const HISTORICAL_WINRATES = {
        'Under': 100, 'GG': 100, '1': 91.7, '2': 88.9, '1X': 88.9, 'X': 88.9,
        'Over 1.5': 80, 'Over 2.5': 69
      };
      
      state.matches.forEach(match => {
        if (['1H','2H','HT','ET','P','LIVE','FT','AET','PEN'].includes(match.status)) return;
        
        // Stima xG - aumentati per generare picks
        let homeXG = 1.55, awayXG = 1.25;
        const fsKey = `${match.home.name.toLowerCase()}_${match.away.name.toLowerCase()}`.replace(/\s+/g, '');
        const fsMatch = state.fsData.get(fsKey);
        
        if (fsMatch) {
          if (fsMatch.home_xg > 0) homeXG = fsMatch.home_xg;
          else if (fsMatch.home_ppg > 0) homeXG = fsMatch.home_ppg * 0.85;
          if (fsMatch.away_xg > 0) awayXG = fsMatch.away_xg;
          else if (fsMatch.away_ppg > 0) awayXG = fsMatch.away_ppg * 0.75;
        }
        
        homeXG *= 1.10;
        awayXG *= 0.92;
        homeXG = clamp(0.4, homeXG, 3.2);
        awayXG = clamp(0.25, awayXG, 2.8);
        
        const p1X2 = quickCalc1X2(homeXG, awayXG);
        const pOver15 = quickCalcOver(homeXG, awayXG, 1.5);
        const pOver25 = quickCalcOver(homeXG, awayXG, 2.5);
        const pUnder25 = 100 - pOver25;
        const pBTTS = quickCalcBTTS(homeXG, awayXG);
        
        // Trova il miglior pronostico
        const bets = [
          { market: '1', value: '1 Casa', prob: p1X2.home, winRate: HISTORICAL_WINRATES['1'] },
          { market: '1X', value: '1X', prob: p1X2.home + p1X2.draw, winRate: HISTORICAL_WINRATES['1X'] },
          { market: 'X2', value: 'X2', prob: p1X2.draw + p1X2.away, winRate: HISTORICAL_WINRATES['X'] },
          { market: '2', value: '2 Ospite', prob: p1X2.away, winRate: HISTORICAL_WINRATES['2'] },
          { market: 'Over 1.5', value: 'Over 1.5', prob: pOver15, winRate: HISTORICAL_WINRATES['Over 1.5'] },
          { market: 'Under 2.5', value: 'Under 2.5', prob: pUnder25, winRate: HISTORICAL_WINRATES['Under'] },
          { market: 'GG', value: 'GG', prob: pBTTS, winRate: HISTORICAL_WINRATES['GG'] },
          { market: 'NG', value: 'No Gol', prob: 100 - pBTTS, winRate: 100 - HISTORICAL_WINRATES['GG'] }
        ];
        
        const bestBet = bets.reduce((best, b) => b.prob > best.prob ? b : best, bets[0]);
        
        const pick = {
          match,
          bet: bestBet,
          xG: { home: homeXG, away: awayXG, total: homeXG + awayXG },
          time: formatTime(match.date),
          league: `${match.league.country} - ${match.league.name}`
        };
        
        if (bestBet.prob >= MIN_PROB_RADDOPPIO) {
          raddoppioPicks.push(pick);
        } else if (bestBet.prob >= MIN_PROB_SINGOLA) {
          singolePicks.push(pick);
        }
      });
      
      // Ordina e seleziona i migliori
      state.traderPicks.raddoppio = raddoppioPicks.sort((a, b) => b.bet.prob - a.bet.prob).slice(0, 4);
      state.traderPicks.singole = singolePicks.sort((a, b) => b.bet.prob - a.bet.prob).slice(0, 6);
      
      console.log('&#x1F4B0; Trader picks:', 
        `Raddoppio: ${state.traderPicks.raddoppio.length}`,
        `Singole: ${state.traderPicks.singole.length}`);
    }

    // === MONEY MANAGEMENT ===
    // === MONEY MANAGEMENT - SISTEMA OBIETTIVO ===
    
    function saveMoney() {
      localStorage.setItem('bp2_bankroll', state.money.bankroll);
      localStorage.setItem('bp2_target', state.money.target);
      localStorage.setItem('bp2_totalbets', state.money.totalBets);
      localStorage.setItem('bp2_currentbet', state.money.currentBet);
      localStorage.setItem('bp2_odds', state.money.currentOdds);
      localStorage.setItem('bp2_history', JSON.stringify(state.money.history.slice(-30)));
    }
    
    // Calcola quanto puntare per raggiungere l'obiettivo
    function calculateStake() {
      const { bankroll, target, totalBets, currentBet, currentOdds } = state.money;
      const remainingBets = totalBets - currentBet + 1;
      
      if (remainingBets <= 0 || bankroll <= 0 || currentOdds <= 1) {
        return { stake: 0, error: 'Parametri non validi' };
      }
      
      if (bankroll >= target) {
        return { stake: 0, reached: true };
      }
      
      // Calcola il moltiplicatore necessario per giocata
      const totalMultiplier = target / bankroll;
      const perBetMultiplier = Math.pow(totalMultiplier, 1 / remainingBets);
      
      // Calcola la puntata necessaria
      // Se vinco: bankroll + stake Ã— (odds - 1) = bankroll Ã— perBetMultiplier
      const stake = bankroll * (perBetMultiplier - 1) / (currentOdds - 1);
      
      // Limiti di sicurezza
      if (stake > bankroll * 0.95) {
        return { stake: Math.round(bankroll * 0.95 * 100) / 100, warning: 'âš ï¸ Rischio MOLTO alto!' };
      }
      
      if (stake < 0.5) {
        return { stake: 0.5, warning: 'Puntata minima â‚¬0.50' };
      }
      
      return {
        stake: Math.round(stake * 100) / 100,
        perBetMultiplier: perBetMultiplier.toFixed(3),
        potentialWin: Math.round(stake * (currentOdds - 1) * 100) / 100,
        newBankroll: Math.round((bankroll + stake * (currentOdds - 1)) * 100) / 100
      };
    }
    
    function recordBetResult(won) {
      const calc = calculateStake();
      const stake = calc.stake || 0;
      
      state.money.history.push({
        bet: state.money.currentBet,
        date: new Date().toLocaleTimeString('it-IT', {hour:'2-digit', minute:'2-digit'}),
        odds: state.money.currentOdds,
        stake: stake,
        won: won,
        bankrollBefore: state.money.bankroll
      });
      
      if (won) {
        state.money.bankroll += stake * (state.money.currentOdds - 1);
      } else {
        state.money.bankroll -= stake;
      }
      
      state.money.bankroll = Math.max(0, Math.round(state.money.bankroll * 100) / 100);
      state.money.currentBet++;
      
      saveMoney();
      render();
    }
    
    function resetMoney() {
      state.money.currentBet = 1;
      state.money.history = [];
      saveMoney();
      render();
    }
    
    function getMoneyStats() {
      const { bankroll, target, totalBets, currentBet, currentOdds, history } = state.money;
      const calc = calculateStake();
      const wins = history.filter(h => h.won).length;
      const losses = history.filter(h => !h.won).length;
      const progress = Math.min(100, (bankroll / target) * 100);
      
      return {
        bankroll,
        target,
        totalBets,
        currentBet,
        currentOdds,
        remainingBets: Math.max(0, totalBets - currentBet + 1),
        progress,
        stake: calc.stake || 0,
        warning: calc.warning,
        error: calc.error,
        reached: calc.reached,
        potentialWin: calc.potentialWin || 0,
        newBankroll: calc.newBankroll || bankroll,
        perBetMultiplier: calc.perBetMultiplier || '-',
        wins,
        losses,
        winRate: (wins + losses) > 0 ? ((wins / (wins + losses)) * 100).toFixed(0) : '-'
      };
    }

    // === SCHEDINA (localStorage only) ===
    function loadSlipFromLocalStorage() {
      // Usa solo localStorage
      try {
        const saved = localStorage.getItem('bp2_slip');
        if (saved) {
          state.slip = JSON.parse(saved);
          console.log('&#x1F4CB; Schedina caricata:', state.slip.length, 'pronostici');
        }
      } catch (e) {
        console.warn('localStorage load error:', e);
      }
    }

    function saveSlipToLocalStorage() {
      // Usa solo localStorage
      try {
        localStorage.setItem('bp2_slip', JSON.stringify(state.slip));
      } catch (e) {
        console.warn('localStorage save error:', e);
      }
    }

    function addToSlip(match, market, value, prob) {
      const key = `${match.id}_${market}`;
      const exists = state.slip.find(s => s.key === key);
      if (exists) {
        state.slip = state.slip.filter(s => s.key !== key);
      } else {
        state.slip.push({
          key,
          matchId: match.id,
          matchName: `${match.home.name} vs ${match.away.name}`,
          matchDate: match.date,
          market,
          value,
          prob
        });
      }
      saveSlipToLocalStorage();
      render();
    }

    function removeFromSlip(key) {
      state.slip = state.slip.filter(s => s.key !== key);
      saveSlipToLocalStorage();
      render();
    }

    function clearSlip() {
      state.slip = [];
      saveSlipToLocalStorage();
      render();
    }

    function isInSlip(matchId, market) {
      return state.slip.some(s => s.key === `${matchId}_${market}`);
    }

    // === API STATUS CHECK ===
    async function checkAPIStatus() {
      console.log('&#x1F50D; Controllo stato API...');
      
      // Check API-Football - chiamata diretta senza proxy
      // L'API api-sports.io supporta CORS con la chiave corretta
      try {
        const testUrl = `${CONFIG.API_FOOTBALL.baseURL}/status`;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 8000);
        
        const res = await fetch(testUrl, {
          headers: {
            'x-rapidapi-key': CONFIG.API_FOOTBALL.key,
            'x-rapidapi-host': 'v3.football.api-sports.io'
          },
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        
        if (res.ok) {
          const data = await res.json();
          state.api.football = 'online';
          localStorage.setItem('api_football_status', 'online');
          console.log('âœ… API-Football: ONLINE', data?.response?.requests?.current || '');
        } else {
          throw new Error(`HTTP ${res.status}`);
        }
      } catch (e) {
        // Non impostiamo offline subito - potrebbe funzionare comunque
        console.warn('âš ï¸ API-Football status check failed:', e.message);
        // Lasciamo lo stato precedente, verrÃ  aggiornato alla prima chiamata reale
      }
      
      // FootyStats - stato offline di default, verificato on-demand
      console.log('âš ï¸ FootyStats: Verifico on-demand con prima richiesta');
    }

    // === API CALLS ===
    async function callAPIFootball(endpoint, params = {}) {
      const url = new URL(CONFIG.API_FOOTBALL.baseURL + endpoint);
      Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, v));
      
      // Helper per fetch con timeout
      const fetchWithTimeout = async (url, options = {}, timeout = 10000) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        try {
          const res = await fetch(url, { ...options, signal: controller.signal });
          clearTimeout(timeoutId);
          return res;
        } catch (e) {
          clearTimeout(timeoutId);
          throw e;
        }
      };
      
      try {
        const res = await fetchWithTimeout(url.toString(), {
          headers: {
            'x-rapidapi-key': CONFIG.API_FOOTBALL.key,
            'x-rapidapi-host': 'v3.football.api-sports.io'
          }
        }, 15000);
        
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        
        // Aggiorna lo stato SOLO se era offline
        if (state.api.football !== 'online') {
          state.api.football = 'online';
          localStorage.setItem('api_football_status', 'online');
          render();
        }
        
        return data;
      } catch (e) {
        console.error('API Football error:', e);
        
        // Aggiorna lo stato SOLO se era online
        if (state.api.football !== 'offline') {
          state.api.football = 'offline';
          localStorage.setItem('api_football_status', 'offline');
          render();
        }
        
        return null;
      }
    }
    
    // === CLASSIFICA E POSIZIONE ===
    async function getStandings(leagueId, season) {
      const cacheKey = `${leagueId}_${season}`;
      if (state.standingsCache.has(cacheKey)) {
        return state.standingsCache.get(cacheKey);
      }
      
      try {
        const data = await callAPIFootball('/standings', { league: leagueId, season: season || 2024 });
        if (data?.response?.[0]?.league?.standings?.[0]) {
          const standings = data.response[0].league.standings[0];
          state.standingsCache.set(cacheKey, standings);
          return standings;
        }
      } catch (e) {
        console.warn('Standings error:', e);
      }
      return null;
    }
    
    function getTeamPosition(standings, teamId) {
      if (!standings) return null;
      const team = standings.find(s => s.team.id === teamId);
      if (!team) return null;
      
      const totalTeams = standings.length;
      const position = team.rank;
      
      // Calcola motivazione
      let motivation = 'normale';
      let motivationText = '';
      let motivationColor = 'gray';
      
      if (position <= 1) {
        motivation = 'alta';
        motivationText = '&#x1F3C6; Lotta Scudetto';
        motivationColor = 'gold';
      } else if (position <= 4) {
        motivation = 'alta';
        motivationText = 'â­ Zona Champions';
        motivationColor = 'cyan';
      } else if (position <= 6) {
        motivation = 'media-alta';
        motivationText = '&#x1F31F; Zona Europa';
        motivationColor = 'blue';
      } else if (position >= totalTeams - 2) {
        motivation = 'altissima';
        motivationText = '&#x1F525; Zona Retrocessione';
        motivationColor = 'red';
      } else if (position >= totalTeams - 5) {
        motivation = 'alta';
        motivationText = 'âš ï¸ Rischio Retrocessione';
        motivationColor = 'orange';
      } else {
        motivation = 'normale';
        motivationText = 'âž– MetÃ  Classifica';
        motivationColor = 'gray';
      }
      
      return {
        position,
        totalTeams,
        points: team.points,
        form: team.form,
        played: team.all.played,
        won: team.all.win,
        draw: team.all.draw,
        lost: team.all.lose,
        goalsFor: team.all.goals.for,
        goalsAgainst: team.all.goals.against,
        goalDiff: team.goalsDiff,
        motivation,
        motivationText,
        motivationColor
      };
    }
    
    // === INFORTUNATI ===
    async function getInjuries(teamId, season) {
      const cacheKey = `injuries_${teamId}_${season}`;
      if (state.injuriesCache.has(cacheKey)) {
        return state.injuriesCache.get(cacheKey);
      }
      
      try {
        const data = await callAPIFootball('/injuries', { team: teamId, season: season || 2024 });
        if (data?.response) {
          // Filtra solo infortuni attivi (ultimi 30 giorni)
          const now = new Date();
          const thirtyDaysAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);
          
          const injuries = data.response.filter(inj => {
            const injDate = new Date(inj.fixture.date);
            return injDate >= thirtyDaysAgo;
          }).map(inj => ({
            player: inj.player.name,
            type: inj.player.type || 'Infortunio',
            reason: inj.player.reason || 'Non specificato'
          }));
          
          // Rimuovi duplicati
          const uniqueInjuries = injuries.filter((inj, idx, arr) => 
            arr.findIndex(i => i.player === inj.player) === idx
          );
          
          state.injuriesCache.set(cacheKey, uniqueInjuries);
          return uniqueInjuries;
        }
      } catch (e) {
        console.warn('Injuries error:', e);
      }
      return [];
    }
    
    // Calcola impatto infortunati sull'attacco/difesa
    function calculateInjuryImpact(injuries) {
      if (!injuries || injuries.length === 0) return { attack: 1.0, defense: 1.0, text: '' };
      
      let attackImpact = 1.0;
      let defenseImpact = 1.0;
      const keyPlayers = [];
      
      injuries.forEach(inj => {
        // Stima impatto base: -3% per ogni infortunato
        attackImpact *= 0.97;
        defenseImpact *= 0.98;
        keyPlayers.push(inj.player);
      });
      
      // Limita l'impatto massimo
      attackImpact = Math.max(0.75, attackImpact);
      defenseImpact = Math.max(0.80, defenseImpact);
      
      const text = injuries.length > 0 
        ? `${injuries.length} assenti: ${keyPlayers.slice(0, 3).join(', ')}${injuries.length > 3 ? '...' : ''}`
        : '';
      
      return { attack: attackImpact, defense: defenseImpact, text };
    }
    
    // === SALVA IMPOSTAZIONI ===
    function saveSettings() {
      localStorage.setItem('bp2_settings', JSON.stringify(state.settings));
    }
    
    function updateThreshold(type, value) {
      state.settings.thresholds[type] = parseInt(value);
      saveSettings();
      setSmartFilter(state.smartFilters.active);
      render();
    }
    
    function toggleSettingsPanel() {
      state.settingsOpen = !state.settingsOpen;
      render();
    }

    async function callFootyStats(endpoint, params = {}) {
      const url = new URL(CONFIG.FOOTYSTATS.baseURL + endpoint);
      url.searchParams.append('key', CONFIG.FOOTYSTATS.key);
      Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, v));
      
      // Helper per fetch con timeout
      const fetchWithTimeout = async (url, timeout = 8000) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        try {
          const res = await fetch(url, { signal: controller.signal });
          clearTimeout(timeoutId);
          return res;
        } catch (e) {
          clearTimeout(timeoutId);
          throw e;
        }
      };
      
      try {
        // Prova prima senza proxy (potrebbe funzionare)
        try {
          const directRes = await fetchWithTimeout(url.toString(), 5000);
          if (directRes.ok) {
            const data = await directRes.json();
            
            if (state.api.footystats !== 'online') {
              state.api.footystats = 'online';
              localStorage.setItem('api_footystats_status', 'online');
              render();
            }
            
            return data;
          }
        } catch (e) {
          // Ignora errori CORS, proviamo con i proxy
        }
        
        // Lista di proxy CORS alternativi (aggiornata e ampliata)
        const proxies = [
          'https://api.allorigins.win/raw?url=',
          'https://corsproxy.io/?',
          'https://api.codetabs.com/v1/proxy?quest=',
          'https://cors-anywhere.herokuapp.com/',
          'https://thingproxy.freeboard.io/fetch/'
        ];
        
        // Prova ogni proxy in sequenza
        for (const proxy of proxies) {
          try {
            const proxyUrl = proxy + encodeURIComponent(url.toString());
            const res = await fetchWithTimeout(proxyUrl, 10000);
            if (res.ok) {
              const data = await res.json();
              
              if (state.api.footystats !== 'online') {
                state.api.footystats = 'online';
                localStorage.setItem('api_footystats_status', 'online');
                render();
              }
              
              console.log(`âœ… FootyStats funziona con proxy: ${proxy}`);
              return data;
            }
          } catch (e) {
            console.log(`âŒ Proxy ${proxy} fallito, provo il prossimo...`);
            continue;
          }
        }
        
        throw new Error('Tutti i proxy CORS hanno fallito');
      } catch (e) {
        console.error('FootyStats error:', e);
        
        if (state.api.footystats !== 'offline') {
          state.api.footystats = 'offline';
          localStorage.setItem('api_footystats_status', 'offline');
          render();
        }
        
        return null;
      }
    }

    // === DATA LOADING ===
    async function loadMatches(dateOffset = 0) {
      state.loading = true;
      state.selectedDate = dateOffset;
      render();
      
      const dateStr = getDateString(dateOffset);
      console.log('&#x1F4C5; Loading matches for:', dateStr);
      
      try {
        console.log(`&#x1F50D; Requesting fixtures for date: ${dateStr}, timezone: Europe/Rome`);
        const data = await callAPIFootball('/fixtures', { date: dateStr, timezone: 'Europe/Rome' });
        
        console.log('&#x1F4E6; API Response:', data);
        
        if (!data) {
          console.error('âŒ API returned null/undefined');
          state.matches = [];
          state.leagues = [];
          state.error = 'API non disponibile. Controlla la tua connessione o le API key.';
        } else if (data?.response && Array.isArray(data.response)) {
          if (data.response.length === 0) {
            console.log(`â„¹ï¸ Nessuna partita per ${dateStr} (questo Ã¨ normale)`);
            state.matches = [];
            state.leagues = [];
            state.error = null;
          } else {
            const leagueMap = new Map();
            data.response.forEach(f => {
              const key = f.league.id;
              if (!leagueMap.has(key)) {
                leagueMap.set(key, {
                  id: f.league.id,
                  name: f.league.name,
                  country: f.league.country,
                  logo: f.league.logo,
                  season: f.league.season,
                  matchCount: 0
                });
              }
              leagueMap.get(key).matchCount++;
            });
            
            state.leagues = Array.from(leagueMap.values())
              .sort((a, b) => `${a.country} ${a.name}`.localeCompare(`${b.country} ${b.name}`));
            
            state.matches = data.response.map(f => ({
              id: f.fixture.id,
              date: f.fixture.date,
              timestamp: f.fixture.timestamp,
              status: f.fixture.status.short,
              elapsed: f.fixture.status.elapsed,
              league: f.league,
              home: { id: f.teams.home.id, name: f.teams.home.name, logo: f.teams.home.logo },
              away: { id: f.teams.away.id, name: f.teams.away.name, logo: f.teams.away.logo },
              goals: f.goals
            }));
            
            console.log(`âœ… Loaded ${state.leagues.length} leagues, ${state.matches.length} matches for ${dateStr}`);
            state.error = null;
          }
        } else {
          console.error('âš ï¸ Invalid API response format:', data);
          state.matches = [];
          state.leagues = [];
          state.error = 'Formato risposta API non valido';
        }
        
        // Load FootyStats e poi calcola picks (deve aspettare fsData)
        callFootyStats('/todays-matches', {}).then(fsData => {
          if (fsData?.data) {
            fsData.data.forEach(m => {
              if (m.home_name && m.away_name) {
                const keys = [
                  `${m.home_name.toLowerCase()}_${m.away_name.toLowerCase()}`,
                  m.home_name.toLowerCase().replace(/\s+/g, '') + '_' + m.away_name.toLowerCase().replace(/\s+/g, '')
                ];
                keys.forEach(k => state.fsData.set(k, m));
              }
            });
          }
          
          // Calcola i picks DOPO aver caricato FootyStats
          calculateDailyPicks();
          calculateTraderPicks();
          render(); // Re-render per aggiornare i consigli
        }).catch(e => {
          console.warn('FootyStats load failed:', e);
          
          // Calcola picks anche senza FootyStats (con dati base)
          calculateDailyPicks();
          calculateTraderPicks();
          render();
        });
        
      } catch (e) {
        console.error('Load matches error:', e);
        state.matches = [];
        state.leagues = [];
      } finally {
        state.loading = false;
        render();
      }
    }

    // === CORNER & CARDS CALCULATIONS ===
    function calcCorners(homeData, awayData, fsMatch) {
      // Base: medie tipiche per corner (varia per campionato)
      let h = 5.2, a = 4.3;
      
      // Usa dati FootyStats piÃ¹ precisi
      if (fsMatch) {
        if (fsMatch.home_corners && fsMatch.home_corners > 0) h = fsMatch.home_corners;
        else if (fsMatch.team_a_corners_avg && fsMatch.team_a_corners_avg > 0) h = fsMatch.team_a_corners_avg;
        
        if (fsMatch.away_corners && fsMatch.away_corners > 0) a = fsMatch.away_corners;
        else if (fsMatch.team_b_corners_avg && fsMatch.team_b_corners_avg > 0) a = fsMatch.team_b_corners_avg;
        
        // Se disponibile media totale
        if (fsMatch.corners_avg && fsMatch.corners_avg > 0) {
          const fsTotal = fsMatch.corners_avg;
          const ratio = h / (h + a);
          h = fsTotal * ratio;
          a = fsTotal * (1 - ratio);
        }
      }
      
      // MIGLIORAMENTO AVANZATO: 10+ fattori che influenzano i corner
      
      // 1. Stile di gioco offensivo â†’ PiÃ¹ attacchi â†’ PiÃ¹ corner (graduale)
      if (homeData.goalsFor >= 2.5) h *= 1.16;
      else if (homeData.goalsFor >= 2.0) h *= 1.12;
      else if (homeData.goalsFor >= 1.8) h *= 1.08;
      else if (homeData.goalsFor >= 1.5) h *= 1.04;
      
      if (awayData.goalsFor >= 2.2) a *= 1.14;
      else if (awayData.goalsFor >= 1.8) a *= 1.10;
      else if (awayData.goalsFor >= 1.5) a *= 1.06;
      else if (awayData.goalsFor >= 1.2) a *= 1.03;
      
      // 2. Difese deboli â†’ PiÃ¹ pressione â†’ PiÃ¹ corner subiti
      if (homeData.goalsAgainst >= 2.2) a *= 1.12;
      else if (homeData.goalsAgainst >= 1.8) a *= 1.08;
      if (awayData.goalsAgainst >= 2.5) h *= 1.14;
      else if (awayData.goalsAgainst >= 2.0) h *= 1.10;
      
      // 3. Squadre difensive chiuse generano meno corner (bloccano prima)
      if (homeData.goalsFor <= 0.9 && homeData.goalsAgainst <= 1.0) h *= 0.86;
      else if (homeData.goalsFor <= 1.2 && homeData.goalsAgainst <= 1.2) h *= 0.92;
      if (awayData.goalsFor <= 0.8 && awayData.goalsAgainst <= 0.9) a *= 0.83;
      else if (awayData.goalsFor <= 1.0 && awayData.goalsAgainst <= 1.1) a *= 0.90;
      
      // 4. Possesso palla â†’ PiÃ¹ possesso â†’ PiÃ¹ corner
      if (fsMatch) {
        if (fsMatch.team_a_possession && fsMatch.team_a_possession >= 62) h *= 1.10;
        else if (fsMatch.team_a_possession && fsMatch.team_a_possession >= 58) h *= 1.06;
        if (fsMatch.team_b_possession && fsMatch.team_b_possession >= 58) a *= 1.08;
        else if (fsMatch.team_b_possession && fsMatch.team_b_possession >= 55) a *= 1.05;
      }
      
      // 5. Forma recente (rapporto gol fatti/subiti)
      const homeForm = (homeData.goalsFor / Math.max(homeData.goalsAgainst, 0.5));
      const awayForm = (awayData.goalsFor / Math.max(awayData.goalsAgainst, 0.5));
      
      if (homeForm >= 2.2) h *= 1.08;
      else if (homeForm >= 1.8) h *= 1.05;
      else if (homeForm <= 0.6) h *= 0.92;
      
      if (awayForm >= 2.0) a *= 1.07;
      else if (awayForm >= 1.6) a *= 1.04;
      else if (awayForm <= 0.5) a *= 0.90;
      
      // 6. Win Rate alto â†’ Squadre dominanti fanno piÃ¹ corner
      if (homeData.winRate && homeData.winRate >= 65) h *= 1.06;
      else if (homeData.winRate && homeData.winRate >= 55) h *= 1.03;
      if (awayData.winRate && awayData.winRate >= 60) a *= 1.05;
      else if (awayData.winRate && awayData.winRate >= 50) a *= 1.02;
      
      // 7. Partite aperte e ad alto punteggio â†’ PiÃ¹ attacchi â†’ PiÃ¹ corner
      const homeTotalGoals = homeData.goalsFor + homeData.goalsAgainst;
      const awayTotalGoals = awayData.goalsFor + awayData.goalsAgainst;
      if (homeTotalGoals >= 3.5) h *= 1.05;
      if (awayTotalGoals >= 3.2) a *= 1.04;
      
      // 8. Fattore casa: squadre casalinghe attaccano di piÃ¹
      h *= 1.08;
      
      // 9. Squadre che segnano poco ma hanno alta media gol contro = subiscono pressione
      if (homeData.goalsFor <= 1.2 && homeData.goalsAgainst >= 1.5) a *= 1.07;
      if (awayData.goalsFor <= 1.0 && awayData.goalsAgainst >= 1.8) h *= 1.09;
      
      // 10. Bilanciamento finale: squadre molto forti vs molto deboli = dominio = piÃ¹ corner
      const strengthDiff = Math.abs(homeData.goalsFor - awayData.goalsFor);
      if (strengthDiff >= 0.8) {
        if (homeData.goalsFor > awayData.goalsFor) h *= 1.06;
        else a *= 1.06;
      }
      
      h = clamp(2.0, h, 10.0);
      a = clamp(1.5, a, 9.0);
      const total = h + a;
      
      const probs = {};
      
      // MIGLIORAMENTO: Distribuzione Poisson (piÃ¹ accurata per eventi discreti)
      [8.5, 9.5, 10.5, 11.5].forEach(line => {
        let pOver = 0;
        // Calcola probabilitÃ  con Poisson
        for (let i = 0; i <= 20; i++) {
          const pCorners = (Math.pow(total, i) * Math.exp(-total)) / factorial(i);
          if (i > line) pOver += pCorners;
        }
        pOver *= 100;
        
        probs[line] = { 
          over: clamp(15, pOver, 85), 
          under: clamp(15, 100 - pOver, 85) 
        };
      });
      
      return { home: h, away: a, total, probs };
    }
    
    function calcCards(homeData, awayData, fsMatch) {
      // Base: media cartellini per squadra
      let h = homeData.cards || 2.1;
      let a = awayData.cards || 1.9;
      
      // Usa dati FootyStats se disponibili
      if (fsMatch) {
        if (fsMatch.home_cards) h = fsMatch.home_cards;
        if (fsMatch.away_cards) a = fsMatch.away_cards;
      }
      
      // MIGLIORAMENTO AVANZATO: 12+ fattori che influenzano i cartellini
      
      // 1. Squadre sotto pressione (subiscono gol) â†’ PiÃ¹ falli disperati â†’ PiÃ¹ cartellini (graduale)
      if (homeData.goalsAgainst >= 2.5) h *= 1.18;
      else if (homeData.goalsAgainst >= 2.0) h *= 1.14;
      else if (homeData.goalsAgainst >= 1.5) h *= 1.10;
      else if (homeData.goalsAgainst >= 1.2) h *= 1.05;
      
      if (awayData.goalsAgainst >= 2.8) a *= 1.22; // Ospite subisce molto (in trasferta Ã¨ peggio)
      else if (awayData.goalsAgainst >= 2.2) a *= 1.16;
      else if (awayData.goalsAgainst >= 1.8) a *= 1.12;
      else if (awayData.goalsAgainst >= 1.4) a *= 1.07;
      
      // 2. Squadre offensive aggressive (molti gol + molti subiti = partite intense = piÃ¹ falli)
      if (homeData.goalsFor >= 2.5 && homeData.goalsAgainst >= 1.8) h *= 1.12;
      else if (homeData.goalsFor >= 2.0 && homeData.goalsAgainst >= 1.3) h *= 1.08;
      if (awayData.goalsFor >= 2.2 && awayData.goalsAgainst >= 2.0) a *= 1.14;
      else if (awayData.goalsFor >= 1.8 && awayData.goalsAgainst >= 1.5) a *= 1.10;
      
      // 3. Squadre difensive disciplinate (pochi gol, pochi subiti = gioco controllato = meno falli)
      if (homeData.goalsFor <= 0.8 && homeData.goalsAgainst <= 0.8) h *= 0.82;
      else if (homeData.goalsFor <= 1.0 && homeData.goalsAgainst <= 1.0) h *= 0.88;
      if (awayData.goalsFor <= 0.7 && awayData.goalsAgainst <= 0.7) a *= 0.80;
      else if (awayData.goalsFor <= 0.8 && awayData.goalsAgainst <= 0.8) a *= 0.85;
      
      // 4. Ritmo di gioco alto â†’ PiÃ¹ cartellini (graduale)
      const homeIntensity = homeData.goalsFor + homeData.goalsAgainst;
      const awayIntensity = awayData.goalsFor + awayData.goalsAgainst;
      
      if (homeIntensity >= 4.0) h *= 1.10;
      else if (homeIntensity >= 3.5) h *= 1.06;
      if (awayIntensity >= 3.8) a *= 1.09;
      else if (awayIntensity >= 3.2) a *= 1.05;
      
      // 5. Partite equilibrate (differenza xG bassa) â†’ PiÃ¹ tensione â†’ PiÃ¹ cartellini
      const balanceDiff = Math.abs(homeData.goalsFor - awayData.goalsFor);
      if (balanceDiff <= 0.2) {
        h *= 1.12; // Partita molto equilibrata = massima tensione
        a *= 1.12;
      } else if (balanceDiff <= 0.3) {
        h *= 1.08;
        a *= 1.08;
      } else if (balanceDiff <= 0.5) {
        h *= 1.04;
        a *= 1.04;
      }
      
      // 6. Fattore trasferta: squadre ospiti tendono a fare piÃ¹ falli
      a *= 1.08;
      
      // 7. Derby / RivalitÃ  (se entrambe hanno alti cartellini medi)
      if (h >= 2.5 && a >= 2.3) {
        h *= 1.14; // Partita molto tesa
        a *= 1.14;
      } else if (h >= 2.3 && a >= 2.1) {
        h *= 1.10;
        a *= 1.10;
      }
      
      // 8. Importanza della partita (squadre forti = partite importanti = piÃ¹ tensione)
      if (homeData.goalsFor >= 2.0 && awayData.goalsFor >= 1.8) {
        h *= 1.06;
        a *= 1.06;
      } else if (homeData.goalsFor >= 1.8 && awayData.goalsFor >= 1.5) {
        h *= 1.04;
        a *= 1.04;
      }
      
      // 9. Forma recente negativa â†’ PiÃ¹ frustrazione â†’ PiÃ¹ falli
      const homeForm = (homeData.goalsFor / Math.max(homeData.goalsAgainst, 0.5));
      const awayForm = (awayData.goalsFor / Math.max(awayData.goalsAgainst, 0.5));
      
      if (homeForm <= 0.5) h *= 1.08; // Casa in crisi
      else if (homeForm <= 0.7) h *= 1.04;
      if (awayForm <= 0.4) a *= 1.10; // Ospite in crisi
      else if (awayForm <= 0.6) a *= 1.05;
      
      // 10. Win rate basso â†’ Squadre perdenti fanno piÃ¹ falli per disperazione
      if (homeData.winRate && homeData.winRate <= 25) h *= 1.08;
      else if (homeData.winRate && homeData.winRate <= 35) h *= 1.04;
      if (awayData.winRate && awayData.winRate <= 20) a *= 1.10;
      else if (awayData.winRate && awayData.winRate <= 30) a *= 1.05;
      
      // 11. Squadre veloci (molti gol) vs squadre lente (pochi gol) = piÃ¹ falli per fermare contropiede
      if (homeData.goalsFor >= 2.0 && awayData.goalsFor <= 1.0) a *= 1.06;
      if (awayData.goalsFor >= 1.8 && homeData.goalsFor <= 1.0) h *= 1.05;
      
      // 12. Clean sheet basso = difese che subiscono pressione = piÃ¹ falli
      if (homeData.cleanSheetPct && homeData.cleanSheetPct <= 20) h *= 1.05;
      if (awayData.cleanSheetPct && awayData.cleanSheetPct <= 15) a *= 1.06;
      
      h = clamp(1.0, h, 5.5);
      a = clamp(0.8, a, 5.0);
      const total = h + a;
      
      const probs = {};
      
      // MIGLIORAMENTO: Distribuzione Poisson
      [2.5, 3.5, 4.5, 5.5].forEach(line => {
        let pOver = 0;
        // Calcola probabilitÃ  con Poisson
        for (let i = 0; i <= 12; i++) {
          const pCards = (Math.pow(total, i) * Math.exp(-total)) / factorial(i);
          if (i > line) pOver += pCards;
        }
        pOver *= 100;
        
        probs[line] = { 
          over: clamp(18, pOver, 82), 
          under: clamp(18, 100 - pOver, 82) 
        };
      });
      
      return { home: h, away: a, total, probs };
    }

    // === ANALYSIS ENGINE ===
    async function analyzeMatch(match) {
      state.selectedMatch = match;
      state.view = 'analysis';
      state.loading = true;
      state.analysis = null;
      render();
      
      let homeStats = null, awayStats = null, h2h = [], apiPred = null;
      let homeLastMatches = [], awayLastMatches = [];
      let standings = null, homeInjuries = [], awayInjuries = [];
      
      try {
        const [hs, as] = await Promise.all([
          callAPIFootball('/teams/statistics', { team: match.home.id, league: match.league.id, season: match.league.season || 2024 }),
          callAPIFootball('/teams/statistics', { team: match.away.id, league: match.league.id, season: match.league.season || 2024 })
        ]);
        homeStats = hs?.response;
        awayStats = as?.response;
      } catch (e) {}
      
      // Ottieni ultime 5 partite per calcolare form REALE
      try {
        const [homeLastRes, awayLastRes] = await Promise.all([
          callAPIFootball('/fixtures', { team: match.home.id, last: 5 }),
          callAPIFootball('/fixtures', { team: match.away.id, last: 5 })
        ]);
        homeLastMatches = homeLastRes?.response || [];
        awayLastMatches = awayLastRes?.response || [];
      } catch (e) {}
      
      try {
        const h2hRes = await callAPIFootball('/fixtures/headtohead', { h2h: `${match.home.id}-${match.away.id}`, last: 10 });
        h2h = h2hRes?.response || [];
      } catch (e) {}
      
      try {
        const predRes = await callAPIFootball('/predictions', { fixture: match.id });
        apiPred = predRes?.response?.[0];
      } catch (e) {}
      
      // NUOVO: Ottieni classifica
      if (state.settings.showStandings) {
        try {
          standings = await getStandings(match.league.id, match.league.season || 2024);
        } catch (e) {}
      }
      
      // NUOVO: Ottieni infortunati
      if (state.settings.showInjuries) {
        try {
          const [homeInj, awayInj] = await Promise.all([
            getInjuries(match.home.id, match.league.season || 2024),
            getInjuries(match.away.id, match.league.season || 2024)
          ]);
          homeInjuries = homeInj || [];
          awayInjuries = awayInj || [];
        } catch (e) {}
      }
      
      let fsMatch = null;
      const fsKeys = [
        `${match.home.name.toLowerCase()}_${match.away.name.toLowerCase()}`,
        match.home.name.toLowerCase().replace(/\s+/g, '') + '_' + match.away.name.toLowerCase().replace(/\s+/g, '')
      ];
      for (const k of fsKeys) {
        if (state.fsData.has(k)) {
          fsMatch = state.fsData.get(k);
          break;
        }
      }
      
      // Calcola form reale dalle ultime partite
      const homeForm = calculateRealForm(homeLastMatches, match.home.id);
      const awayForm = calculateRealForm(awayLastMatches, match.away.id);
      
      // NUOVO: Calcola posizione e motivazione
      const homePosition = getTeamPosition(standings, match.home.id);
      const awayPosition = getTeamPosition(standings, match.away.id);
      
      // NUOVO: Calcola impatto infortunati
      const homeInjuryImpact = calculateInjuryImpact(homeInjuries);
      const awayInjuryImpact = calculateInjuryImpact(awayInjuries);
      
      state.analysis = buildAnalysis(match, homeStats, awayStats, h2h, apiPred, fsMatch, homeForm, awayForm, {
        homePosition, awayPosition, homeInjuries, awayInjuries, homeInjuryImpact, awayInjuryImpact
      });
      
      // SALVA NELLO STORICO VARIAZIONI
      if (state.analysis) {
        const ai = generateAIAdvice(match, state.analysis);
        const matchName = match.home.name + ' vs ' + match.away.name;
        savePredictionToHistory(match.id, matchName, {
          pick: ai.pick,
          prob: ai.prob
        });
      }
      
      state.loading = false;
      render();
    }
    
    // Calcola form reale dalle ultime partite
    function calculateRealForm(matches, teamId) {
      if (!matches || matches.length === 0) return 'DDDDD';
      
      let form = '';
      matches.forEach(m => {
        const homeGoals = m.goals?.home ?? 0;
        const awayGoals = m.goals?.away ?? 0;
        const isHome = m.teams?.home?.id === teamId;
        
        if (isHome) {
          if (homeGoals > awayGoals) form += 'W';
          else if (homeGoals < awayGoals) form += 'L';
          else form += 'D';
        } else {
          if (awayGoals > homeGoals) form += 'W';
          else if (awayGoals < homeGoals) form += 'L';
          else form += 'D';
        }
      });
      
      return form || 'DDDDD';
    }

    // === ALGORITMO AVANZATO ===
    function buildAnalysis(match, homeStats, awayStats, h2h, apiPred, fsMatch, homeForm, awayForm, extraData = {}) {
      // Extract real data
      const homeData = extractTeamData(homeStats, 'home');
      const awayData = extractTeamData(awayStats, 'away');
      
      // Estrai dati extra
      const { homePosition, awayPosition, homeInjuries, awayInjuries, homeInjuryImpact, awayInjuryImpact } = extraData;
      
      // Calculate xG
      let homeXG = calculateXG(homeData, awayData, 'home', apiPred, fsMatch);
      let awayXG = calculateXG(awayData, homeData, 'away', apiPred, fsMatch);
      
      // H2H adjustment
      if (h2h.length >= 3) {
        const adj = analyzeH2H(h2h, match.home.id);
        homeXG *= adj.homeMultiplier;
        awayXG *= adj.awayMultiplier;
      }
      
      // Form adjustment (ultime 5 partite)
      if (homeForm && awayForm) {
        const homeWins = (homeForm.match(/W/g) || []).length;
        const homeLosses = (homeForm.match(/L/g) || []).length;
        const awayWins = (awayForm.match(/W/g) || []).length;
        const awayLosses = (awayForm.match(/L/g) || []).length;
        
        // Aggiusta xG in base al form recente
        if (homeWins >= 4) homeXG *= 1.08; // Ottima forma casa
        else if (homeWins >= 3) homeXG *= 1.04;
        else if (homeLosses >= 3) homeXG *= 0.92; // Pessima forma casa
        
        if (awayWins >= 4) awayXG *= 1.08; // Ottima forma ospite
        else if (awayWins >= 3) awayXG *= 1.04;
        else if (awayLosses >= 3) awayXG *= 0.92; // Pessima forma ospite
      }
      
      // NOTA: Classifica e Infortuni sono mostrati come INFO ma NON modificano i calcoli
      // per mantenere coerenza con i pronostici storici
      
      // Home advantage (realistico: studi mostrano ~+6% casa, ~-5% trasferta)
      homeXG *= 1.06;  // +6% vantaggio casa (conservativo e realistico)
      awayXG *= 0.95;  // -5% svantaggio trasferta (conservativo e realistico)
      
      // Validazione anti-NaN e valori negativi
      if (isNaN(homeXG) || homeXG < 0) homeXG = 1.2;
      if (isNaN(awayXG) || awayXG < 0) awayXG = 1.0;
      
      // Clamp ai valori realistici
      homeXG = clamp(0.25, homeXG, 3.8);
      awayXG = clamp(0.15, awayXG, 3.2);
      
      const totXG = homeXG + awayXG;
      
      // Probabilities
      const p1X2 = calc1X2(homeXG, awayXG);
      const pOU = calcOU(homeXG, awayXG);
      
      // BTTS avanzato: usa Poisson + dati storici clean sheet
      let pBTTS = calcBTTS(homeXG, awayXG);
      
      // Aggiusta BTTS con dati clean sheet e failed to score
      const homeWillScore = 100 - homeData.failedToScorePct; // % che la casa segna
      const awayWillScore = 100 - awayData.failedToScorePct; // % che l'ospite segna
      const historicalBTTS = (homeWillScore * awayWillScore) / 100;
      
      // Media ponderata: 60% Poisson, 40% storico
      pBTTS = (pBTTS * 0.60) + (historicalBTTS * 0.40);
      pBTTS = clamp(15, pBTTS, 85);
      
      const exactScores = calcExactScores(homeXG, awayXG);
      
      // Corners & Cards
      const corners = calcCorners(homeData, awayData, fsMatch);
      const cards = calcCards(homeData, awayData, fsMatch);
      
      // Build predictions
      const predictions = buildPredictions(match, homeXG, awayXG, p1X2, pOU, pBTTS, exactScores, corners, cards);
      
      // Build combos
      const combos = buildCombos(p1X2, pOU, pBTTS);
      
      // H2H info
      const h2hInfo = summarizeH2H(h2h, match.home.id);
      
      // Multigoal analysis (tutti i range)
      const multigoal = calcAllMultigol(homeXG, awayXG);
      
      // Distribuzione temporale gol
      const temporalDistribution = calcTemporalDistribution(homeXG, awayXG);
      
      // Multigoal squadra
      const multigoalHome = [
        { range: '1+', prob: calcTeamMultigol(homeXG, 1, 6) },
        { range: '2+', prob: calcTeamMultigol(homeXG, 2, 6) },
        { range: '1-2', prob: calcTeamMultigol(homeXG, 1, 2) },
        { range: '1-3', prob: calcTeamMultigol(homeXG, 1, 3) }
      ];
      const multigoalAway = [
        { range: '1+', prob: calcTeamMultigol(awayXG, 1, 6) },
        { range: '2+', prob: calcTeamMultigol(awayXG, 2, 6) },
        { range: '1-2', prob: calcTeamMultigol(awayXG, 1, 2) },
        { range: '1-3', prob: calcTeamMultigol(awayXG, 1, 3) }
      ];
      
      return {
        match,
        xG: { home: homeXG, away: awayXG, total: totXG },
        p1X2, pOU, pBTTS,
        exactScores: exactScores.slice(0, 12),
        corners, cards,
        h2h: h2hInfo,
        h2hInfo,
        predictions,
        combos,
        multigoal,
        temporalDistribution,
        multigoalHome,
        multigoalAway,
        homeForm: homeForm || 'N/A',
        awayForm: awayForm || 'N/A',
        // Dati squadre per Super Algoritmo
        homeData,
        awayData,
        // NUOVO: Classifica e Infortunati
        homePosition,
        awayPosition,
        homeInjuries: homeInjuries || [],
        awayInjuries: awayInjuries || [],
        quality: (homeStats || awayStats) ? 'enhanced' : 'base'
      };
    }

    function extractTeamData(stats, side) {
      if (!stats) return { 
        goalsFor: 1.3, goalsAgainst: 1.2, form: 'DDDDD', corners: 5.0, cards: 1.8,
        cleanSheetPct: 25, failedToScorePct: 25, played: 10, wins: 4, draws: 3, losses: 3
      };
      
      const goals = stats.goals || {};
      const fixtures = stats.fixtures || {};
      const played = (side === 'home' ? fixtures.played?.home : fixtures.played?.away) || fixtures.played?.total || 10;
      const wins = (side === 'home' ? fixtures.wins?.home : fixtures.wins?.away) || fixtures.wins?.total || 4;
      const draws = (side === 'home' ? fixtures.draws?.home : fixtures.draws?.away) || fixtures.draws?.total || 3;
      const losses = (side === 'home' ? fixtures.loses?.home : fixtures.loses?.away) || fixtures.loses?.total || 3;
      
      const forAvg = side === 'home' 
        ? (goals.for?.average?.home || goals.for?.average?.total || 1.3)
        : (goals.for?.average?.away || goals.for?.average?.total || 1.1);
      const againstAvg = side === 'home'
        ? (goals.against?.average?.home || goals.against?.average?.total || 1.2)
        : (goals.against?.average?.away || goals.against?.average?.total || 1.3);
      
      // Clean sheet e failed to score percentuali (con protezione divisione per zero)
      const cleanSheetPct = stats.clean_sheet && played > 0 ? 
        ((side === 'home' ? stats.clean_sheet.home : stats.clean_sheet.away) || stats.clean_sheet.total || 0) / played * 100 : 25;
      const failedToScorePct = stats.failed_to_score && played > 0 ?
        ((side === 'home' ? stats.failed_to_score.home : stats.failed_to_score.away) || stats.failed_to_score.total || 0) / played * 100 : 25;
      
      return {
        goalsFor: parseFloat(forAvg) || 1.3,
        goalsAgainst: parseFloat(againstAvg) || 1.2,
        form: stats.form || 'DDDDD',
        corners: 5.0,
        cards: parseFloat(stats.cards?.yellow?.total) / (played || 1) || 1.8,
        cleanSheetPct: cleanSheetPct || 25,
        failedToScorePct: failedToScorePct || 25,
        played, wins, draws, losses,
        winRate: played > 0 ? (wins / played) * 100 : 40
      };
    }

    function calculateXG(teamData, oppData, side, apiPred, fsMatch) {
      // Base: attacco squadra vs difesa avversaria (ponderato)
      const attackStrength = teamData.goalsFor / 1.25; // Normalizzato su media campionato ~1.25
      const defenseWeakness = oppData.goalsAgainst / 1.25;
      
      let xg = 1.25 * attackStrength * defenseWeakness; // Expected goals base
      
      // Fattore forma recente (peso 20%)
      const formMultiplier = calculateFormMultiplier(teamData.form);
      xg = xg * 0.80 + xg * formMultiplier * 0.20;
      
      // Fattore win rate (squadre che vincono spesso segnano di piÃ¹)
      if (teamData.winRate > 60) xg *= 1.08;
      else if (teamData.winRate < 30) xg *= 0.90;
      
      // Fattore clean sheet avversario (se l'avversario fa molti clean sheet, segnerai meno)
      if (oppData.cleanSheetPct > 40) xg *= 0.88;
      else if (oppData.cleanSheetPct < 20) xg *= 1.10;
      
      // Fattore failed to score (se la squadra spesso non segna)
      if (teamData.failedToScorePct > 35) xg *= 0.85;
      else if (teamData.failedToScorePct < 15) xg *= 1.08;
      
      // API Predictions (peso 35% se disponibili - sono dati molto accurati)
      if (apiPred?.predictions?.goals) {
        const apiGoal = side === 'home' ? parseFloat(apiPred.predictions.goals.home) : parseFloat(apiPred.predictions.goals.away);
        if (apiGoal > 0) xg = (xg * 0.65) + (apiGoal * 0.35);
      }
      
      // FootyStats xG reali (peso 40% se disponibili - sono i piÃ¹ accurati)
      if (fsMatch) {
        const fsXg = side === 'home' ? fsMatch.home_xg : fsMatch.away_xg;
        const fsPpg = side === 'home' ? fsMatch.home_ppg : fsMatch.away_ppg;
        const fsAvgGoals = side === 'home' ? fsMatch.avg_goals_home : fsMatch.avg_goals_away;
        
        if (fsXg && fsXg > 0 && !isNaN(fsXg)) {
          xg = (xg * 0.60) + (fsXg * 0.40);
        } else if (fsAvgGoals && fsAvgGoals > 0 && !isNaN(fsAvgGoals)) {
          xg = (xg * 0.65) + (fsAvgGoals * 0.35);
        } else if (fsPpg && fsPpg > 0 && !isNaN(fsPpg)) {
          xg = (xg * 0.75) + (fsPpg * 0.6 * 0.25); // PPG convertito in gol attesi
        }
      }
      
      // Validazione finale anti-NaN
      if (isNaN(xg) || xg < 0) xg = 1.0;
      
      return xg;
    }

    function calculateFormMultiplier(form) {
      if (!form || form.length === 0) return 1.0;
      
      const recent = form.slice(0, 5).split('');
      let score = 0;
      let totalWeight = 0;
      
      recent.forEach((r, i) => {
        // Peso decrescente: partita piÃ¹ recente conta di piÃ¹
        const weight = Math.pow(0.8, i); // 1, 0.8, 0.64, 0.51, 0.41
        totalWeight += weight;
        
        if (r === 'W') score += 1.0 * weight;      // Vittoria = 1.0
        else if (r === 'D') score += 0.35 * weight; // Pareggio = 0.35
        else if (r === 'L') score += 0.0 * weight;  // Sconfitta = 0
      });
      
      const avgScore = totalWeight > 0 ? score / totalWeight : 0.5;
      
      // Converti in moltiplicatore: range 0.80 - 1.20
      // Score 0 (tutte sconfitte) -> 0.80
      // Score 0.5 (medio) -> 1.00
      // Score 1 (tutte vittorie) -> 1.20
      return 0.80 + (avgScore * 0.40);
    }

    function analyzeH2H(h2h, homeId) {
      if (!h2h || h2h.length === 0) return { homeMultiplier: 1.0, awayMultiplier: 1.0 };
      
      let hg = 0, ag = 0, totalWeight = 0;
      
      h2h.forEach((m, index) => {
        // Peso decrescente per partite piÃ¹ vecchie
        const weight = Math.pow(0.85, index); // Partite recenti contano di piÃ¹
        totalWeight += weight;
        
        const homeGoals = m.goals?.home || 0;
        const awayGoals = m.goals?.away || 0;
        
        if (m.teams?.home?.id === homeId) {
          hg += homeGoals * weight;
          ag += awayGoals * weight;
        } else {
          hg += awayGoals * weight;
          ag += homeGoals * weight;
        }
      });
      
      // Normalizza per il peso totale
      const avgHome = totalWeight > 0 ? hg / totalWeight : 1.2;
      const avgAway = totalWeight > 0 ? ag / totalWeight : 1.0;
      const avgTotal = (avgHome + avgAway) / 2;
      
      // Calcola moltiplicatori con range piÃ¹ ampio per H2H significativi
      const homeMultiplier = avgTotal > 0.1 ? clamp(0.85, avgHome / avgTotal, 1.15) : 1.0;
      const awayMultiplier = avgTotal > 0.1 ? clamp(0.85, avgAway / avgTotal, 1.15) : 1.0;
      
      return { homeMultiplier, awayMultiplier };
    }

    function summarizeH2H(h2h, homeId) {
      const info = { matches: h2h.length, homeWins: 0, draws: 0, awayWins: 0, totalGoals: 0 };
      h2h.forEach(m => {
        const hg = m.goals?.home || 0, ag = m.goals?.away || 0;
        info.totalGoals += hg + ag;
        if (m.teams?.home?.id === homeId) {
          if (hg > ag) info.homeWins++; else if (hg < ag) info.awayWins++; else info.draws++;
        } else {
          if (ag > hg) info.homeWins++; else if (ag < hg) info.awayWins++; else info.draws++;
        }
      });
      info.avgGoals = info.matches ? (info.totalGoals / info.matches).toFixed(1) : '2.5';
      return info;
    }

    function calc1X2(lH, lA) {
      // Validazione input
      if (isNaN(lH) || isNaN(lA) || lH < 0 || lA < 0) {
        return { home: 33.33, draw: 33.33, away: 33.33 };
      }
      
      let pH = 0, pD = 0, pA = 0;
      for (let i = 0; i <= 6; i++) {
        for (let j = 0; j <= 6; j++) {
          const p = poisson(lH, i) * poisson(lA, j);
          if (isNaN(p)) continue; // Salta se NaN
          if (i > j) pH += p; else if (i === j) pD += p; else pA += p;
        }
      }
      const t = pH + pD + pA;
      // Protezione divisione per zero e NaN
      if (t === 0 || isNaN(t)) return { home: 33.33, draw: 33.33, away: 33.33 };
      return { home: (pH/t)*100, draw: (pD/t)*100, away: (pA/t)*100 };
    }

    function calcBTTS(lH, lA) {
      // Validazione input
      if (isNaN(lH) || isNaN(lA) || lH < 0 || lA < 0) return 50;
      
      const pBTTS = (1 - poisson(lH, 0)) * (1 - poisson(lA, 0)) * 100;
      if (isNaN(pBTTS)) return 50;
      
      return clamp(15, pBTTS, 85);
    }

    function calcOU(lH, lA) {
      // Validazione input
      if (isNaN(lH) || isNaN(lA) || lH < 0 || lA < 0) {
        return {
          1.5: { over: 50, under: 50 },
          2.5: { over: 50, under: 50 },
          3.5: { over: 50, under: 50 },
          4.5: { over: 50, under: 50 }
        };
      }
      
      const result = {};
      [1.5, 2.5, 3.5, 4.5].forEach(line => {
        let pU = 0;
        for (let i = 0; i <= 6; i++) {
          for (let j = 0; j <= 6; j++) {
            if (i + j <= Math.floor(line)) {
              const p = poisson(lH, i) * poisson(lA, j);
              if (!isNaN(p)) pU += p; // Aggiungi solo se valido
            }
          }
        }
        const over = (1 - pU) * 100;
        const under = pU * 100;
        result[line] = { 
          over: isNaN(over) ? 50 : clamp(5, over, 95), 
          under: isNaN(under) ? 50 : clamp(5, under, 95) 
        };
      });
      return result;
    }

    function calcExactScores(lH, lA) {
      const scores = [];
      
      // Dixon-Coles correction factor per risultati a basso punteggio
      // Questo corregge la tendenza del Poisson a sottostimare 0-0, 1-0, 0-1, 1-1
      const rho = 0.13; // Fattore di correlazione (valori tipici: 0.10-0.15)
      
      for (let i = 0; i <= 5; i++) {
        for (let j = 0; j <= 5; j++) {
          let p = poisson(lH, i) * poisson(lA, j);
          
          // Applica Dixon-Coles correction per risultati bassi
          if (i === 0 && j === 0) {
            p *= (1 + lH * lA * rho); // 0-0 leggermente piÃ¹ probabile
          } else if (i === 0 && j === 1) {
            p *= (1 + lH * rho); // 0-1 
          } else if (i === 1 && j === 0) {
            p *= (1 + lA * rho); // 1-0
          } else if (i === 1 && j === 1) {
            p *= (1 - rho); // 1-1 leggermente meno probabile (giÃ  frequente)
          }
          
          scores.push({ h: i, a: j, p: p * 100 });
        }
      }
      
      // Normalizza le probabilitÃ 
      const total = scores.reduce((sum, s) => sum + s.p, 0);
      scores.forEach(s => s.p = (s.p / total) * 100);
      
      return scores.sort((a, b) => b.p - a.p);
    }

    function calcMultigol(lH, lA, min, max) {
      let prob = 0;
      for (let i = 0; i <= 6; i++) {
        for (let j = 0; j <= 6; j++) {
          const t = i + j;
          if (t >= min && t <= max) prob += poisson(lH, i) * poisson(lA, j);
        }
      }
      return prob * 100;
    }
    
    // Calcola TUTTI i range multigoal
    function calcAllMultigol(homeXG, awayXG) {
      const ranges = [
        { name: '0-2', min: 0, max: 2 },
        { name: '0-3', min: 0, max: 3 },
        { name: '1-3', min: 1, max: 3 },
        { name: '1-4', min: 1, max: 4 },
        { name: '2-4', min: 2, max: 4 },
        { name: '2-5', min: 2, max: 5 },
        { name: '3-5', min: 3, max: 5 },
        { name: '3-6', min: 3, max: 6 }
      ];
      
      return ranges.map(r => ({
        range: r.name,
        prob: calcMultigol(homeXG, awayXG, r.min, r.max),
        quota: (100 / calcMultigol(homeXG, awayXG, r.min, r.max)).toFixed(2)
      })).sort((a, b) => b.prob - a.prob);
    }
    
    // Calcola distribuzione gol per tempo
    function calcTemporalDistribution(homeXG, awayXG) {
      // Statisticamente: ~42% gol nel 1T, ~58% nel 2T
      const homeXG_1T = homeXG * 0.42;
      const homeXG_2T = homeXG * 0.58;
      const awayXG_1T = awayXG * 0.42;
      const awayXG_2T = awayXG * 0.58;
      
      const totXG_1T = homeXG_1T + awayXG_1T;
      const totXG_2T = homeXG_2T + awayXG_2T;
      
      // Calcola over/under per tempo
      const over05_1T = calcMultigol(homeXG_1T, awayXG_1T, 1, 6);
      const over15_1T = calcMultigol(homeXG_1T, awayXG_1T, 2, 6);
      const over05_2T = calcMultigol(homeXG_2T, awayXG_2T, 1, 6);
      const over15_2T = calcMultigol(homeXG_2T, awayXG_2T, 2, 6);
      
      // Tempo con piÃ¹ gol
      const piuGol1T = totXG_1T > totXG_2T;
      const probPiuGol = piuGol1T ? 
        (totXG_1T / (totXG_1T + totXG_2T)) * 100 :
        (totXG_2T / (totXG_1T + totXG_2T)) * 100;
      
      return {
        primoTempo: {
          xG: totXG_1T,
          over05: over05_1T,
          over15: over15_1T
        },
        secondoTempo: {
          xG: totXG_2T,
          over05: over05_2T,
          over15: over15_2T
        },
        tempoConPiuGol: piuGol1T ? '1Â° Tempo' : '2Â° Tempo',
        probTempoConPiuGol: probPiuGol
      };
    }

    function calcTeamMultigol(l, min, max) {
      let prob = 0;
      for (let i = min; i <= max; i++) prob += poisson(l, i);
      return prob * 100;
    }

    function buildPredictions(match, homeXG, awayXG, p1X2, pOU, pBTTS, exactScores, corners, cards) {
      const preds = [];
      const totXG = homeXG + awayXG;
      
      // xG Primo Tempo (circa 45% dei gol nel 1T)
      const homeXG_1T = homeXG * 0.45;
      const awayXG_1T = awayXG * 0.45;
      
      // 1X2
      const max1X2 = Math.max(p1X2.home, p1X2.draw, p1X2.away);
      let esito = p1X2.home === max1X2 ? '1' : (p1X2.away === max1X2 ? '2' : 'X');
      preds.push({ market: 'Esito 1X2', value: esito, prob: max1X2 });
      
      // GG/NG
      preds.push({ market: 'GG/NG', value: pBTTS >= 50 ? 'GG' : 'NG', prob: pBTTS >= 50 ? pBTTS : 100-pBTTS });
      
      // Over/Under 2.5
      preds.push({ market: 'O/U 2.5', value: pOU[2.5].over >= 50 ? 'Over 2.5' : 'Under 2.5', prob: Math.max(pOU[2.5].over, pOU[2.5].under) });
      
      // Over/Under 1.5
      preds.push({ market: 'O/U 1.5', value: pOU[1.5].over >= 50 ? 'Over 1.5' : 'Under 1.5', prob: Math.max(pOU[1.5].over, pOU[1.5].under) });
      
      // === OVER PRIMO TEMPO ===
      const pOver05_1T = calcOver1T(homeXG_1T, awayXG_1T, 0.5);
      const pOver15_1T = calcOver1T(homeXG_1T, awayXG_1T, 1.5);
      
      // Over 0.5 1T
      preds.push({ market: 'O/U 0.5 1T', value: pOver05_1T >= 50 ? 'Over 0.5 1T' : 'Under 0.5 1T', prob: Math.max(pOver05_1T, 100 - pOver05_1T) });
      
      // Over 1.5 1T (solo se xG Ã¨ alto)
      if (totXG >= 2.5) {
        preds.push({ market: 'O/U 1.5 1T', value: pOver15_1T >= 50 ? 'Over 1.5 1T' : 'Under 1.5 1T', prob: Math.max(pOver15_1T, 100 - pOver15_1T) });
      }
      
      // Multigol
      const mg13 = calcMultigol(homeXG, awayXG, 1, 3);
      const mg24 = calcMultigol(homeXG, awayXG, 2, 4);
      preds.push({ market: 'Multigol', value: totXG < 2.8 ? '1-3' : '2-4', prob: totXG < 2.8 ? mg13 : mg24 });
      
      // MG Casa 1-3
      const mgH = calcTeamMultigol(homeXG, 1, 3);
      preds.push({ market: 'MG Casa', value: '1-3', prob: mgH });
      
      // MG Ospite 1-3
      const mgA = calcTeamMultigol(awayXG, 1, 3);
      preds.push({ market: 'MG Ospite', value: '1-3', prob: mgA });
      
      // Corner
      const cProb = corners.probs[9.5];
      preds.push({ market: 'Corner', value: cProb.over >= 50 ? 'Over 9.5' : 'Under 9.5', prob: Math.max(cProb.over, cProb.under) });
      
      // Cartellini
      const cardLine = cards.total > 4 ? 4.5 : 3.5;
      const cardProb = cards.probs[cardLine];
      preds.push({ market: 'Cartellini', value: cardProb.over >= 50 ? `Over ${cardLine}` : `Under ${cardLine}`, prob: Math.max(cardProb.over, cardProb.under) });
      
      // Risultato Esatto
      preds.push({ market: 'Ris. Esatto', value: `${exactScores[0].h}-${exactScores[0].a}`, prob: exactScores[0].p });
      
      return preds.sort((a, b) => b.prob - a.prob);
    }
    
    // Calcola Over Primo Tempo
    function calcOver1T(homeXG_1T, awayXG_1T, line) {
      let pUnder = 0;
      for (let i = 0; i <= 4; i++) {
        for (let j = 0; j <= 4; j++) {
          if (i + j <= Math.floor(line)) {
            pUnder += poisson(homeXG_1T, i) * poisson(awayXG_1T, j);
          }
        }
      }
      return clamp(10, (1 - pUnder) * 100, 90);
    }

    function buildCombos(p1X2, pOU, pBTTS) {
      const combos = [];
      
      // 1X + Over 1.5
      const p1X = p1X2.home + p1X2.draw;
      const o15 = pOU[1.5].over;
      combos.push({ value: '1X + Over 1.5', prob: (p1X * o15) / 100, odds: (100 / ((p1X * o15) / 100)).toFixed(2) });
      
      // 1 + Over 1.5
      combos.push({ value: '1 + Over 1.5', prob: (p1X2.home * o15) / 100, odds: (100 / ((p1X2.home * o15) / 100)).toFixed(2) });
      
      // GG + Under 3.5
      const u35 = pOU[3.5].under;
      combos.push({ value: 'GG + Under 3.5', prob: (pBTTS * u35) / 100, odds: (100 / ((pBTTS * u35) / 100)).toFixed(2) });
      
      // GG + Over 2.5
      const o25 = pOU[2.5].over;
      combos.push({ value: 'GG + Over 2.5', prob: (pBTTS * o25) / 100, odds: (100 / ((pBTTS * o25) / 100)).toFixed(2) });
      
      return combos.sort((a, b) => b.prob - a.prob);
    }
    
    // === STATISTICAL ADVICE - Pronostico basato SOLO sulla probabilitÃ  piÃ¹ alta ===
    function generateStatisticalAdvice(match, analysis) {
      const { predictions } = analysis;
      const bestPrediction = predictions.reduce((best, current) => {
        return current.prob > best.prob ? current : best;
      }, predictions[0]);
      let confidence = 'medium';
      if (bestPrediction.prob >= 70) confidence = 'high';
      else if (bestPrediction.prob < 55) confidence = 'low';
      const alternatives = predictions
        .filter(p => p.market !== bestPrediction.market)
        .sort((a, b) => b.prob - a.prob)
        .slice(0, 3)
        .map(p => ({ pick: p.value, prob: p.prob.toFixed(0) }));
      return {
        pick: bestPrediction.value,
        market: bestPrediction.market,
        prob: bestPrediction.prob,
        confidence,
        alternatives
      };
    }

    // === AI ADVICE - Genera il consiglio intelligente ===
    function generateAIAdvice(match, analysis) {
      const { xG, p1X2, pOU, pBTTS, exactScores } = analysis;
      const homeXG = xG.home;
      const awayXG = xG.away;
      const totXG = xG.total;
      
      const advice = {
        pick: '',
        prob: 0,
        confidence: 'medium',
        reasons: [],
        alternatives: []
      };
      
      // Analisi della partita
      const homeStrong = homeXG > 1.8;
      const awayWeak = awayXG < 0.8;
      const awayStrong = awayXG > 1.5;
      const homeWeak = homeXG < 1.0;
      const highScoring = totXG >= 3.0;
      const veryHighScoring = totXG >= 3.8;
      const lowScoring = totXG < 2.2;
      const balanced = Math.abs(homeXG - awayXG) < 0.5;
      const ggLikely = pBTTS >= 55 && homeXG > 0.9 && awayXG > 0.9;
      
      // === LOGICA DI SELEZIONE ===
      
      // CASO 1: Casa dominante (xG casa alto, ospite basso) - SOGLIE PIÃ™ ALTE per affidabilitÃ 
      if (homeStrong && awayWeak && p1X2.home >= 68) {
        advice.pick = '1 (Vittoria Casa)';
        advice.prob = p1X2.home;
        advice.confidence = p1X2.home >= 78 ? 'high' : 'medium';
        advice.reasons.push({ text: `xG Casa ${homeXG.toFixed(2)} molto superiore`, type: 'positive' });
        advice.reasons.push({ text: `xG Ospite solo ${awayXG.toFixed(2)}`, type: 'positive' });
        advice.reasons.push({ text: `ProbabilitÃ  ${p1X2.home.toFixed(0)}% favorevole`, type: 'positive' });
        
        if (highScoring) {
          advice.alternatives.push({ pick: '1 + Over 1.5', prob: ((p1X2.home * pOU[1.5].over) / 100).toFixed(0) });
        }
        advice.alternatives.push({ pick: '1X', prob: (p1X2.home + p1X2.draw).toFixed(0) });
      }
      // CASO 2: Trasferta dominante - SOGLIE PIÃ™ ALTE
      else if (awayStrong && homeWeak && p1X2.away >= 63) {
        advice.pick = '2 (Vittoria Ospite)';
        advice.prob = p1X2.away;
        advice.confidence = p1X2.away >= 73 ? 'high' : 'medium';
        advice.reasons.push({ text: `xG Ospite ${awayXG.toFixed(2)} superiore`, type: 'positive' });
        advice.reasons.push({ text: `xG Casa debole ${homeXG.toFixed(2)}`, type: 'positive' });
        
        advice.alternatives.push({ pick: 'X2', prob: (p1X2.away + p1X2.draw).toFixed(0) });
      }
      // CASO 3: Partita da GOL (xG totale alto) - PIÃ™ SELETTIVO
      else if (veryHighScoring && pOU[2.5].over >= 73) {
        advice.pick = 'Over 2.5';
        advice.prob = pOU[2.5].over;
        advice.confidence = pOU[2.5].over >= 82 ? 'high' : 'medium';
        advice.reasons.push({ text: `xG Totale ${totXG.toFixed(2)} molto alto`, type: 'positive' });
        advice.reasons.push({ text: `Entrambe le squadre segnano regolarmente`, type: 'positive' });
        
        advice.alternatives.push({ pick: 'Over 1.5 1T', prob: '60+' });
        advice.alternatives.push({ pick: 'Over 3.5', prob: pOU[3.5].over.toFixed(0) });
        if (ggLikely) advice.alternatives.push({ pick: 'GG', prob: pBTTS.toFixed(0) });
      }
      // CASO 4: GG probabile (entrambe segnano) - SOGLIE PIÃ™ ALTE
      else if (ggLikely && pBTTS >= 63) {
        advice.pick = 'GG (Entrambe Segnano)';
        advice.prob = pBTTS;
        advice.confidence = pBTTS >= 73 ? 'high' : 'medium';
        advice.reasons.push({ text: `xG Casa ${homeXG.toFixed(2)} - segnerÃ `, type: 'positive' });
        advice.reasons.push({ text: `xG Ospite ${awayXG.toFixed(2)} - segnerÃ `, type: 'positive' });
        
        if (highScoring) advice.alternatives.push({ pick: 'GG + Over 2.5', prob: ((pBTTS * pOU[2.5].over) / 100).toFixed(0) });
        advice.alternatives.push({ pick: 'Over 2.5', prob: pOU[2.5].over.toFixed(0) });
      }
      // CASO 5: Over 1.5 sicuro
      else if (pOU[1.5].over >= 80) {
        advice.pick = 'Over 1.5';
        advice.prob = pOU[1.5].over;
        advice.confidence = 'high';
        advice.reasons.push({ text: `ProbabilitÃ  ${pOU[1.5].over.toFixed(0)}% molto alta`, type: 'positive' });
        advice.reasons.push({ text: `xG Totale ${totXG.toFixed(2)} supporta gol`, type: 'positive' });
        
        advice.alternatives.push({ pick: '1X + Over 1.5', prob: (((p1X2.home + p1X2.draw) * pOU[1.5].over) / 100).toFixed(0) });
      }
      // CASO 6: Pareggio probabile (X) - MIGLIORATO
      else if (balanced && p1X2.draw >= 30 && lowScoring && Math.abs(p1X2.home - p1X2.away) < 10) {
        // Condizioni per X:
        // - xG equilibrati (diff < 0.5)
        // - Prob pareggio >= 30%
        // - Partita a basso punteggio (xG tot < 2.2)
        // - Home e Away con probabilitÃ  simili (diff < 10%)
        advice.pick = 'X (Pareggio)';
        advice.prob = p1X2.draw;
        advice.confidence = p1X2.draw >= 35 ? 'medium' : 'low';
        advice.reasons.push({ text: `Squadre molto equilibrate: xG ${homeXG.toFixed(2)} vs ${awayXG.toFixed(2)}`, type: 'positive' });
        advice.reasons.push({ text: `Partita a basso punteggio previsto (${totXG.toFixed(2)} gol totali)`, type: 'positive' });
        advice.reasons.push({ text: `ProbabilitÃ  pareggio ${p1X2.draw.toFixed(0)}%`, type: 'positive' });
        
        advice.alternatives.push({ pick: 'Under 2.5', prob: pOU[2.5].under.toFixed(0) });
        advice.alternatives.push({ pick: '12 (No Pareggio)', prob: (p1X2.home + p1X2.away).toFixed(0) });
        if (pBTTS >= 45 && pBTTS <= 60) advice.alternatives.push({ pick: 'X + GG', prob: ((p1X2.draw * pBTTS) / 100).toFixed(0) });
      }
      // CASO 7: 1X sicuro (casa non perde)
      else if ((p1X2.home + p1X2.draw) >= 80) {
        advice.pick = '1X (Casa o Pareggio)';
        advice.prob = p1X2.home + p1X2.draw;
        advice.confidence = 'high';
        advice.reasons.push({ text: `Casa forte con xG ${homeXG.toFixed(2)}`, type: 'positive' });
        advice.reasons.push({ text: `Vittoria ospite improbabile (${p1X2.away.toFixed(0)}%)`, type: 'positive' });
        
        advice.alternatives.push({ pick: '1', prob: p1X2.home.toFixed(0) });
        if (highScoring) advice.alternatives.push({ pick: '1X + Over 1.5', prob: (((p1X2.home + p1X2.draw) * pOU[1.5].over) / 100).toFixed(0) });
      }
      // CASO 8: Partita equilibrata (generale)
      else if (balanced && p1X2.draw >= 28) {
        advice.pick = 'Under 3.5';
        advice.prob = pOU[3.5].under;
        advice.confidence = lowScoring ? 'medium' : 'low';
        advice.reasons.push({ text: `Partita equilibrata (xG simili)`, type: 'neutral' });
        advice.reasons.push({ text: `Possibile pareggio (${p1X2.draw.toFixed(0)}%)`, type: 'neutral' });
        
        advice.alternatives.push({ pick: 'X', prob: p1X2.draw.toFixed(0) });
        advice.alternatives.push({ pick: 'Under 2.5', prob: pOU[2.5].under.toFixed(0) });
      }
      // CASO 8: Default - Over 1.5 (quasi sempre valido)
      else {
        advice.pick = 'Over 1.5';
        advice.prob = pOU[1.5].over;
        advice.confidence = pOU[1.5].over >= 70 ? 'medium' : 'low';
        advice.reasons.push({ text: `Pronostico piÃ¹ sicuro per questa partita`, type: 'neutral' });
        advice.reasons.push({ text: `xG Totale ${totXG.toFixed(2)}`, type: 'neutral' });
        
        if (p1X2.home >= 55) advice.alternatives.push({ pick: '1X', prob: (p1X2.home + p1X2.draw).toFixed(0) });
      }
      
      // Aggiungi warning se i dati non sono affidabili
      if (analysis.quality === 'base') {
        advice.reasons.push({ text: 'Dati statistici limitati', type: 'negative' });
        if (advice.confidence === 'high') advice.confidence = 'medium';
      }
      
      return advice;
    }

    // === SUPER ALGORITHM ===
    // Meta-analisi che valuta ogni segnale dell'algoritmo base e produce
    // un ranking affidabile di pronostici con score composito
    function runSuperAlgorithm(match, analysis) {
      const { xG, p1X2, pOU, pBTTS, exactScores, multigoal, multigoalHome, multigoalAway, temporalDistribution, h2hInfo, homeData, awayData, homeForm, awayForm } = analysis;
      const homeXG = xG.home;
      const awayXG = xG.away;
      const totXG  = xG.total;
      
      // Helper: form score 0-5 (W=1, D=0.4, L=0)
      const formScore = (form) => {
        if (!form || form === 'N/A') return 2.5;
        return form.slice(0,5).split('').reduce((s,c) => s + (c==='W'?1:c==='D'?0.4:0), 0);
      };
      const homeFS = formScore(homeForm);
      const awayFS  = formScore(awayForm);
      
      // ML accuracy weights
      const mlWeights = {};
      Object.entries(state.mlThresholds||{}).forEach(([market, data]) => {
        const acc = data.totalPredictions >= 10 ? parseFloat(data.accuracy) / 100 : 0.5;
        mlWeights[market] = Math.min(0.92, Math.max(0.4, acc));
      });
      const getML = (k) => mlWeights[k] || 0.5;
      
      // H2H helpers
      const h2h = h2hInfo || {};
      const h2hAvgGoals = parseFloat(h2h.avgGoals) || totXG;
      const h2hHomeWins = h2h.homeWins || 0;
      const h2hAwayWins = h2h.awayWins || 0;
      const h2hDraws    = h2h.draws || 0;
      const h2hTotal    = h2hHomeWins + h2hAwayWins + h2hDraws || 1;
      
      // Stats helpers
      const hGF = homeData?.goalsFor || 1.3;
      const hGA = homeData?.goalsAgainst || 1.2;
      const aGF = awayData?.goalsFor || 1.1;
      const aGA = awayData?.goalsAgainst || 1.3;
      const hCS  = homeData?.cleanSheetPct || 25;
      const aCS  = awayData?.cleanSheetPct || 25;
      const hFTS = homeData?.failedToScorePct || 25;
      const aFTS = awayData?.failedToScorePct || 25;
      const hWR  = homeData?.winRate || 40;
      const aWR  = awayData?.winRate || 35;
      
      // Exact score sum helpers
      const esFilter = (fn) => exactScores ? exactScores.filter(fn).reduce((s,e)=>s+e.p,0) : 0;
      
      const candidates = [];
      
      // ====================================================
      // FUNZIONE SCORING UNIFICATA
      // ====================================================
      function buildCandidate(opts) {
        const { market, value, icon, color, prob, signals, mlKey, contextMult } = opts;
        const signalKeys  = Object.keys(signals);
        const signalVals  = Object.values(signals);
        const signalCount = signalVals.filter(Boolean).length;
        const totalSignals = signalKeys.length;
        const convergence  = signalCount / totalSignals;
        const mlW = getML(mlKey || value);
        
        // SuperScore: prob Ã— convergenza Ã— ML Ã— contesto
        // Normalizzato: prob su 100 â†’ score 0-100
        const rawScore = (prob / 100) * convergence * (0.45 + mlW * 0.55) * (contextMult || 1.0);
        const superScore = rawScore * 100;
        
        // Confidenza calibrata per mercato
        let confidence = 'low';
        const highThresh = opts.highThresh || { prob: 72, conv: 0.65 };
        const medThresh  = opts.medThresh  || { prob: 55, conv: 0.50 };
        if (prob >= highThresh.prob && convergence >= highThresh.conv) confidence = 'high';
        else if (prob >= medThresh.prob && convergence >= medThresh.conv) confidence = 'medium';
        
        return { market, value, icon, color, prob, signals, signalCount, totalSignals, convergence, superScore, confidence, mlAccuracy: mlW * 100 };
      }
      
      // ====================================================
      // 1 â€” VITTORIA CASA
      // ====================================================
      candidates.push(buildCandidate({
        market: 'Esito 1X2', value: '1 (Casa)', icon: '&#x1F3E0;', color: '#0284c7',
        prob: p1X2.home, mlKey: '1',
        contextMult: homeXG > awayXG * 1.1 ? 1.12 : homeXG < awayXG ? 0.88 : 1.0,
        highThresh: { prob: 68, conv: 0.62 }, medThresh: { prob: 52, conv: 0.50 },
        signals: {
          poisson_forte:    p1X2.home >= 50,
          xG_superiore:     homeXG > awayXG * 1.15,
          xG_almeno_1:      homeXG >= 1.0,
          forma_casa:       homeFS >= 3.0,
          h2h_casa:         h2hHomeWins > h2hAwayWins,
          win_rate_ok:      hWR >= 45,
          ospite_attacco_debole: aGF <= 1.1,
          ospite_FTS_alto:  aFTS >= 28,
          temporale_casa:   temporalDistribution ? temporalDistribution.primoTempo.casa >= 35 : p1X2.home >= 50,
          algo_alta_conf:   p1X2.home >= 60,
        }
      }));
      
      // ====================================================
      // X â€” PAREGGIO
      // ====================================================
      {
        const drawExact = esFilter(s => s.h === s.a);
        const balanced  = Math.abs(homeXG - awayXG) < 0.35;
        candidates.push(buildCandidate({
          market: 'Esito 1X2', value: 'X (Pareggio)', icon: '&#x1F91D;', color: '#f59e0b',
          prob: p1X2.draw, mlKey: 'X',
          contextMult: balanced ? 1.18 : Math.abs(p1X2.home - p1X2.away) < 10 ? 1.08 : 0.82,
          highThresh: { prob: 30, conv: 0.60 }, medThresh: { prob: 25, conv: 0.50 },
          signals: {
            poisson_pareggio:  p1X2.draw >= 26,
            xG_bilanciato:     balanced,
            bassa_prod:        totXG < 2.3,
            pari_exact_scores: drawExact >= 14,
            under_25:          pOU[2.5].under >= 52,
            probs_vicine:      Math.abs(p1X2.home - p1X2.away) < 14,
            h2h_draw:          h2hDraws / h2hTotal >= 0.28,
            forma_simile:      Math.abs(homeFS - awayFS) < 0.8,
          }
        }));
      }
      
      // ====================================================
      // 2 â€” VITTORIA OSPITE
      // ====================================================
      candidates.push(buildCandidate({
        market: 'Esito 1X2', value: '2 (Ospite)', icon: '&#x2708;&#xFE0F;', color: '#8b5cf6',
        prob: p1X2.away, mlKey: '2',
        contextMult: awayXG > homeXG * 1.1 ? 1.12 : awayXG < homeXG ? 0.88 : 1.0,
        highThresh: { prob: 62, conv: 0.62 }, medThresh: { prob: 48, conv: 0.50 },
        signals: {
          poisson_forte:    p1X2.away >= 42,
          xG_superiore:     awayXG > homeXG * 1.10,
          xG_almeno_1:      awayXG >= 0.9,
          forma_ospite:     awayFS >= 3.0,
          h2h_ospite:       h2hAwayWins > h2hHomeWins,
          win_rate_ok:      aWR >= 40,
          casa_FTS_alto:    hFTS >= 25,
          algo_alta_conf:   p1X2.away >= 55,
          ospite_GF_alto:   aGF >= 1.4,
        }
      }));
      
      // ====================================================
      // GG â€” ENTRAMBE SEGNANO
      // ====================================================
      candidates.push(buildCandidate({
        market: 'GG/NG', value: 'GG (Entrambe)', icon: '&#x26BD;', color: '#10b981',
        prob: pBTTS, mlKey: 'GG',
        contextMult: (homeXG >= 1.1 && awayXG >= 0.9) ? 1.08 : 0.92,
        highThresh: { prob: 66, conv: 0.62 }, medThresh: { prob: 54, conv: 0.50 },
        signals: {
          poisson_gg:       pBTTS >= 52,
          xG_casa_ok:       homeXG >= 0.9,
          xG_ospite_ok:     awayXG >= 0.85,
          tot_xG_alto:      totXG >= 2.3,
          casa_CS_basso:    hCS <= 35,
          ospite_CS_basso:  aCS <= 35,
          casa_FTS_basso:   hFTS <= 32,
          ospite_FTS_basso: aFTS <= 35,
          forma_attacchi:   homeFS >= 2.5 && awayFS >= 2.5,
          h2h_GG:           h2hAvgGoals >= 2.4,
        }
      }));
      
      // ====================================================
      // NG â€” NESSUNA DELLE DUE SEGNA
      // ====================================================
      candidates.push(buildCandidate({
        market: 'GG/NG', value: 'NG (Nessuna)', icon: '&#x1F6AB;', color: '#64748b',
        prob: 100 - pBTTS, mlKey: 'NG',
        contextMult: (hCS >= 35 || aCS >= 35) ? 1.10 : 0.90,
        highThresh: { prob: 58, conv: 0.62 }, medThresh: { prob: 45, conv: 0.48 },
        signals: {
          poisson_ng:       (100-pBTTS) >= 45,
          casa_difesa:      hCS >= 32,
          ospite_difesa:    aCS >= 32,
          casa_FTS:         hFTS >= 30,
          ospite_FTS:       aFTS >= 30,
          basso_xG:         totXG < 2.0,
          under_15:         pOU[1.5].under >= 25,
        }
      }));
      
      // ====================================================
      // OVER 1.5
      // ====================================================
      candidates.push(buildCandidate({
        market: 'Over/Under', value: 'Over 1.5', icon: '&#x1F4C8;', color: '#06b6d4',
        prob: pOU[1.5].over, mlKey: 'Over 1.5',
        contextMult: totXG >= 2.0 ? 1.06 : 0.95,
        highThresh: { prob: 82, conv: 0.65 }, medThresh: { prob: 68, conv: 0.50 },
        signals: {
          poisson_o15:      pOU[1.5].over >= 68,
          xG_tot_ok:        totXG >= 1.6,
          entrambi_attacco: homeXG >= 0.75 && awayXG >= 0.65,
          h2h_gol:          h2hAvgGoals >= 2.0,
          btts_supp:        pBTTS >= 44,
          casa_GF:          hGF >= 1.3,
          ospite_GF:        aGF >= 1.0,
          forma_gol:        homeFS >= 2.2 && awayFS >= 2.0,
        }
      }));
      
      // ====================================================
      // OVER 2.5
      // ====================================================
      candidates.push(buildCandidate({
        market: 'Over/Under', value: 'Over 2.5', icon: '&#x1F525;', color: '#f97316',
        prob: pOU[2.5].over, mlKey: 'Over 2.5',
        contextMult: totXG >= 2.8 ? 1.10 : totXG < 2.0 ? 0.85 : 1.0,
        highThresh: { prob: 65, conv: 0.62 }, medThresh: { prob: 50, conv: 0.50 },
        signals: {
          poisson_o25:      pOU[2.5].over >= 46,
          xG_alto:          totXG >= 2.5,
          entrambi_attacco: homeXG >= 1.1 && awayXG >= 0.95,
          h2h_gol:          h2hAvgGoals >= 2.5,
          btts:             pBTTS >= 52,
          casa_GF_alto:     hGF >= 1.6,
          ospite_GF_alto:   aGF >= 1.3,
          forme_offensive:  homeFS >= 3.0 || awayFS >= 3.0,
          o25_h2h:          h2hAvgGoals >= 2.6,
        }
      }));
      
      // ====================================================
      // UNDER 2.5
      // ====================================================
      candidates.push(buildCandidate({
        market: 'Over/Under', value: 'Under 2.5', icon: '&#x1F6E1;', color: '#0ea5e9',
        prob: pOU[2.5].under, mlKey: 'Under 2.5',
        contextMult: totXG < 2.0 ? 1.12 : totXG > 2.8 ? 0.82 : 1.0,
        highThresh: { prob: 62, conv: 0.62 }, medThresh: { prob: 50, conv: 0.48 },
        signals: {
          poisson_u25:     pOU[2.5].under >= 46,
          xG_basso:        totXG < 2.2,
          difese_forti:    hCS >= 30 || aCS >= 30,
          ng_likely:       pBTTS <= 48,
          exact_low:       esFilter(s => s.h+s.a <= 2) >= 42,
          h2h_low:         h2hAvgGoals < 2.3,
          casa_GF_basso:   hGF <= 1.4,
          ospite_GF_basso: aGF <= 1.2,
        }
      }));
      
      // ====================================================
      // OVER 3.5
      // ====================================================
      candidates.push(buildCandidate({
        market: 'Over/Under', value: 'Over 3.5', icon: '&#x1F4A5;', color: '#ef4444',
        prob: pOU[3.5].over, mlKey: 'Over 3.5',
        contextMult: totXG >= 3.5 ? 1.15 : totXG < 2.5 ? 0.75 : 1.0,
        highThresh: { prob: 50, conv: 0.65 }, medThresh: { prob: 35, conv: 0.50 },
        signals: {
          poisson_o35:     pOU[3.5].over >= 32,
          xG_molto_alto:   totXG >= 3.2,
          entrambi_forti:  homeXG >= 1.5 && awayXG >= 1.3,
          h2h_alti:        h2hAvgGoals >= 3.0,
          over25_alto:     pOU[2.5].over >= 62,
          btts_over:       pBTTS >= 58 && pOU[2.5].over >= 58,
        }
      }));
      
      // ====================================================
      // MG CASA 1-3
      // ====================================================
      {
        const prob = calcTeamMultigol(homeXG, 1, 3);
        candidates.push(buildCandidate({
          market: 'MG Casa', value: 'MG Casa 1-3', icon: '&#x1F3E0;&#x26BD;', color: '#d97706',
          prob, mlKey: 'MG Casa',
          contextMult: homeXG >= 0.9 && homeXG <= 2.1 ? 1.05 : 0.95,
          highThresh: { prob: 62, conv: 0.60 }, medThresh: { prob: 50, conv: 0.48 },
          signals: {
            xG_range_ottimo:   homeXG >= 0.85 && homeXG <= 2.2,
            prob_alta:         prob >= 52,
            casa_FTS_basso:    hFTS <= 32,
            casa_WR_ok:        hWR >= 35,
            ospite_def_debole: aGA >= 1.2,
            exact_h_1_3:       esFilter(s => s.h >= 1 && s.h <= 3) >= 55,
            forma_casa:        homeFS >= 2.5,
          }
        }));
      }
      
      // ====================================================
      // MG OSPITE 1-3
      // ====================================================
      {
        const prob = calcTeamMultigol(awayXG, 1, 3);
        candidates.push(buildCandidate({
          market: 'MG Ospite', value: 'MG Ospite 1-3', icon: '&#x2708;&#xFE0F;&#x26BD;', color: '#059669',
          prob, mlKey: 'MG Ospite',
          contextMult: awayXG >= 0.75 && awayXG <= 2.0 ? 1.05 : 0.95,
          highThresh: { prob: 60, conv: 0.60 }, medThresh: { prob: 48, conv: 0.48 },
          signals: {
            xG_range_ottimo:  awayXG >= 0.75 && awayXG <= 2.0,
            prob_alta:        prob >= 50,
            ospite_FTS_basso: aFTS <= 35,
            ospite_WR_ok:     aWR >= 30,
            casa_def_debole:  hGA >= 1.15,
            exact_a_1_3:      esFilter(s => s.a >= 1 && s.a <= 3) >= 50,
            forma_ospite:     awayFS >= 2.2,
          }
        }));
      }
      
      // ====================================================
      // 1X â€” DOPPIA CHANCE CASA
      // ====================================================
      {
        const prob = Math.min(p1X2.home + p1X2.draw, 97);
        candidates.push(buildCandidate({
          market: 'Doppia Chance', value: '1X (Casa/Pari)', icon: '&#x1F512;', color: '#0284c7',
          prob, mlKey: '1X',
          contextMult: 0.90,  // penalty: e' doppia chance
          highThresh: { prob: 80, conv: 0.70 }, medThresh: { prob: 68, conv: 0.55 },
          signals: {
            poisson_alto:   prob >= 64,
            casa_not_weak:  homeXG >= awayXG * 0.85,
            forma_casa:     homeFS >= 2.2,
            under_35:       pOU[3.5].under >= 55,
            hWR_minimo:     hWR >= 28,
          }
        }));
      }
      
      // ====================================================
      // X2 â€” DOPPIA CHANCE OSPITE
      // ====================================================
      {
        const prob = Math.min(p1X2.away + p1X2.draw, 97);
        candidates.push(buildCandidate({
          market: 'Doppia Chance', value: 'X2 (Ospite/Pari)', icon: '&#x1F510;', color: '#8b5cf6',
          prob, mlKey: 'X2',
          contextMult: 0.88,
          highThresh: { prob: 75, conv: 0.70 }, medThresh: { prob: 62, conv: 0.55 },
          signals: {
            poisson_alto:    prob >= 58,
            ospite_not_weak: awayXG >= homeXG * 0.80,
            forma_ospite:    awayFS >= 2.2,
            under_35:        pOU[3.5].under >= 55,
            aWR_minimo:      aWR >= 24,
          }
        }));
      }
      
      // ====================================================
      // ORDINA per SuperScore decrescente
      // ====================================================
      candidates.sort((a, b) => b.superScore - a.superScore);
      
      const topPick = candidates[0];
      const avgConvergence = candidates.reduce((s,c) => s + c.convergence, 0) / candidates.length;
      const highConfCount  = candidates.filter(c => c.confidence === 'high').length;
      
      return {
        picks: candidates,
        topPick,
        avgConvergence,
        highConfCount,
        totalSignals: candidates.reduce((s,c) => s + c.signalCount, 0),
        analysisDepth: analysis.quality === 'enhanced' ? 'Completa' : analysis.quality === 'partial' ? 'Parziale' : 'Base'
      };
    }

    function renderSuperAnalysis(superData, match) {
      if (!superData) {
        return `
          <div class="super-algo-panel">
            <div class="super-loading">
              <div class="super-loading-spinner"></div>
              <div style="font-size:0.88rem; font-weight:600; color:#00d4ff; margin-bottom:4px;">&#x1F9E0; Calcolo in corso...</div>
              <div style="font-size:0.75rem; color:rgba(148,163,184,0.6);">Analisi Poisson, xG, ML, segnali multi-fonte</div>
            </div>
          </div>`;
      }
      
      const { picks, avgConvergence, highConfCount, analysisDepth } = superData;
      const aiData = state.superAIAnalysis;
      const aiLoading = state.superAIRunning;
      
      // Oracle verdict colors
      let recColor = '#64748b', recBg = 'rgba(100,116,139,0.15)', recIcon = '&#x23F3;';
      if (aiData) {
        if (aiData.recommendation === 'GIOCA') { recColor = '#00e5a0'; recBg = 'rgba(0,229,160,0.1)'; recIcon = '&#x2705;'; }
        else if (aiData.recommendation === 'SKIP') { recColor = '#f87171'; recBg = 'rgba(248,113,113,0.1)'; recIcon = '&#x26D4;'; }
        else if (aiData.recommendation === 'ATTENDI') { recColor = '#fbbf24'; recBg = 'rgba(251,191,36,0.1)'; recIcon = '&#x26A0;&#xFE0F;'; }
      }
      
      // AI section
      let aiSection = '';
      if (aiLoading) {
        aiSection = `
          <div class="super-ai-section">
            <div class="super-ai-header">
              <span class="super-ai-live">AI LIVE</span>
              <span style="font-weight:700;">&#x1F30D; Oracle AI sta analizzando...</span>
            </div>
            <div style="display:flex;align-items:center;gap:12px;padding:16px;background:rgba(0,0,0,0.3);border-radius:12px;border:1px solid rgba(0,212,255,0.1);">
              <div class="super-loading-spinner" style="width:20px;height:20px;border-width:2px;margin:0;flex-shrink:0;"></div>
              <div>
                <div style="font-size:0.84rem;color:#00d4ff;font-weight:600;margin-bottom:3px;">&#x1F4F0; Ricerca news in tempo reale...</div>
                <div style="font-size:0.75rem;color:rgba(148,163,184,0.6);">Infortuni &#x2022; Formazioni &#x2022; Stato di forma &#x2022; Contesto tattico &#x2022; Motivazioni</div>
              </div>
            </div>
          </div>`;
      } else if (aiData && !aiData.error) {
        const newsHtml = (aiData.keyNews || []).map(n => 
          `<div class="oracle-news-item"><span style="color:#f59e0b;flex-shrink:0;">&#x2022;</span><span>${n}</span></div>`
        ).join('');
        const factorsHtml = (aiData.keyFactors || []).map(f => `<span class="super-ai-tag">${f}</span>`).join('');
        const top3Html = (aiData.adjustedTop3 || []).map((p,i) => 
          `<span class="super-ai-tag" style="background:rgba(0,229,160,0.08);border-color:rgba(0,229,160,0.3);color:#00e5a0;">${['&#x1F947;','&#x1F948;','&#x1F949;'][i]||'&#x2022;'} ${p}</span>`
        ).join('');
        
        // Confidence bar
        const conf = aiData.confidence || 0;
        const confWidth = Math.min(100, Math.max(0, conf));
        const confColor = conf >= 70 ? '#00e5a0' : conf >= 55 ? '#fbbf24' : '#f87171';
        
        aiSection = `
          <div class="super-ai-section">
            <div class="super-ai-header">
              <span class="super-ai-live">&#x1F916; ORACLE AI</span>
              <span style="font-weight:700;font-size:0.9rem;">Analisi Intelligente + News Live</span>
              <span style="margin-left:auto;font-size:0.75rem;color:${aiData.newsFound ? '#00e5a0' : '#fbbf24'};">
                ${aiData.newsFound ? '&#x1F4F0; News trovate' : '&#x26A0; Dati limitati'}
              </span>
            </div>
            
            ${newsHtml ? `<div style="margin-bottom:12px;">${newsHtml}</div>` : ''}
            
            ${aiData.teamsContext ? `<div style="font-size:0.8rem;color:rgba(148,163,184,0.75);margin-bottom:12px;padding:10px 12px;background:rgba(255,255,255,0.02);border-radius:10px;border-left:2px solid rgba(0,212,255,0.4);line-height:1.6;">&#x1F4CB; ${aiData.teamsContext}</div>` : ''}
            
            <div class="oracle-verdict-text">${aiData.aiVerdict || ''}</div>
            
            <!-- KPI boxes -->
            <div style="display:flex;flex-wrap:wrap;gap:8px;margin:12px 0;">
              <div class="oracle-verdict-box" style="border-color:${recColor};background:${recBg};">
                <div style="font-size:1.5rem;font-weight:900;color:${recColor};">${recIcon}</div>
                <div style="font-size:0.95rem;font-weight:800;color:${recColor};">${aiData.recommendation||'?'}</div>
                <div style="font-size:0.65rem;color:rgba(148,163,184,0.5);margin-top:2px;text-transform:uppercase;">Raccomandazione</div>
              </div>
              <div class="oracle-verdict-box">
                <div style="font-size:1.4rem;font-weight:900;color:#00d4ff;">${aiData.confidence||'?'}%</div>
                <div style="margin:4px 0;">
                  <div style="height:4px;background:rgba(255,255,255,0.08);border-radius:4px;overflow:hidden;">
                    <div style="width:${confWidth}%;height:100%;background:${confColor};border-radius:4px;transition:width 0.8s;"></div>
                  </div>
                </div>
                <div style="font-size:0.65rem;color:rgba(148,163,184,0.5);text-transform:uppercase;">Confidenza AI</div>
              </div>
              <div class="oracle-verdict-box">
                <div style="font-size:1rem;font-weight:800;color:${aiData.riskLevel==='basso'?'#00e5a0':aiData.riskLevel==='alto'?'#f87171':'#fbbf24'};">
                  ${aiData.riskLevel==='basso'?'&#x1F7E2;':aiData.riskLevel==='alto'?'&#x1F534;':'&#x1F7E1;'} ${(aiData.riskLevel||'?').toUpperCase()}
                </div>
                <div style="font-size:0.65rem;color:rgba(148,163,184,0.5);margin-top:4px;text-transform:uppercase;">Rischio</div>
              </div>
              <div class="oracle-verdict-box" style="border-color:rgba(0,229,160,0.3);background:rgba(0,229,160,0.05);flex:2;min-width:140px;">
                <div style="font-size:0.7rem;color:rgba(148,163,184,0.5);text-transform:uppercase;margin-bottom:4px;">Best Pick Oracle</div>
                <div style="font-size:1rem;font-weight:800;color:#00e5a0;">${aiData.bestPick||'?'}</div>
                <div style="font-size:0.85rem;font-weight:700;color:rgba(0,229,160,0.7);">${aiData.bestPickProb||'?'}%</div>
              </div>
              ${aiData.alternativePick ? `<div class="oracle-verdict-box" style="border-color:rgba(0,212,255,0.2);flex:1.5;min-width:110px;">
                <div style="font-size:0.65rem;color:rgba(148,163,184,0.5);text-transform:uppercase;margin-bottom:4px;">Alternativa Oracle</div>
                <div style="font-size:0.9rem;font-weight:700;color:#00d4ff;">${aiData.alternativePick}</div>
                <div style="font-size:0.8rem;color:rgba(0,212,255,0.6);">${aiData.alternativePickProb||'?'}%</div>
              </div>` : ''}
            </div>
            
            ${aiData.bestPickReasoning ? `<div style="margin:10px 0;padding:10px 12px;background:rgba(0,229,160,0.06);border:1px solid rgba(0,229,160,0.2);border-radius:10px;font-size:0.8rem;color:#a7f3d0;line-height:1.6;">&#x1F3AF; <strong>PerchÃ©:</strong> ${aiData.bestPickReasoning}</div>` : ''}
            ${aiData.warningFlags && aiData.warningFlags.filter(w=>w).length > 0 ? `<div style="margin:8px 0;padding:8px 12px;background:rgba(251,191,36,0.06);border:1px solid rgba(251,191,36,0.2);border-radius:10px;font-size:0.78rem;color:#fcd34d;line-height:1.6;">&#x26A0;&#xFE0F; <strong>Attenzione:</strong> ${aiData.warningFlags.filter(w=>w).join(' | ')}</div>` : ''}
            ${aiData.bookmakerOdds && aiData.bookmakerOdds !== 'null' ? `<div style="margin:8px 0;padding:8px 12px;background:rgba(0,212,255,0.05);border:1px solid rgba(0,212,255,0.15);border-radius:10px;font-size:0.78rem;color:#67e8f9;">&#x1F4B0; <strong>Quote bookmakers:</strong> ${aiData.bookmakerOdds}</div>` : ''}
            ${factorsHtml ? `
            <div style="margin-top:10px;">
              <div style="font-size:0.72rem;color:rgba(148,163,184,0.5);margin-bottom:6px;text-transform:uppercase;letter-spacing:0.5px;">&#x1F511; Fattori Chiave</div>
              <div style="display:flex;flex-wrap:wrap;gap:6px;">${factorsHtml}</div>
            </div>` : ''}
            
            ${top3Html ? `
            <div style="margin-top:10px;">
              <div style="font-size:0.72rem;color:rgba(148,163,184,0.5);margin-bottom:6px;text-transform:uppercase;letter-spacing:0.5px;">&#x1F3AF; Ranking Oracle Corretto</div>
              <div style="display:flex;flex-wrap:wrap;gap:6px;">${top3Html}</div>
            </div>` : ''}
            
            ${aiData.algoConfirmed !== undefined ? `
            <div style="margin-top:12px;padding:8px 12px;border-radius:8px;font-size:0.8rem;
              background:${aiData.algoConfirmed ? 'rgba(0,229,160,0.08)' : 'rgba(248,113,113,0.08)'};
              border:1px solid ${aiData.algoConfirmed ? 'rgba(0,229,160,0.25)' : 'rgba(248,113,113,0.25)'};
              color:${aiData.algoConfirmed ? '#00e5a0' : '#f87171'};">
              ${aiData.algoConfirmed 
                ? '&#x2705; Oracle AI <strong>conferma</strong> il ranking dell&#39;algoritmo statistico' 
                : '&#x26A0;&#xFE0F; Oracle AI <strong>suggerisce correzioni</strong> al ranking â€” vedi Ranking Oracle sopra'}
            </div>` : ''}
          </div>`;
      } else if (aiData && aiData.error) {
        aiSection = `
          <div class="super-ai-section">
            <div style="font-size:0.78rem;color:rgba(148,163,184,0.4);padding:10px;background:rgba(248,113,113,0.05);border-radius:8px;border:1px solid rgba(248,113,113,0.15);">
              &#x26A0;&#xFE0F; Analisi Oracle AI non disponibile: ${aiData.error}. I dati statistici locali restano validi.
            </div>
          </div>`;
      }
      
      return `
        <div class="super-algo-panel" id="superAlgoPanel">
          <!-- HEADER -->
          <div class="super-algo-header">
            <div class="super-algo-icon">&#x1F52E;</div>
            <div class="super-algo-title-group">
              <div class="super-algo-title">Oracle Super Algoritmo</div>
              <div class="super-algo-subtitle">Poisson + xG + Dixon-Coles + ML + AI News Live &#x2014; ${analysisDepth}</div>
            </div>
            <div class="super-algo-badge">v4.0</div>
          </div>
          
          <!-- PICKS RANKING -->
          <div style="font-size:0.72rem;color:rgba(148,163,184,0.5);margin-bottom:10px;text-transform:uppercase;letter-spacing:0.8px;">
            &#x1F3C6; Ranking Mercati per SuperScore
          </div>
          <div class="super-picks-grid">
            ${picks.map((pick, idx) => {
              const rank = idx + 1;
              const rankClass = rank === 1 ? 'rank-1' : rank === 2 ? 'rank-2' : rank === 3 ? 'rank-3' : 'rank-other';
              const probClass = pick.prob >= 70 ? 'prob-high' : pick.prob >= 54 ? 'prob-med' : 'prob-low';
              const signalDots = Array.from({length: pick.totalSignals}, (_, i) => 
                `<span class="super-signal ${i < pick.signalCount ? 'on' : 'off'}"></span>`
              ).join('');
              
              // AI boost badge
              let aiBoost = '';
              if (aiData && aiData.adjustedTop3) {
                const aiIdx = aiData.adjustedTop3.findIndex(p => {
                  const pv = (pick.value||'').toLowerCase();
                  const pp = p.toLowerCase();
                  return pv.includes(pp.split(' ')[0]) || pp.includes(pv.split(' ')[0]);
                });
                if (aiIdx === 0 && rank > 1) aiBoost = '<span style="font-size:0.58rem;color:#f59e0b;font-weight:800;"> &#x2605;AI</span>';
                else if (aiIdx > -1 && aiIdx < rank - 1) aiBoost = '<span style="font-size:0.58rem;color:#00e5a0;"> &#x2191;</span>';
              }
              
              return `
                <div class="super-pick-card ${rankClass}" 
                     onclick="addToSlip(state.selectedMatch, 'oracle_${pick.value.replace(/'/g,'').replace(/ /g,'_')}', '${pick.value.replace(/'/g,"\'")}', ${pick.prob.toFixed(0)})"
                     title="Clicca per aggiungere alla schedina">
                  <div class="super-pick-rank">#${rank}${aiBoost}</div>
                  <div class="super-pick-market">${pick.market}</div>
                  <div class="super-pick-value">${pick.value}</div>
                  <div class="super-pick-prob ${probClass}">${pick.prob.toFixed(1)}%</div>
                  <div class="super-pick-confidence ${pick.confidence}">${
                    pick.confidence === 'high' ? '&#x1F3AF; Alta' : 
                    pick.confidence === 'medium' ? '&#x2713; Media' : '&#x26A0; Bassa'
                  }</div>
                  <div class="super-signals-row">${signalDots}</div>
                </div>`;
            }).join('')}
          </div>
          
          <!-- SUMMARY BAR -->
          <div class="super-algo-summary">
            <div class="super-summary-item">
              <div class="super-summary-num">${picks[0].prob.toFixed(1)}%</div>
              <div class="super-summary-label">&#x1F3C6; Top Prob</div>
            </div>
            <div class="super-summary-item">
              <div class="super-summary-num">${(avgConvergence * 100).toFixed(0)}%</div>
              <div class="super-summary-label">&#x1F4A1; Convergenza</div>
            </div>
            <div class="super-summary-item">
              <div class="super-summary-num">${highConfCount}</div>
              <div class="super-summary-label">&#x1F525; Alta Conf.</div>
            </div>
            <div class="super-summary-item">
              <div class="super-summary-num">${picks.length}</div>
              <div class="super-summary-label">&#x1F4CA; Mercati</div>
            </div>
            <div style="flex:2;font-size:0.71rem;color:rgba(148,163,184,0.5);line-height:1.55;min-width:140px;">
              Puntini verdi = segnali che confermano il pick. Cliccabili per schedina.
              L&#39;AI Oracle cerca news live e corregge il ranking se necessario.
            </div>
          </div>
          
          <!-- AI ORACLE SECTION -->
          ${aiSection}
        </div>
      `;
    }
    function getProbClass(prob) {
      if (prob >= 65) return 'high';
      if (prob >= 50) return 'mid';
      return 'low';
    }

    // Funzione per generare il verdetto del trader
    function renderTraderVerdict(ai, stat, d) {
      const bestProb = Math.max(ai.prob, stat.prob);
      const bestPick = ai.prob >= stat.prob ? ai.pick : stat.pick;
      const bestMarket = ai.prob >= stat.prob ? 'AI' : 'Statistico';
      
      const HISTORICAL = {
        'Under': { rate: 100, note: 'Storico perfetto!' },
        'GG': { rate: 100, note: 'Mai sbagliato!' },
        '1': { rate: 91.7, note: 'Ottimo storico' },
        '1 Casa': { rate: 91.7, note: 'Ottimo storico' },
        '2': { rate: 88.9, note: 'Buon storico' },
        '2 Ospite': { rate: 88.9, note: 'Buon storico' },
        '1X': { rate: 88.9, note: 'Buon storico' },
        'X2': { rate: 88.9, note: 'Buon storico' },
        'X': { rate: 88.9, note: 'Equilibrato' },
        'Over 1.5': { rate: 80, note: 'Discreto' },
        'Over 2.5': { rate: 69, note: 'âš ï¸ Attenzione!' },
        'Over 3.5': { rate: 65, note: 'âš ï¸ Rischioso' }
      };
      
      let histMatch = null;
      for (const [key, val] of Object.entries(HISTORICAL)) {
        if (bestPick.includes(key) || bestPick === key) {
          histMatch = { market: key, ...val };
          break;
        }
      }
      if (!histMatch) histMatch = { market: bestPick, rate: 75, note: 'Dati limitati' };
      
      let verdict, verdictClass, verdictIcon;
      if (bestProb >= 80 && histMatch.rate >= 85) {
        verdict = 'âœ… GIOCABILE';
        verdictClass = 'play';
        verdictIcon = '&#x1F3AF;';
      } else if (bestProb >= 70 && histMatch.rate >= 70) {
        verdict = 'âš ï¸ CAUTELA';
        verdictClass = 'caution';
        verdictIcon = 'âš¡';
      } else {
        verdict = 'âŒ EVITARE';
        verdictClass = 'avoid';
        verdictIcon = '&#x1F6D1;';
      }
      
      let suggestion = '';
      if (bestProb >= 82) {
        suggestion = 'Ideale per <strong>RADDOPPIO</strong> con altra partita â‰¥82%';
      } else if (bestProb >= 70) {
        suggestion = 'Consigliata come <strong>SINGOLA</strong> (max 5% bankroll)';
      } else {
        suggestion = 'Non consigliata per betting. Solo per studio.';
      }
      
      const stars = Math.min(5, Math.floor(bestProb / 18));
      
      let warningHtml = '';
      if (histMatch.rate < 75) {
        warningHtml = '<div class="verdict-warning"><span class="verdict-warning-icon">âš ï¸</span><span class="verdict-warning-text"><strong>Attenzione:</strong> Questo mercato ha uno storico sotto il 75%. Evita di usarlo nei raddoppi.</span></div>';
      }
      
      return '<div class="trader-verdict">' +
        '<div class="verdict-header">' +
          '<div class="verdict-icon">' + verdictIcon + '</div>' +
          '<div class="verdict-title"><h3>Consiglio del Trader</h3><p>Analisi strategica basata su probabilitÃ  e storico</p></div>' +
          '<div class="verdict-badge ' + verdictClass + '">' + verdict + '</div>' +
        '</div>' +
        '<div class="verdict-content">' +
          '<div class="verdict-box">' +
            '<div class="verdict-box-title">&#x1F3AF; Pick Consigliato</div>' +
            '<div class="verdict-main-pick">' +
              '<div class="verdict-main-pick-label">Pronostico ' + bestMarket + '</div>' +
              '<div class="verdict-main-pick-value">' + bestPick + '</div>' +
              '<div class="verdict-main-pick-prob">' + bestProb.toFixed(0) + '%</div>' +
              '<div class="verdict-stars">' + 'â˜…'.repeat(stars) + 'â˜†'.repeat(5-stars) + '</div>' +
            '</div>' +
            '<div class="verdict-suggestion"><span class="verdict-suggestion-icon">&#x1F4A1;</span><span class="verdict-suggestion-text">' + suggestion + '</span></div>' +
          '</div>' +
          '<div class="verdict-box">' +
            '<div class="verdict-box-title">&#x1F4CA; Win Rate Storico</div>' +
            '<div class="verdict-suggestion"><span class="verdict-suggestion-icon">&#x1F4C8;</span><span class="verdict-suggestion-text">Mercato <strong>' + histMatch.market + '</strong>: <strong>' + histMatch.rate + '%</strong> win rate</span></div>' +
            '<div class="verdict-suggestion"><span class="verdict-suggestion-icon">&#x1F4DD;</span><span class="verdict-suggestion-text">' + histMatch.note + '</span></div>' +
            warningHtml +
          '</div>' +
        '</div>' +
      '</div>';
    }

    // === LIVE BETTING SYSTEM ===
    
    async function loadLiveMatches() {
      state.liveLoading = true;
      render();
      
      try {
        // Usa la stessa API giÃ  configurata
        const data = await callAPIFootball('/fixtures', { live: 'all' });
        
        if (data && data.response) {
          state.liveMatches = data.response.map(f => ({
            id: f.fixture.id,
            status: f.fixture.status.short,
            elapsed: f.fixture.status.elapsed || 0,
            league: {
              id: f.league.id,
              name: f.league.name,
              country: f.league.country,
              logo: f.league.logo
            },
            home: { id: f.teams.home.id, name: f.teams.home.name, logo: f.teams.home.logo },
            away: { id: f.teams.away.id, name: f.teams.away.name, logo: f.teams.away.logo },
            goals: { home: f.goals.home || 0, away: f.goals.away || 0 },
            stats: f.statistics || []
          }));
          
          // Calcola gli alert
          calculateLiveAlerts();
        }
      } catch (e) {
        console.error('Live load error:', e);
      }
      
      state.liveLoading = false;
      render();
    }
    
    function calculateLiveAlerts() {
      const alerts = [];
      
      // ============================================
      // === CONFIGURAZIONE CAMPIONATI AD ALTA MEDIA GOL ===
      // ============================================
      const HIGH_SCORING_LEAGUES = {
        // Top 5 Europei
        88: { name: 'Eredivisie', avgGoals: 3.2, boost: 12 },
        78: { name: 'Bundesliga', avgGoals: 3.1, boost: 10 },
        144: { name: 'Jupiler Pro', avgGoals: 3.0, boost: 10 },
        218: { name: 'Bundesliga Austria', avgGoals: 3.0, boost: 10 },
        179: { name: 'Premiership Scozia', avgGoals: 2.9, boost: 8 },
        // Serie A e altri
        135: { name: 'Serie A', avgGoals: 2.8, boost: 6 },
        39: { name: 'Premier League', avgGoals: 2.8, boost: 6 },
        140: { name: 'La Liga', avgGoals: 2.6, boost: 4 },
        61: { name: 'Ligue 1', avgGoals: 2.7, boost: 5 },
        // Leghe minori ad alto punteggio
        203: { name: 'Super Lig Turchia', avgGoals: 2.9, boost: 8 },
        94: { name: 'Primeira Liga Portogallo', avgGoals: 2.7, boost: 5 },
        // Sudamerica (tanti gol)
        71: { name: 'Serie A Brasile', avgGoals: 2.6, boost: 5 },
        128: { name: 'Liga Argentina', avgGoals: 2.5, boost: 4 }
      };
      
      // ============================================
      // === MOMENTI CALDI (statisticamente piÃ¹ gol) ===
      // ============================================
      const getHotMomentBoost = (elapsed, isFirstHalf) => {
        if (isFirstHalf) {
          if (elapsed >= 43 && elapsed <= 45) return 15; // Fine 1T - squadre spingono
          if (elapsed >= 40 && elapsed <= 42) return 8;  // Pre-fine 1T
          if (elapsed >= 35 && elapsed <= 39) return 5;  // Fase calda 1T
        } else {
          if (elapsed >= 85) return 18;                  // Ultimi minuti - disperazione
          if (elapsed >= 80 && elapsed <= 84) return 14; // Forcing finale
          if (elapsed >= 75 && elapsed <= 79) return 10; // Ultimi 15 min
          if (elapsed >= 55 && elapsed <= 60) return 8;  // Inizio 2T - cambi tattici
        }
        return 0;
      };
      
      // ============================================
      // === FATTORE SVANTAGGIO (squadra sotto attacca) ===
      // ============================================
      const getDisadvantageBoost = (homeGoals, awayGoals, elapsed) => {
        const diff = Math.abs(homeGoals - awayGoals);
        if (diff === 0) return 0; // Pareggio
        
        // Squadra sotto di 1 gol
        if (diff === 1) {
          if (elapsed >= 75) return 18; // Ultimi 15 min, spinta massima
          if (elapsed >= 65) return 12;
          if (elapsed >= 55) return 8;
          return 4;
        }
        
        // Squadra sotto di 2 gol
        if (diff === 2) {
          if (elapsed >= 70) return 10; // Ancora possibile rimonta
          if (elapsed >= 60) return 5;
          return 0; // Troppo presto o partita chiusa
        }
        
        return 0; // 3+ gol di differenza = partita chiusa
      };
      
      // ============================================
      // === ANALISI PARTITE ===
      // ============================================
      
      state.liveMatches.forEach(match => {
        const elapsed = match.elapsed || 0;
        const homeGoals = match.goals?.home || 0;
        const awayGoals = match.goals?.away || 0;
        const totalGoals = homeGoals + awayGoals;
        const isFirstHalf = match.status === '1H';
        const isSecondHalf = match.status === '2H';
        const isHalfTime = match.status === 'HT';
        
        // Estrai ID campionato
        const leagueId = match.league?.id || 0;
        const leagueInfo = HIGH_SCORING_LEAGUES[leagueId];
        const leagueBoost = leagueInfo ? leagueInfo.boost : 0;
        
        // Calcola boost dinamici
        const hotMomentBoost = getHotMomentBoost(elapsed, isFirstHalf);
        const disadvantageBoost = getDisadvantageBoost(homeGoals, awayGoals, elapsed);
        
        // Estrai statistiche
        let stats = { 
          shotsHome: 0, shotsAway: 0, shots: 0,
          shotsOnHome: 0, shotsOnAway: 0, shotsOn: 0,
          cornersHome: 0, cornersAway: 0, corners: 0,
          possessionHome: 50, possessionAway: 50,
          hasStats: false
        };
        
        if (match.stats && match.stats.length >= 2) {
          const homeStats = match.stats[0]?.statistics || [];
          const awayStats = match.stats[1]?.statistics || [];
          
          const getStat = (arr, type) => {
            const s = arr.find(s => s.type === type);
            return s ? (parseInt(s.value) || 0) : 0;
          };
          
          stats.shotsHome = getStat(homeStats, 'Total Shots');
          stats.shotsAway = getStat(awayStats, 'Total Shots');
          stats.shotsOnHome = getStat(homeStats, 'Shots on Goal');
          stats.shotsOnAway = getStat(awayStats, 'Shots on Goal');
          stats.cornersHome = getStat(homeStats, 'Corner Kicks');
          stats.cornersAway = getStat(awayStats, 'Corner Kicks');
          stats.possessionHome = getStat(homeStats, 'Ball Possession') || 50;
          stats.possessionAway = getStat(awayStats, 'Ball Possession') || 50;
          
          stats.shots = stats.shotsHome + stats.shotsAway;
          stats.shotsOn = stats.shotsOnHome + stats.shotsOnAway;
          stats.corners = stats.cornersHome + stats.cornersAway;
          stats.hasStats = (stats.shots >= 1) || (stats.corners >= 1);
        }
        
        // === CALCOLO PRESSIONE OFFENSIVA ===
        // PiÃ¹ alto = piÃ¹ probabilitÃ  di gol
        const pressure = stats.hasStats 
          ? (stats.shotsOn * 3) + (stats.shots * 1) + (stats.corners * 1.5)
          : 0;
        const pressureBoost = Math.min(20, pressure * 0.8);
        
        // ============================================
        // === &#x1F525; ALERT SECONDO TEMPO &#x1F525; ===
        // ============================================
        
        // &#x1F3AF; OVER 0.5 - Partita 0-0 (dal 50')
        if (isSecondHalf && totalGoals === 0 && elapsed >= 50) {
          let prob = 45;
          
          // Base: tempo trascorso
          prob += (elapsed - 45) * 0.8;
          
          // Boost dinamici
          prob += hotMomentBoost;
          prob += leagueBoost;
          prob += pressureBoost;
          
          // 0-0 tardi = alta pressione
          if (elapsed >= 70) prob += 12;
          if (elapsed >= 80) prob += 10;
          
          prob = Math.min(94, prob);
          
          if (prob >= 58) {
            const leagueTag = leagueInfo ? ` [${leagueInfo.name}]` : '';
            alerts.push({
              match, type: 'over05',
              level: prob >= 78 ? 'high' : prob >= 65 ? 'medium' : 'low',
              pick: 'âš½ Over 0.5',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `0-0 al ${elapsed}'${leagueTag}${stats.hasStats ? ` | ${stats.shotsOn} tiri in porta` : ''}`,
              stats, leagueBoost, hotMomentBoost
            });
          }
        }
        
        // &#x1F3AF; OVER 1.5 - Partita con 0-1 gol (dal 50')
        if (isSecondHalf && totalGoals <= 1 && elapsed >= 50 && elapsed <= 85) {
          let prob = 35;
          
          prob += (elapsed - 45) * 0.6;
          prob += hotMomentBoost;
          prob += leagueBoost;
          prob += disadvantageBoost;
          prob += pressureBoost * 0.8;
          
          if (totalGoals === 1) prob += 15;
          if (elapsed >= 65) prob += 6;
          if (elapsed >= 75) prob += 6;
          
          // 1-1 apertissima
          if (homeGoals === 1 && awayGoals === 0 && elapsed >= 70) prob += 8;
          if (homeGoals === 0 && awayGoals === 1 && elapsed >= 70) prob += 8;
          
          prob = Math.min(88, prob);
          
          if (prob >= 52) {
            alerts.push({
              match, type: 'over15',
              level: prob >= 72 ? 'high' : prob >= 60 ? 'medium' : 'low',
              pick: 'âš½âš½ Over 1.5',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `${homeGoals}-${awayGoals} al ${elapsed}'${disadvantageBoost > 0 ? ' | Squadra sotto spinge!' : ''}`,
              stats, leagueBoost, hotMomentBoost, disadvantageBoost
            });
          }
        }
        
        // &#x1F3AF; OVER 2.5 - Partita con gol (dal 48')
        if (isSecondHalf && totalGoals >= 1 && totalGoals <= 2 && elapsed >= 48 && elapsed <= 83) {
          let prob = 30;
          
          prob += totalGoals * 10;
          prob += hotMomentBoost;
          prob += leagueBoost;
          prob += disadvantageBoost;
          prob += pressureBoost * 0.7;
          
          // Situazioni specifiche
          if (homeGoals === 1 && awayGoals === 1) prob += 18; // 1-1 = APERTA
          if (homeGoals === 2 && awayGoals === 0) prob += 10; // 2-0 = ospite spingerÃ 
          if (homeGoals === 0 && awayGoals === 2) prob += 10; // 0-2 = casa spingerÃ 
          if (homeGoals === 2 && awayGoals === 1) prob += 12; // 2-1 vivace
          if (homeGoals === 1 && awayGoals === 2) prob += 12; // 1-2 vivace
          
          if (elapsed >= 60) prob += 5;
          if (elapsed >= 70) prob += 5;
          
          prob = Math.min(85, prob);
          
          if (prob >= 50) {
            const situation = (homeGoals === 1 && awayGoals === 1) ? '&#x1F525; Partita APERTA!' : 
                             (Math.abs(homeGoals - awayGoals) >= 1) ? 'âš¡ Squadra sotto attacca!' : '';
            alerts.push({
              match, type: 'over25',
              level: prob >= 70 ? 'high' : prob >= 58 ? 'medium' : 'low',
              pick: 'âš½âš½âš½ Over 2.5',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `${homeGoals}-${awayGoals} al ${elapsed}' ${situation}`,
              stats, leagueBoost, hotMomentBoost, disadvantageBoost
            });
          }
        }
        
        // &#x1F3AF; OVER 3.5 - Partita ricca di gol (dal 50')
        if (isSecondHalf && totalGoals >= 2 && totalGoals <= 3 && elapsed >= 50 && elapsed <= 82) {
          let prob = 28;
          
          prob += totalGoals * 10;
          prob += hotMomentBoost;
          prob += leagueBoost;
          prob += pressureBoost * 0.6;
          
          if ((homeGoals === 2 && awayGoals === 1) || (homeGoals === 1 && awayGoals === 2)) prob += 15;
          if (homeGoals === 2 && awayGoals === 2) prob += 12;
          if (totalGoals === 3 && elapsed >= 60) prob += 8;
          
          prob = Math.min(80, prob);
          
          if (prob >= 50) {
            alerts.push({
              match, type: 'over35',
              level: prob >= 68 ? 'high' : prob >= 55 ? 'medium' : 'low',
              pick: 'âš½âš½âš½âš½ Over 3.5',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `&#x1F525; GiÃ  ${totalGoals} gol! ${homeGoals}-${awayGoals} al ${elapsed}'`,
              stats, leagueBoost, hotMomentBoost
            });
          }
        }
        
        // &#x1F3AF; GOL 2Â° TEMPO (all'intervallo)
        if (isHalfTime) {
          let prob = 52;
          
          prob += leagueBoost;
          prob += pressureBoost;
          
          if (totalGoals === 0) prob += 18; // 0-0 = pressione massima
          if (totalGoals === 1) prob += 12;
          if (stats.hasStats && stats.shotsOn >= 3) prob += 10;
          if (stats.hasStats && stats.shotsOn >= 5) prob += 8;
          if (stats.hasStats && stats.corners >= 5) prob += 5;
          
          prob = Math.min(90, prob);
          
          if (prob >= 58) {
            alerts.push({
              match, type: 'goal2T',
              level: prob >= 78 ? 'high' : prob >= 65 ? 'medium' : 'low',
              pick: totalGoals === 0 ? 'âš½ Gol 2Â°T' : 'âš½ Altro Gol',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `${homeGoals}-${awayGoals} HT${stats.hasStats ? ` | ${stats.shotsOn} tiri, ${stats.corners} corner` : ''}`,
              stats, leagueBoost
            });
          }
        }
        
        // ============================================
        // === &#x1F525; ALERT PRIMO TEMPO &#x1F525; ===
        // ============================================
        
        // &#x1F3AF; OVER 0.5 1Â°T (dal 25')
        if (isFirstHalf && totalGoals === 0 && elapsed >= 25 && elapsed <= 45) {
          let prob = 38;
          
          prob += (elapsed - 20) * 1.5;
          prob += hotMomentBoost;
          prob += leagueBoost;
          prob += pressureBoost;
          
          // Fine primo tempo = boost extra
          if (elapsed >= 40) prob += 8;
          if (elapsed >= 43) prob += 10;
          
          prob = Math.min(88, prob);
          
          if (prob >= 55) {
            alerts.push({
              match, type: 'over05_1T',
              level: prob >= 72 ? 'high' : prob >= 60 ? 'medium' : 'low',
              pick: 'âš½ Over 0.5 1Â°T',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `0-0 al ${elapsed}'${elapsed >= 40 ? ' â° Fine 1T vicina!' : ''}${stats.hasStats ? ` | ${stats.shotsOn} tiri` : ''}`,
              stats, leagueBoost, hotMomentBoost
            });
          }
        }
        
        // &#x1F3AF; OVER 1.5 1Â°T - Se giÃ  1 gol (dal 20')
        if (isFirstHalf && totalGoals === 1 && elapsed >= 20 && elapsed <= 45) {
          let prob = 35;
          
          prob += (elapsed - 15) * 1.2;
          prob += hotMomentBoost;
          prob += leagueBoost;
          prob += pressureBoost * 0.8;
          prob += disadvantageBoost;
          
          if (elapsed >= 35) prob += 8;
          if (elapsed >= 42) prob += 10;
          
          prob = Math.min(82, prob);
          
          if (prob >= 50) {
            alerts.push({
              match, type: 'over15_1T',
              level: prob >= 68 ? 'high' : prob >= 55 ? 'medium' : 'low',
              pick: 'âš½âš½ Over 1.5 1Â°T',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `${homeGoals}-${awayGoals} al ${elapsed}'${elapsed >= 40 ? ' â° Fine 1T!' : ''}`,
              stats, leagueBoost, hotMomentBoost, disadvantageBoost
            });
          }
        }
        
        // ============================================
        // === &#x1F3E0;âœˆï¸ SQUADRA SEGNA (con stats) ===
        // ============================================
        
        if (stats.hasStats && elapsed >= 20) {
          // &#x1F3E0; Casa domina
          if (stats.shotsOnHome >= 3 && stats.shotsOnHome > stats.shotsOnAway * 1.5 && homeGoals === 0) {
            let prob = 45;
            prob += stats.shotsOnHome * 5;
            prob += leagueBoost;
            prob += hotMomentBoost;
            if (elapsed >= 50) prob += 10;
            if (elapsed >= 70) prob += 10;
            if (stats.cornersHome >= 4) prob += 5;
            prob = Math.min(88, prob);
            
            if (prob >= 58) {
              alerts.push({
                match, type: 'homeScores',
                level: prob >= 75 ? 'high' : prob >= 62 ? 'medium' : 'low',
                pick: `&#x1F3E0; ${match.home.name.substring(0,12)} Segna`,
                prob: prob.toFixed(0),
                quota: (100 / prob).toFixed(2),
                reason: `Dominio: ${stats.shotsOnHome} tiri in porta vs ${stats.shotsOnAway}`,
                stats, leagueBoost, hotMomentBoost
              });
            }
          }
          
          // âœˆï¸ Ospite domina
          if (stats.shotsOnAway >= 3 && stats.shotsOnAway > stats.shotsOnHome * 1.5 && awayGoals === 0) {
            let prob = 42;
            prob += stats.shotsOnAway * 5;
            prob += leagueBoost;
            prob += hotMomentBoost;
            if (elapsed >= 50) prob += 10;
            if (elapsed >= 70) prob += 10;
            if (stats.cornersAway >= 4) prob += 5;
            prob = Math.min(85, prob);
            
            if (prob >= 55) {
              alerts.push({
                match, type: 'awayScores',
                level: prob >= 72 ? 'high' : prob >= 60 ? 'medium' : 'low',
                pick: `âœˆï¸ ${match.away.name.substring(0,12)} Segna`,
                prob: prob.toFixed(0),
                quota: (100 / prob).toFixed(2),
                reason: `Dominio: ${stats.shotsOnAway} tiri in porta vs ${stats.shotsOnHome}`,
                stats, leagueBoost, hotMomentBoost
              });
            }
          }
        }
      });
      
      // ============================================
      // === ORDINAMENTO E FILTRO FINALE ===
      // ============================================
      
      // Ordina: HIGH prima, poi per probabilitÃ 
      alerts.sort((a, b) => {
        const levelOrder = { high: 0, medium: 1, low: 2 };
        if (levelOrder[a.level] !== levelOrder[b.level]) {
          return levelOrder[a.level] - levelOrder[b.level];
        }
        return parseFloat(b.prob) - parseFloat(a.prob);
      });
      
      // Max 2 alert per partita (i migliori)
      const alertsFiltered = [];
      const matchAlertCount = {};
      alerts.forEach(alert => {
        const matchId = alert.match.id;
        matchAlertCount[matchId] = (matchAlertCount[matchId] || 0);
        if (matchAlertCount[matchId] < 2) {
          alertsFiltered.push(alert);
          matchAlertCount[matchId]++;
        }
      });
      
      state.liveAlerts = alertsFiltered;
    }
    
    // === LIVE BACKGROUND MONITORING ===
    function startLiveBackgroundMonitoring() {
      // Carica subito i dati LIVE
      loadLiveMatchesBackground();
      
      // Poi ogni 90 secondi in background
      state.liveBackgroundInterval = setInterval(() => {
        loadLiveMatchesBackground();
      }, 90000); // 90 secondi in background
    }
    
    async function loadLiveMatchesBackground() {
      try {
        const data = await callAPIFootball('/fixtures', { live: 'all' });
        
        if (data && data.response) {
          state.liveMatches = data.response.map(f => ({
            id: f.fixture.id,
            status: f.fixture.status.short,
            elapsed: f.fixture.status.elapsed || 0,
            league: {
              id: f.league.id,
              name: f.league.name,
              country: f.league.country,
              logo: f.league.logo
            },
            home: { id: f.teams.home.id, name: f.teams.home.name, logo: f.teams.home.logo },
            away: { id: f.teams.away.id, name: f.teams.away.name, logo: f.teams.away.logo },
            goals: { home: f.goals.home || 0, away: f.goals.away || 0 },
            stats: f.statistics || []
          }));
          
          // Calcola gli alert
          calculateLiveAlerts();
          
          // Aggiorna solo il badge senza re-renderizzare tutto
          updateLiveBadge();
        }
      } catch (e) {
        console.warn('Live background load error:', e);
      }
    }
    
    function updateLiveBadge() {
      const badge = document.querySelector('#liveTab');
      if (badge) {
        const alertCount = state.liveAlerts.length;
        const dot = '<span class="live-dot"></span>';
        const countBadge = alertCount > 0 ? `<span class="live-badge-count">${alertCount}</span>` : '';
        badge.innerHTML = `${dot} LIVE ${countBadge}`;
      }
    }
    
    function startLiveAutoRefresh() {
      if (state.liveInterval) return;
      
      // Countdown visivo
      state.liveCountdown = 60;
      state.countdownInterval = setInterval(() => {
        state.liveCountdown--;
        const countdownEl = document.querySelector('.live-countdown');
        if (countdownEl) {
          countdownEl.textContent = state.liveCountdown + 's';
        }
        if (state.liveCountdown <= 0) {
          state.liveCountdown = 60;
        }
      }, 1000);
      
      // Refresh dati ogni 60 secondi quando nella sezione LIVE
      state.liveInterval = setInterval(() => {
        if (state.liveMode) {
          loadLiveMatches();
          state.liveCountdown = 60;
        }
      }, 60000);
    }
    
    function stopLiveAutoRefresh() {
      if (state.liveInterval) {
        clearInterval(state.liveInterval);
        state.liveInterval = null;
      }
      if (state.countdownInterval) {
        clearInterval(state.countdownInterval);
        state.countdownInterval = null;
      }
    }
    
    function toggleConsigliMode() {
      state.consigliMode = !state.consigliMode;
      state.liveMode = false; // Disattiva live mode
      render();
    }
    
    function toggleLiveMode() {
      state.liveMode = !state.liveMode;
      if (state.liveMode) {
        loadLiveMatches();
        startLiveAutoRefresh();
      } else {
        stopLiveAutoRefresh();
      }
      render();
    }
    
    // === TRACKING PRONOSTICI ===
    
    function trackBet(type, matchId, matchName, pick, prob, odds, isLive = false) {
      // Normalizza il pick per evitare duplicati con formati diversi
      const normalizedPick = pick.trim();
      
      // Evita duplicati - controllo piÃ¹ robusto
      const isDuplicate = state.trackedBets.some(b => {
        if (b.matchId !== matchId) return false;
        const existingPick = b.pick.trim().toLowerCase();
        const newPick = normalizedPick.toLowerCase();
        
        // Match esatto
        if (existingPick === newPick) return true;
        
        // Evita che 1X sia considerato duplicato di X o 1
        // Ma se esiste giÃ  1X, non aggiungere 1X di nuovo
        return false;
      });
      
      if (isDuplicate) {
        console.log('Pronostico giÃ  tracciato:', normalizedPick);
        return null;
      }
      
      const bet = {
        id: Date.now(),
        type, // 'prematch' o 'live'
        matchId,
        matchName,
        pick: normalizedPick, // Usa il pick normalizzato
        prob: parseFloat(prob),
        odds: parseFloat(odds) || 0,
        isLive,
        timestamp: new Date().toISOString(),
        status: 'pending', // pending, won, lost
        result: null
      };
      
      state.trackedBets.push(bet);
      saveTrackedBets();
      
      console.log('âœ… Pronostico tracciato:', normalizedPick, 'per match:', matchId);
      
      render();
      return bet;
    }
    
    // Funzione per tracciare pronostici pre-match
    function trackPrematchBet(matchId, matchName, pick, prob, event) {
      if (event) event.stopPropagation();
      
      // Stima quota basata sulla probabilitÃ 
      const odds = (100 / prob).toFixed(2);
      
      const bet = trackBet('prematch', matchId, matchName, pick, prob, odds, false);
      if (bet) {
        alert(`âœ… Pronostico tracciato!\n\n${matchName}\n${pick} @ ${odds}\n\nVerrÃ  verificato automaticamente a fine partita.`);
      } else {
        alert('âš ï¸ Questo pronostico Ã¨ giÃ  stato tracciato.');
      }
    }
    
    // Funzione per tracciare pronostici LIVE
    function trackLiveBet(matchId, matchName, pick, prob, odds, event) {
      if (event) event.stopPropagation();
      const bet = trackBet('live', matchId, matchName, pick, prob, odds, true);
      if (bet) {
        alert(`âœ… Pronostico LIVE tracciato!\n\n${matchName}\n${pick} @ ${odds}\n\nVerrÃ  verificato automaticamente a fine partita.`);
      } else {
        alert('âš ï¸ Questo pronostico LIVE Ã¨ giÃ  stato tracciato.');
      }
    }
    
    // Funzione per tracciare pronostici dalla HOME (Consiglio AI cards)
    function trackFromHome(matchId, matchName, pick, prob, event) {
      if (event) event.stopPropagation();
      const odds = (100 / prob).toFixed(2);
      const bet = trackBet('prematch', matchId, matchName, pick, prob, odds, false);
      if (bet) {
        render();
      } else {
        alert('âš ï¸ Questo pronostico Ã¨ giÃ  nella tua schedina.');
      }
    }
    
    function updateBetResult(betId, status, result) {
      const bet = state.trackedBets.find(b => b.id === betId);
      if (bet) {
        bet.status = status;
        bet.result = result;
        saveTrackedBets();
      }
    }
    
    function saveTrackedBets() {
      // Salva su localStorage (locale)
      localStorage.setItem('bp2_tracked', JSON.stringify(state.trackedBets));
      
      // Salva su Firebase (cloud) - async, non bloccante
      saveToFirebase('trackedBets', state.trackedBets).catch(e => 
        console.warn('Firebase save trackedBets failed:', e)
      );
    }
    
    async function loadTrackingFromLocalStorage() {
      // Prova prima Firebase (cloud), poi localStorage (locale)
      try {
        // 1. Carica da Firebase se disponibile
        const firebaseData = await loadFromFirebase('trackedBets');
        if (firebaseData && Array.isArray(firebaseData)) {
          state.trackedBets = firebaseData;
          console.log(`&#x1F4CA; Caricati ${firebaseData.length} pronostici da Firebase`);
          return;
        }
        
        // 2. Fallback su localStorage
        const saved = localStorage.getItem('bp2_tracked');
        if (saved) {
          state.trackedBets = JSON.parse(saved);
          console.log(`&#x1F4CA; Caricati ${state.trackedBets.length} pronostici da localStorage`);
          
          // Sincronizza con Firebase se disponibile
          if (firebaseEnabled && state.trackedBets.length > 0) {
            saveToFirebase('trackedBets', state.trackedBets).catch(e => 
              console.warn('Firebase sync failed:', e)
            );
          }
        }
      } catch (e) {
        console.warn('Tracking load error:', e);
      }
    }
    
    async function loadMLThresholdsFromCloud() {
      try {
        const firebaseData = await loadFromFirebase('mlThresholds');
        if (firebaseData && typeof firebaseData === 'object') {
          state.mlThresholds = firebaseData;
          console.log('&#x1F916; ML Thresholds caricati da Firebase');
          return;
        }
        
        // Fallback giÃ  fatto in state init con localStorage
        console.log('&#x1F916; ML Thresholds da localStorage (Firebase non disponibile)');
      } catch (e) {
        console.warn('ML Thresholds load error:', e);
      }
    }
    
    async function loadPerformanceHistoryFromCloud() {
      try {
        const firebaseData = await loadFromFirebase('performanceHistory');
        if (firebaseData && Array.isArray(firebaseData)) {
          state.performanceHistory = firebaseData;
          console.log(`&#x1F4C8; Performance History caricato da Firebase (${firebaseData.length} records)`);
          return;
        }
        
        // Fallback giÃ  fatto in state init con localStorage
        console.log('&#x1F4C8; Performance History da localStorage (Firebase non disponibile)');
      } catch (e) {
        console.warn('Performance History load error:', e);
      }
    }
    
    // Carica ML Stats da Firebase
    async function loadMLStatsFromCloud() {
      try {
        const firebaseData = await loadFromFirebase('mlStats');
        if (firebaseData && typeof firebaseData === 'object') {
          state.mlStats = firebaseData;
          localStorage.setItem('bp2_ml_stats', JSON.stringify(firebaseData));
          console.log('&#x1F916; ML Stats caricate da Firebase:', Object.keys(firebaseData).length, 'categorie');
          return;
        }
        
        // Fallback su localStorage
        const saved = localStorage.getItem('bp2_ml_stats');
        if (saved) {
          state.mlStats = JSON.parse(saved);
          console.log('&#x1F916; ML Stats da localStorage');
        }
      } catch (e) {
        console.warn('ML Stats load error:', e);
      }
    }
    
    async function checkPendingResults() {
      const pending = state.trackedBets.filter(b => b.status === 'pending');
      let updated = false;
      
      for (const bet of pending) {
        try {
          const data = await callAPIFootball('/fixtures', { id: bet.matchId });
          if (data && data.response && data.response[0]) {
            const fixture = data.response[0];
            const status = fixture.fixture.status.short;
            
            // Solo se la partita Ã¨ finita
            if (['FT', 'AET', 'PEN'].includes(status)) {
              const homeGoals = fixture.goals.home;
              const awayGoals = fixture.goals.away;
              const totalGoals = homeGoals + awayGoals;
              const result = `${homeGoals}-${awayGoals}`;
              
              // Verifica se ha vinto
              let won = false;
              const pick = bet.pick.toLowerCase().trim();
              
              // Over/Under - ordine specifico per evitare conflitti
              if (pick.includes('over 3.5') && totalGoals >= 4) won = true;
              else if (pick.includes('over 2.5') && totalGoals >= 3) won = true;
              else if (pick.includes('over 1.5') && totalGoals >= 2) won = true;
              else if (pick.includes('over 0.5') && totalGoals >= 1) won = true;
              else if (pick.includes('under 1.5') && totalGoals < 2) won = true;
              else if (pick.includes('under 2.5') && totalGoals < 3) won = true;
              else if (pick.includes('under 3.5') && totalGoals < 4) won = true;
              // GG/NG
              else if ((pick === 'gg' || pick.includes('entrambe segnano') || pick === 'goal') && homeGoals > 0 && awayGoals > 0) won = true;
              else if ((pick === 'ng' || pick.includes('no gol')) && (homeGoals === 0 || awayGoals === 0)) won = true;
              // DOPPIE CHANCE - IMPORTANTE: verificare PRIMA di 1X2 singoli
              else if ((pick === '1x' || pick.startsWith('1x ') || pick.startsWith('1x(')) && homeGoals >= awayGoals) won = true;
              else if ((pick === 'x2' || pick.startsWith('x2 ') || pick.startsWith('x2(')) && homeGoals <= awayGoals) won = true;
              else if ((pick === '12' || pick.startsWith('12 ') || pick.startsWith('12(')) && homeGoals !== awayGoals) won = true;
              // 1X2 SINGOLI - verificare dopo le doppie chance
              else if ((pick === '1' || pick === '1 (vittoria casa)' || (pick.startsWith('1 ') && !pick.startsWith('1x'))) && homeGoals > awayGoals) won = true;
              else if ((pick === 'x' || pick === 'pareggio' || pick === 'x (pareggio)') && homeGoals === awayGoals) won = true;
              else if ((pick === '2' || pick === '2 (vittoria ospite)' || (pick.startsWith('2 ') && !pick.startsWith('2x'))) && homeGoals < awayGoals) won = true;
              // Multigol
              else if (pick.includes('multigol 1-3') && totalGoals >= 1 && totalGoals <= 3) won = true;
              else if (pick.includes('multigol 2-4') && totalGoals >= 2 && totalGoals <= 4) won = true;
              else if (pick.includes('multigol 2-5') && totalGoals >= 2 && totalGoals <= 5) won = true;
              // Segna
              else if (pick.includes('segna') && totalGoals > 0) won = true;
              else if (pick.includes('gol 2Â°') && totalGoals > 0) won = true;
              
              updateBetResult(bet.id, won ? 'won' : 'lost', result);
              updated = true;
              console.log(`&#x1F4CA; Risultato verificato: ${bet.matchName} - ${pick} = ${won ? 'VINTO' : 'PERSO'} (${result})`);
            }
          }
        } catch (e) {
          console.warn('Check result error:', e);
        }
      }
      
      if (updated) {
        // Aggiorna ML con i nuovi risultati
        updateMLFromResults();
        render();
      }
    }
    
    // === MACHINE LEARNING - Aggiorna soglie in base ai risultati ===
    function updateMLFromResults() {
      const completedBets = state.trackedBets.filter(b => b.status !== 'pending');
      if (completedBets.length < 5) return; // Serve un minimo di dati
      
      // Calcola win rate per ogni tipo di pick
      const pickStats = {};
      
      // Categorie di pick da analizzare
      const categories = [
        { patterns: ['over 2.5'], key: 'over25' },
        { patterns: ['over 1.5'], key: 'over15' },
        { patterns: ['gg', 'entrambe segnano', 'goal'], key: 'gg' },
        { patterns: ['ng', 'no gol'], key: 'ng' },
        { patterns: ['1x'], key: '1x' },
        { patterns: ['x2'], key: 'x2' },
        { patterns: ['under 2.5'], key: 'under25' }
      ];
      
      categories.forEach(cat => {
        const bets = completedBets.filter(b => {
          const pick = b.pick.toLowerCase();
          return cat.patterns.some(p => pick.includes(p) || pick === p);
        });
        
        if (bets.length >= 3) {
          const won = bets.filter(b => b.status === 'won').length;
          const total = bets.length;
          const winRate = (won / total) * 100;
          
          pickStats[cat.key] = {
            total,
            won,
            winRate: winRate.toFixed(1),
            // Suggerimento soglia basato su win rate
            suggestedThreshold: Math.max(50, Math.min(85, 100 - winRate + 10))
          };
        }
      });
      
      // Salva statistiche ML
      state.mlStats = pickStats;
      
      // Salva su localStorage
      localStorage.setItem('bp2_ml_stats', JSON.stringify(pickStats));
      
      // Salva su Firebase
      saveToFirebase('mlStats', pickStats).catch(e => 
        console.warn('Firebase save mlStats failed:', e)
      );
      
      // Aggiorna anche i threshold ML in base ai risultati
      updateMLThresholdsFromStats(pickStats);
      
      console.log('&#x1F916; ML Stats aggiornate:', pickStats);
    }
    
    // Aggiorna i threshold ML in base alle statistiche
    function updateMLThresholdsFromStats(pickStats) {
      const mapping = {
        'over25': 'Over 2.5',
        'over15': 'Over 1.5',
        'gg': 'GG',
        '1x': '1X',
        'x2': 'X2',
        'under25': 'Under 2.5'
      };
      
      Object.entries(pickStats).forEach(([key, stats]) => {
        const thresholdKey = mapping[key];
        if (thresholdKey && state.mlThresholds[thresholdKey]) {
          // Aggiorna accuracy e predizioni
          state.mlThresholds[thresholdKey].accuracy = parseFloat(stats.winRate);
          state.mlThresholds[thresholdKey].totalPredictions = stats.total;
          state.mlThresholds[thresholdKey].correctPredictions = stats.won;
          
          // Suggerisci nuova soglia se win rate Ã¨ buono
          if (stats.total >= 10 && parseFloat(stats.winRate) >= 55) {
            // Abbassa leggermente la soglia se sta andando bene
            const currentThreshold = state.mlThresholds[thresholdKey].threshold;
            state.mlThresholds[thresholdKey].threshold = Math.max(45, currentThreshold - 2);
          } else if (stats.total >= 10 && parseFloat(stats.winRate) < 45) {
            // Alza la soglia se sta andando male
            const currentThreshold = state.mlThresholds[thresholdKey].threshold;
            state.mlThresholds[thresholdKey].threshold = Math.min(75, currentThreshold + 3);
          }
        }
      });
      
      // Salva i threshold aggiornati
      localStorage.setItem('bp2_ml_thresholds', JSON.stringify(state.mlThresholds));
      saveToFirebase('mlThresholds', state.mlThresholds).catch(e => 
        console.warn('Firebase save mlThresholds failed:', e)
      );
      
      console.log('&#x1F916; ML Thresholds aggiornati');
    }
    
    function getTrackingStats() {
      const stats = {
        total: state.trackedBets.length,
        pending: state.trackedBets.filter(b => b.status === 'pending').length,
        won: state.trackedBets.filter(b => b.status === 'won').length,
        lost: state.trackedBets.filter(b => b.status === 'lost').length,
        byType: {},
        byPick: {}
      };
      
      // Win rate
      const completed = stats.won + stats.lost;
      stats.winRate = completed > 0 ? ((stats.won / completed) * 100).toFixed(1) : 0;
      
      // Per tipo (prematch vs live)
      ['prematch', 'live'].forEach(type => {
        const bets = state.trackedBets.filter(b => b.type === type);
        const won = bets.filter(b => b.status === 'won').length;
        const lost = bets.filter(b => b.status === 'lost').length;
        const total = won + lost;
        stats.byType[type] = {
          total: bets.length,
          won,
          lost,
          winRate: total > 0 ? ((won / total) * 100).toFixed(1) : 0
        };
      });
      
      // Per tipo di pick - CORRETTO per evitare sovrapposizioni
      // Funzione helper per matchare esattamente il tipo di pick
      const matchPick = (pick, patterns) => {
        const p = pick.toLowerCase().trim();
        return patterns.some(pattern => {
          if (pattern.startsWith('^')) {
            // Match esatto all'inizio
            return p.startsWith(pattern.slice(1));
          } else if (pattern.endsWith('$')) {
            // Match esatto alla fine
            return p.endsWith(pattern.slice(0, -1));
          } else if (pattern.includes('|exact|')) {
            // Match esatto
            return p === pattern.replace('|exact|', '');
          } else {
            // Match contains
            return p.includes(pattern);
          }
        });
      };
      
      const pickCategories = [
        { patterns: ['over 0.5'], label: 'Over 0.5', excludePatterns: [] },
        { patterns: ['over 1.5'], label: 'Over 1.5', excludePatterns: [] },
        { patterns: ['over 2.5'], label: 'Over 2.5', excludePatterns: [] },
        { patterns: ['over 3.5'], label: 'Over 3.5', excludePatterns: [] },
        { patterns: ['under 1.5', 'under 2.5', 'under 3.5'], label: 'Under', excludePatterns: [] },
        { patterns: ['|exact|gg', 'entrambe segnano', '|exact|goal'], label: 'GG', excludePatterns: ['multigol'] },
        { patterns: ['|exact|ng', 'no gol'], label: 'NG', excludePatterns: [] },
        { patterns: ['^1x', '1x '], label: '1X', excludePatterns: [] },
        { patterns: ['^x2', 'x2 '], label: 'X2', excludePatterns: [] },
        { patterns: ['|exact|1', '^1 (', '1 (vittoria'], label: '1 (Casa)', excludePatterns: ['1x', 'over 1', 'under 1', 'multigol 1'] },
        { patterns: ['|exact|2', '^2 (', '2 (vittoria'], label: '2 (Ospite)', excludePatterns: ['x2', 'over 2', 'under 2', 'multigol 2'] },
        { patterns: ['|exact|x', 'pareggio', 'x (pareggio)'], label: 'X (Pareggio)', excludePatterns: ['1x', 'x2'] },
        { patterns: ['multigol'], label: 'Multigol', excludePatterns: [] }
      ];
      
      pickCategories.forEach(cat => {
        const bets = state.trackedBets.filter(b => {
          const pick = b.pick.toLowerCase().trim();
          // Verifica che matchi almeno un pattern
          const matches = matchPick(pick, cat.patterns);
          // Verifica che non sia escluso
          const excluded = cat.excludePatterns.length > 0 && 
            cat.excludePatterns.some(ex => pick.includes(ex));
          return matches && !excluded;
        });
        
        const won = bets.filter(b => b.status === 'won').length;
        const lost = bets.filter(b => b.status === 'lost').length;
        const total = won + lost;
        
        if (bets.length > 0) {
          stats.byPick[cat.label] = {
            total: bets.length,
            won,
            lost,
            winRate: total > 0 ? ((won / total) * 100).toFixed(1) : 0
          };
        }
      });
      
      return stats;
    }
    
    function clearOldTrackedBets() {
      // Rimuove bet completati piÃ¹ vecchi di 30 giorni
      const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
      state.trackedBets = state.trackedBets.filter(b => {
        if (b.status === 'pending') return true;
        return new Date(b.timestamp).getTime() > thirtyDaysAgo;
      });
      saveTrackedBets();
    }
    
    // === VERIFICA AUTOMATICA RISULTATI ===
    async function autoVerifyPendingBets() {
      const pending = state.trackedBets.filter(b => b.status === 'pending');
      if (pending.length === 0) {
        console.log('âœ… Nessun pronostico pendente da verificare');
        return;
      }
      
      console.log(`&#x1F50D; Verifica automatica di ${pending.length} pronostici pendenti...`);
      let updatedCount = 0;
      
      for (const bet of pending) {
        try {
          // Controlla se la partita Ã¨ finita (almeno 30 minuti fa - tempo sufficiente per fine match)
          const betDate = new Date(bet.timestamp);
          const now = new Date();
          const minutesSince = (now - betDate) / (1000 * 60);
          
          console.log(`â³ Verifica bet: ${bet.matchName} (${(minutesSince/60).toFixed(1)}h fa)`);
          
          // Verifica solo partite che sono iniziate almeno 30 minuti fa
          if (minutesSince < 30) {
            console.log(`  â¸ï¸ Troppo recente, skippo`);
            continue;
          }
          
          // Ottieni risultato dalla API
          const data = await callAPIFootball('/fixtures', { id: bet.matchId });
          
          if (!data?.response || data.response.length === 0) {
            console.log(`  âŒ Nessun dato ricevuto per fixture ${bet.matchId}`);
            continue;
          }
          
          const fixture = data.response[0];
          const status = fixture.fixture.status.short;
          
          // Partita finita?
          if (!['FT', 'AET', 'PEN'].includes(status)) {
            console.log(`  â¸ï¸ Partita non ancora finita (status: ${status})`);
            continue;
          }
          
          const homeGoals = fixture.goals.home;
          const awayGoals = fixture.goals.away;
          const totalGoals = homeGoals + awayGoals;
          
          // Verifica risultato basandosi sul tipo di pronostico
          let isWon = false;
          const pickLower = bet.pick.toLowerCase().trim();
          
          // IMPORTANTE: Ordine dei check - piÃ¹ specifico prima
          if (pickLower.includes('over 3.5')) isWon = totalGoals >= 4;
          else if (pickLower.includes('over 2.5')) isWon = totalGoals >= 3;
          else if (pickLower.includes('over 1.5')) isWon = totalGoals >= 2;
          else if (pickLower.includes('over 0.5')) isWon = totalGoals >= 1;
          else if (pickLower.includes('under 1.5')) isWon = totalGoals < 2;
          else if (pickLower.includes('under 2.5')) isWon = totalGoals < 3;
          else if (pickLower.includes('under 3.5')) isWon = totalGoals < 4;
          else if (pickLower === 'gg' || pickLower.includes('entrambe segnano') || pickLower === 'goal') isWon = homeGoals > 0 && awayGoals > 0;
          else if (pickLower === 'ng' || pickLower.includes('no gol')) isWon = homeGoals === 0 || awayGoals === 0;
          // Doppie chance PRIMA delle singole
          else if (pickLower === '1x' || pickLower.startsWith('1x ')) isWon = homeGoals >= awayGoals;
          else if (pickLower === 'x2' || pickLower.startsWith('x2 ')) isWon = homeGoals <= awayGoals;
          else if (pickLower === '12' || pickLower.includes('no pareggio')) isWon = homeGoals !== awayGoals;
          // 1X2 singoli
          else if (pickLower === '1' || pickLower.includes('vittoria casa') || pickLower.includes('1 (')) isWon = homeGoals > awayGoals;
          else if (pickLower === '2' || pickLower.includes('vittoria ospite') || pickLower.includes('2 (')) isWon = homeGoals < awayGoals;
          else if (pickLower === 'x' || pickLower === 'pareggio' || pickLower.includes('x (')) isWon = homeGoals === awayGoals;
          else {
            console.warn(`âš ï¸ Pick type non riconosciuto: "${bet.pick}"`);
            continue;
          }
          
          // Aggiorna stato
          bet.status = isWon ? 'won' : 'lost';
          bet.result = `${homeGoals}-${awayGoals}`;
          bet.verified = new Date().toISOString();
          updatedCount++;
          
          console.log(`${isWon ? 'âœ…' : 'âŒ'} ${bet.matchName}: ${bet.pick} - ${homeGoals}-${awayGoals}`);
          
          // Aggiorna ML thresholds
          updateMLThresholds(bet.pick, isWon, bet.prob);
          
          // Piccola pausa per evitare rate limiting
          await new Promise(resolve => setTimeout(resolve, 300));
          
        } catch (e) {
          console.warn(`Errore verifica bet ${bet.id}:`, e);
        }
      }
      
      // Salva solo se ci sono stati aggiornamenti
      if (updatedCount > 0) {
        saveTrackedBets();
        saveMLThresholds();
        updatePerformanceHistory();
        updateMLFromResults();
        
        console.log(`&#x1F4CA; Aggiornati ${updatedCount} pronostici`);
      }
      
      // Aggiorna interfaccia
      render();
      
      console.log('âœ… Verifica automatica completata');
    }
    
    // === MACHINE LEARNING: CALIBRAZIONE SOGLIE ===
    function updateMLThresholds(pick, isWon, prob) {
      // Normalizza il pick per trovare la categoria giusta
      const pickLower = pick.toLowerCase().trim();
      let market = null;
      
      // IMPORTANTE: Ordine dei check - piÃ¹ specifico prima
      // Over/Under
      if (pickLower.includes('over 3.5')) market = 'Over 3.5';
      else if (pickLower.includes('over 2.5')) market = 'Over 2.5';
      else if (pickLower.includes('over 1.5')) market = 'Over 1.5';
      else if (pickLower.includes('under 2.5')) market = 'Under 2.5';
      else if (pickLower.includes('under 3.5')) market = 'Under 3.5';
      // GG/NG
      else if (pickLower.includes('gg') || pickLower.includes('entrambe segnano') || pickLower.includes('both teams')) market = 'GG';
      else if (pickLower.includes('ng') || pickLower.includes('no gol') || pickLower.includes('nessuna')) market = 'NG';
      // Doppie chance (PRIMA delle singole!)
      else if (pickLower === '1x' || pickLower.includes('1x ') || pickLower.includes('casa o pareggio')) market = '1X';
      else if (pickLower === 'x2' || pickLower.includes('x2 ') || pickLower.includes('pareggio o ospite')) market = 'X2';
      // Risultati esatti
      else if (pickLower.includes('1 (') || pickLower === '1' || pickLower.includes('vittoria casa') || pickLower.includes('home win')) market = '1';
      else if (pickLower.includes('2 (') || pickLower === '2' || pickLower.includes('vittoria ospite') || pickLower.includes('away win')) market = '2';
      else if (pickLower.includes('pareggio') || pickLower === 'x' || pickLower.includes('x (') || pickLower.includes('draw')) market = 'X';
      
      // Se mercato non trovato o non supportato, skippa
      if (!market) {
        console.log(`&#x1F916; ML: Mercato non riconosciuto per "${pick}"`);
        return;
      }
      
      // Se il mercato non esiste ancora in mlThresholds, crealo
      if (!state.mlThresholds[market]) {
        state.mlThresholds[market] = {
          threshold: 55,
          accuracy: 0,
          totalPredictions: 0,
          correctPredictions: 0,
          streak: 0,
          lastResults: []
        };
      }
      
      const ml = state.mlThresholds[market];
      const oldThreshold = ml.threshold;
      const oldAccuracy = ml.accuracy;
      
      // Aggiorna statistiche
      ml.totalPredictions++;
      if (isWon) {
        ml.correctPredictions++;
        ml.streak = (ml.streak >= 0) ? ml.streak + 1 : 1; // Reset o incrementa streak positivo
      } else {
        ml.streak = (ml.streak <= 0) ? ml.streak - 1 : -1; // Reset o decrementa streak negativo
      }
      
      // Salva ultimi 10 risultati
      if (!ml.lastResults) ml.lastResults = [];
      ml.lastResults.push(isWon ? 1 : 0);
      if (ml.lastResults.length > 10) ml.lastResults.shift();
      
      // Calcola accuracy
      ml.accuracy = ml.totalPredictions > 0 
        ? ((ml.correctPredictions / ml.totalPredictions) * 100).toFixed(1) 
        : 0;
      
      // === CALIBRAZIONE SOGLIA INTELLIGENTE ===
      // Basata su accuracy globale + trend recente
      if (ml.totalPredictions >= 15) {
        const currentAccuracy = parseFloat(ml.accuracy);
        const recentAccuracy = ml.lastResults.length >= 5 
          ? (ml.lastResults.slice(-5).reduce((a, b) => a + b, 0) / 5) * 100
          : currentAccuracy;
        
        // Se accuracy bassa E trend negativo â†’ aumenta molto la soglia
        if (currentAccuracy < 45 && recentAccuracy < 40) {
          ml.threshold = Math.min(ml.threshold + 4, 80);
        }
        // Se accuracy sotto 50% â†’ aumenta soglia
        else if (currentAccuracy < 50) {
          ml.threshold = Math.min(ml.threshold + 2, 75);
        }
        // Se accuracy molto alta E trend positivo â†’ diminuisci soglia
        else if (currentAccuracy > 70 && recentAccuracy > 70 && ml.totalPredictions >= 25) {
          ml.threshold = Math.max(ml.threshold - 2, 35);
        }
        // Se accuracy buona â†’ leggera diminuzione
        else if (currentAccuracy > 60 && ml.totalPredictions >= 20) {
          ml.threshold = Math.max(ml.threshold - 1, 40);
        }
      }
      
      // Log dettagliato per debug
      const trendEmoji = ml.streak > 0 ? '&#x1F4C8;' : (ml.streak < 0 ? '&#x1F4C9;' : 'âž–');
      console.log(`&#x1F916; ML Update [${market}]: ${isWon ? 'WIN âœ…' : 'LOSS âŒ'} | Accuracy: ${oldAccuracy}% â†’ ${ml.accuracy}% (${ml.correctPredictions}/${ml.totalPredictions}) | Threshold: ${oldThreshold}% ${ml.threshold !== oldThreshold ? 'â†’ ' + ml.threshold + '%' : ''} | Streak: ${ml.streak} ${trendEmoji}`);
    }
    
    function saveMLThresholds() {
      // Salva su localStorage (locale)
      localStorage.setItem('bp2_ml_thresholds', JSON.stringify(state.mlThresholds));
      
      // Salva su Firebase (cloud) - async, non bloccante
      saveToFirebase('mlThresholds', state.mlThresholds).catch(e => 
        console.warn('Firebase save mlThresholds failed:', e)
      );
    }
    
    function getMLInsights() {
      const insights = [];
      
      Object.entries(state.mlThresholds).forEach(([market, data]) => {
        if (data.totalPredictions < 10) {
          insights.push({
            market,
            status: 'learning',
            message: `${market}: Raccogliendo dati (${data.totalPredictions}/15 predizioni)`,
            accuracy: data.accuracy,
            threshold: data.threshold
          });
        } else {
          const acc = parseFloat(data.accuracy);
          let status = 'stable';
          let message = '';
          
          if (acc < 50) {
            status = 'declining';
            message = `${market}: Performance bassa (${acc}%). Soglia aumentata a ${data.threshold}% per essere piÃ¹ selettivi.`;
          } else if (acc >= 70) {
            status = 'improving';
            message = `${market}: Ottima performance (${acc}%)! Soglia calibrata a ${data.threshold}%.`;
          } else {
            message = `${market}: Performance stabile (${acc}%). Soglia: ${data.threshold}%.`;
          }
          
          insights.push({
            market,
            status,
            message,
            accuracy: acc,
            threshold: data.threshold,
            total: data.totalPredictions,
            correct: data.correctPredictions
          });
        }
      });
      
      return insights.sort((a, b) => b.total - a.total);
    }
    
    // === PERFORMANCE HISTORY ===
    function updatePerformanceHistory() {
      const today = new Date().toISOString().split('T')[0];
      const stats = getTrackingStats();
      
      // Rimuovi entry di oggi se esiste
      state.performanceHistory = state.performanceHistory.filter(h => h.date !== today);
      
      // Aggiungi nuova entry
      state.performanceHistory.push({
        date: today,
        totalBets: stats.total,
        won: stats.won,
        lost: stats.lost,
        pending: stats.pending,
        winRate: parseFloat(stats.winRate),
        byMarket: stats.byPick
      });
      
      // Mantieni solo ultimi 60 giorni
      if (state.performanceHistory.length > 60) {
        state.performanceHistory = state.performanceHistory.slice(-60);
      }
      
      localStorage.setItem('bp2_performance_history', JSON.stringify(state.performanceHistory));
      
      // Salva su Firebase (cloud) - async, non bloccante
      saveToFirebase('performanceHistory', state.performanceHistory).catch(e => 
        console.warn('Firebase save performanceHistory failed:', e)
      );
    }
    
    // === RENDER ===
    function render() {
      document.getElementById('app').innerHTML = `
        ${renderHeader()}
        <main class="main">
          ${state.loading ? renderLoading() :
            state.view === 'leagues' ? renderLeagues() :
            state.view === 'matches' ? renderMatches() :
            state.view === 'performance' ? renderPerformance() :
            renderAnalysis()}
        </main>
        ${renderSlipFloating()}
        ${state.slipModal ? renderSlipModal() : ''}
      `;
      attachEvents();
      
      // Inizializza grafici se siamo nella view performance
      if (state.view === 'performance') {
        setTimeout(() => initializeCharts(), 100);
      }
    }

    function renderHeader() {
      const userDisplay = authState.isLoggedIn 
        ? `<span class="user-email" title="${authState.email}">&#x1F464; ${authState.email.split('@')[0]}</span>`
        : '';
      
      return `
        <header class="header">
          <div class="header-inner">
            <div class="brand">
              <div class="brand-icon">âš½</div>
              <span class="brand-name">BettingPro</span>
            </div>
            <div class="header-right">
              <div class="status-bar">
                <div class="status-item">
                  <span class="status-dot ${state.api.football}"></span>
                  <span>API</span>
                </div>
                <div class="status-item">
                  <span class="status-dot ${state.api.footystats}"></span>
                  <span>Stats</span>
                </div>
                <div class="status-item" title="Firebase Cloud Storage">
                  <span class="status-dot ${firebaseEnabled ? 'online' : 'offline'}"></span>
                  <span>Cloud</span>
                </div>
              </div>
              ${userDisplay}
              <button class="auth-btn ${authState.isLoggedIn ? 'logged-in' : ''}" onclick="${authState.isLoggedIn ? 'firebaseLogout()' : 'toggleLoginModal()'}" title="${authState.isLoggedIn ? 'Esci' : 'Accedi per sincronizzare su tutti i dispositivi'}">
                ${authState.isLoggedIn ? '&#x1F6AA; Esci' : '&#x1F510; Accedi'}
              </button>
              <button class="settings-btn" onclick="showPerformance()" title="Performance & Analytics">
                &#x1F4CA;
              </button>
              <button class="settings-btn" onclick="toggleSettingsPanel()" title="Impostazioni">
                âš™ï¸
              </button>
              <div class="slip-badge" id="openSlip">
                &#x1F3AB; ${state.slip.length} pronostici
              </div>
            </div>
          </div>
        </header>
        ${renderSettingsPanel()}
        ${authState.showLoginModal ? renderLoginModal() : ''}
      `;
    }
    
    function renderLoginModal() {
      return `
        <div class="login-modal-overlay" onclick="toggleLoginModal()">
          <div class="login-modal" onclick="event.stopPropagation()">
            <div class="login-header">
              <h2>&#x1F510; Accedi a BettingPro</h2>
              <button class="login-close" onclick="toggleLoginModal()">Ã—</button>
            </div>
            <div class="login-body">
              <p class="login-info">Accedi per sincronizzare i tuoi pronostici su tutti i dispositivi</p>
              
              ${authState.loginError ? `<div class="login-error">âŒ ${authState.loginError}</div>` : ''}
              
              <div class="login-form">
                <input type="email" id="loginEmail" placeholder="Email" class="login-input" />
                <input type="password" id="loginPassword" placeholder="Password" class="login-input" />
                
                <div class="login-buttons">
                  <button class="login-btn primary" onclick="handleLogin()" ${authState.isLoading ? 'disabled' : ''}>
                    ${authState.isLoading ? 'â³ Attendere...' : '&#x1F511; Accedi'}
                  </button>
                  <button class="login-btn secondary" onclick="handleRegister()" ${authState.isLoading ? 'disabled' : ''}>
                    ${authState.isLoading ? 'â³ Attendere...' : '&#x1F4DD; Registrati'}
                  </button>
                </div>
              </div>
              
              <div class="login-note">
                <p>&#x1F4A1; <strong>Nota:</strong> La registrazione Ã¨ gratuita e ti permette di:</p>
                <ul>
                  <li>âœ… Sincronizzare i pronostici tracciati su tutti i dispositivi</li>
                  <li>âœ… Mantenere le statistiche ML personalizzate</li>
                  <li>âœ… Accedere alla cronologia ovunque</li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    // Handler per login/registrazione (chiamati dal modal)
    function handleLogin() {
      const email = document.getElementById('loginEmail')?.value;
      const password = document.getElementById('loginPassword')?.value;
      if (email && password) {
        firebaseLogin(email, password);
      } else {
        authState.loginError = 'Inserisci email e password';
        render();
      }
    }
    
    function handleRegister() {
      const email = document.getElementById('loginEmail')?.value;
      const password = document.getElementById('loginPassword')?.value;
      if (email && password) {
        if (password.length < 6) {
          authState.loginError = 'La password deve avere almeno 6 caratteri';
          render();
          return;
        }
        firebaseRegister(email, password);
      } else {
        authState.loginError = 'Inserisci email e password';
        render();
      }
    }
    
    function renderSettingsPanel() {
      const s = state.settings;
      const stats = getTrackingStats();
      return `
        <div class="settings-overlay ${state.settingsOpen ? 'open' : ''}" onclick="toggleSettingsPanel()"></div>
        <div class="settings-panel ${state.settingsOpen ? 'open' : ''}">
          <div class="settings-header">
            <span class="settings-title">âš™ï¸ Impostazioni</span>
            <button class="settings-close" onclick="toggleSettingsPanel()">Ã—</button>
          </div>
          
          <div class="settings-section">
            <div class="settings-section-title">&#x1F4CA; Win Rate per Segno</div>
            ${renderWinRateByPick(stats)}
          </div>
          
          <div class="settings-section">
            <div class="settings-section-title">&#x1F527; FunzionalitÃ </div>
            <div class="settings-row">
              <span class="settings-label">Mostra Classifica</span>
              <div class="settings-toggle ${s.showStandings ? 'active' : ''}" 
                onclick="toggleSetting('showStandings')"></div>
            </div>
            <div class="settings-row">
              <span class="settings-label">Mostra Infortunati</span>
              <div class="settings-toggle ${s.showInjuries ? 'active' : ''}" 
                onclick="toggleSetting('showInjuries')"></div>
            </div>
            <div class="settings-row">
              <span class="settings-label">Auto-refresh LIVE</span>
              <div class="settings-toggle ${s.autoRefresh ? 'active' : ''}" 
                onclick="toggleSetting('autoRefresh')"></div>
            </div>
          </div>
          
          <div class="settings-section">
            <div class="settings-section-title">&#x1F4C8; Storico Ultimi Pronostici</div>
            ${renderHistoryChart()}
          </div>
          
          <div class="settings-section">
            <button class="btn btn-secondary" style="width:100%" onclick="resetAllData()">
              &#x1F5D1;ï¸ Reset tutti i dati
            </button>
          </div>
        </div>
      `;
    }
    
    function renderWinRateByPick(stats) {
      const picks = Object.entries(stats.byPick);
      if (picks.length === 0) {
        return '<div style="text-align:center; color:var(--text-dark); padding:20px;">Nessun pronostico tracciato</div>';
      }
      
      // Ordina per numero di giocate
      picks.sort((a, b) => b[1].total - a[1].total);
      
      return `
        <div class="winrate-grid">
          ${picks.map(([label, data]) => `
            <div class="winrate-item">
              <div class="winrate-label">${label}</div>
              <div class="winrate-stats">
                <span class="winrate-played">${data.total} giocate</span>
                <span class="winrate-won">âœ… ${data.won}</span>
                <span class="winrate-lost">âŒ ${data.lost}</span>
              </div>
              <div class="winrate-bar">
                <div class="winrate-bar-fill ${parseFloat(data.winRate) >= 50 ? 'good' : 'bad'}" 
                  style="width: ${data.winRate}%"></div>
              </div>
              <div class="winrate-percent">${data.winRate}%</div>
            </div>
          `).join('')}
        </div>
        
        <div class="winrate-summary">
          <div class="winrate-summary-item">
            <span>Totale</span>
            <strong>${stats.total}</strong>
          </div>
          <div class="winrate-summary-item">
            <span>Vinte</span>
            <strong style="color: var(--accent-green)">${stats.won}</strong>
          </div>
          <div class="winrate-summary-item">
            <span>Perse</span>
            <strong style="color: var(--accent-red)">${stats.lost}</strong>
          </div>
          <div class="winrate-summary-item">
            <span>Win Rate</span>
            <strong style="color: var(--accent-cyan)">${stats.winRate}%</strong>
          </div>
        </div>
      `;
    }
    
    function renderHistoryChart() {
      const bets = state.trackedBets.filter(b => b.status !== 'pending').slice(-20);
      if (bets.length === 0) {
        return '<div style="text-align:center; color:var(--text-dark); padding:20px;">Nessun pronostico verificato</div>';
      }
      
      const maxHeight = 60;
      return `
        <div class="history-chart">
          <div class="history-bars">
            ${bets.map(b => `
              <div class="history-bar ${b.status}" style="height: ${maxHeight}px" title="${b.match}: ${b.pick} - ${b.status === 'won' ? 'VINTO' : 'PERSO'}"></div>
            `).join('')}
          </div>
          <div class="history-labels">
            <span>Ultimi ${bets.length} pronostici</span>
            <span style="color: var(--accent-green)">${bets.filter(b => b.status === 'won').length}V</span>
            <span style="color: var(--accent-red)">${bets.filter(b => b.status === 'lost').length}P</span>
          </div>
        </div>
      `;
    }
    
    function toggleSetting(key) {
      state.settings[key] = !state.settings[key];
      saveSettings();
      render();
    }
    
    function resetAllData() {
      if (confirm('Sei sicuro di voler cancellare TUTTI i dati? (pronostici, impostazioni, statistiche)')) {
        localStorage.removeItem('bp2_tracked');
        localStorage.removeItem('bp2_settings');
        localStorage.removeItem('bp2_history');
        localStorage.removeItem('bp2_bankroll');
        localStorage.removeItem('bp2_slip');
        state.trackedBets = [];
        state.slip = [];
        state.settings = {
          thresholds: { '1': 50, 'X': 28, '2': 50, 'GG': 55, 'Over 2.5': 50, 'Over 1.5': 65 },
          showInjuries: true, showStandings: true, autoRefresh: true
        };
        render();
        alert('âœ… Tutti i dati sono stati cancellati');
      }
    }
    
    // Filtra campionati e squadre
    function renderLoading() {
      return `<div class="loading"><div class="spinner"></div><div class="loading-text">Caricamento...</div></div>`;
    }

    // === RENDER PERFORMANCE VIEW ===
    function renderPerformance() {
      const stats = getTrackingStats();
      const mlInsights = getMLInsights();
      const history = state.performanceHistory.slice(-30); // Ultimi 30 giorni
      
      return `
        <div class="panel">
          <div class="panel-title">&#x1F4CA; Performance & Analytics</div>
          
          <!-- STATS OVERVIEW -->
          <div class="stats-overview" style="grid-template-columns: repeat(4, 1fr); margin-bottom: 24px;">
            <div class="stats-card">
              <div class="stats-card-value ${stats.winRate >= 60 ? 'green' : stats.winRate >= 50 ? 'yellow' : 'red'}">
                ${stats.winRate}%
              </div>
              <div class="stats-card-label">Win Rate Totale</div>
            </div>
            <div class="stats-card">
              <div class="stats-card-value green">${stats.won}</div>
              <div class="stats-card-label">Pronostici Vinti</div>
            </div>
            <div class="stats-card">
              <div class="stats-card-value red">${stats.lost}</div>
              <div class="stats-card-label">Pronostici Persi</div>
            </div>
            <div class="stats-card">
              <div class="stats-card-value">${stats.total}</div>
              <div class="stats-card-label">Totale Pronostici</div>
            </div>
          </div>
          
          <!-- MACHINE LEARNING INSIGHTS -->
          ${mlInsights.length > 0 ? `
          <div class="ml-insights">
            <div class="ml-insights-header">
              <div class="ml-insights-icon">&#x1F916;</div>
              <div>
                <div class="ml-insights-title">Machine Learning Insights</div>
                <div style="font-size: 0.75rem; color: var(--text-gray); margin-top: 4px;">
                  Calibrazione automatica delle soglie basata sui risultati storici
                </div>
              </div>
            </div>
            
            ${mlInsights.map(insight => `
              <div class="ml-suggestion-card">
                <div class="ml-suggestion-header">
                  <span class="ml-suggestion-market">${insight.market}</span>
                  <span class="ml-suggestion-status ${insight.status}">${
                    insight.status === 'improving' ? '&#x1F4C8; In miglioramento' :
                    insight.status === 'declining' ? '&#x1F4C9; In calo' :
                    insight.status === 'learning' ? '&#x1F393; Apprendimento' : 'âž¡ï¸ Stabile'
                  }</span>
                </div>
                <div class="ml-suggestion-body">
                  ${insight.message}
                  ${insight.total >= 10 ? `<br><small>${insight.correct}/${insight.total} predizioni corrette</small>` : ''}
                </div>
              </div>
            `).join('')}
          </div>
          ` : ''}
          
          <!-- GRAFICI -->
          <div class="performance-grid">
            <!-- Win Rate nel Tempo -->
            <div class="chart-container" style="grid-column: span 2;">
              <div class="chart-header">
                <div class="chart-title">&#x1F4C8; Win Rate nel Tempo (Ultimi 30 giorni)</div>
              </div>
              <div class="chart-canvas-wrapper">
                <canvas id="winRateChart"></canvas>
              </div>
            </div>
            
            <!-- Performance per Mercato -->
            <div class="chart-container">
              <div class="chart-header">
                <div class="chart-title">&#x1F3AF; Performance per Mercato</div>
              </div>
              <div class="chart-canvas-wrapper">
                <canvas id="marketPerformanceChart"></canvas>
              </div>
            </div>
            
            <!-- Distribuzione Risultati -->
            <div class="chart-container">
              <div class="chart-header">
                <div class="chart-title">&#x1F4CA; Distribuzione Risultati</div>
              </div>
              <div class="chart-canvas-wrapper">
                <canvas id="resultsDistributionChart"></canvas>
              </div>
            </div>
          </div>
          
          <!-- BOTTONE VERIFICA AUTOMATICA -->
          <div style="text-align: center; margin-top: 24px;">
            <button class="btn btn-primary" onclick="manualVerifyBets()" style="padding: 12px 32px; font-size: 1rem;">
              &#x1F50D; Verifica Risultati Pendenti
            </button>
            <div style="font-size: 0.75rem; color: var(--text-dark); margin-top: 8px;">
              Verifica automaticamente i risultati delle partite terminate
            </div>
          </div>
          
          <!-- BACK BUTTON -->
          <div style="text-align: center; margin-top: 16px;">
            <button class="btn btn-secondary" id="backFromPerformance" onclick="backToLeagues()">
              â† Torna ai Campionati
            </button>
          </div>
        </div>
      `;
    }
    
    // === INITIALIZE CHARTS ===
    function initializeCharts() {
      if (!window.Chart) {
        console.warn('Chart.js non caricato');
        return;
      }
      
      const history = state.performanceHistory.slice(-30);
      const stats = getTrackingStats();
      
      // Chart.js default colors
      Chart.defaults.color = '#94a3b8';
      Chart.defaults.borderColor = 'rgba(255,255,255,0.08)';
      
      // 1. WIN RATE NEL TEMPO
      const winRateCtx = document.getElementById('winRateChart');
      if (winRateCtx && history.length > 0) {
        new Chart(winRateCtx, {
          type: 'line',
          data: {
            labels: history.map(h => new Date(h.date).toLocaleDateString('it-IT', { month: 'short', day: 'numeric' })),
            datasets: [{
              label: 'Win Rate %',
              data: history.map(h => h.winRate),
              borderColor: '#3b82f6',
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              fill: true,
              tension: 0.4,
              pointRadius: 4,
              pointHoverRadius: 6
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                backgroundColor: '#22253a',
                titleColor: '#f1f5f9',
                bodyColor: '#94a3b8',
                borderColor: 'rgba(255,255,255,0.1)',
                borderWidth: 1
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                max: 100,
                grid: { color: 'rgba(255,255,255,0.05)' }
              },
              x: {
                grid: { display: false }
              }
            }
          }
        });
      }
      
      // 2. PERFORMANCE PER MERCATO
      const marketCtx = document.getElementById('marketPerformanceChart');
      if (marketCtx && Object.keys(stats.byPick).length > 0) {
        const marketData = Object.entries(stats.byPick).sort((a, b) => b[1].total - a[1].total).slice(0, 5);
        
        new Chart(marketCtx, {
          type: 'bar',
          data: {
            labels: marketData.map(m => m[0]),
            datasets: [{
              label: 'Win Rate %',
              data: marketData.map(m => parseFloat(m[1].winRate)),
              backgroundColor: marketData.map(m => {
                const wr = parseFloat(m[1].winRate);
                return wr >= 60 ? 'rgba(16, 185, 129, 0.8)' :
                       wr >= 50 ? 'rgba(251, 191, 36, 0.8)' :
                       'rgba(239, 68, 68, 0.8)';
              }),
              borderRadius: 8,
              borderSkipped: false
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false }
            },
            scales: {
              y: {
                beginAtZero: true,
                max: 100,
                grid: { color: 'rgba(255,255,255,0.05)' }
              },
              x: {
                grid: { display: false }
              }
            }
          }
        });
      }
      
      // 3. DISTRIBUZIONE RISULTATI
      const resultsCtx = document.getElementById('resultsDistributionChart');
      if (resultsCtx) {
        new Chart(resultsCtx, {
          type: 'doughnut',
          data: {
            labels: ['Vinti', 'Persi', 'Pendenti'],
            datasets: [{
              data: [stats.won, stats.lost, stats.pending],
              backgroundColor: [
                'rgba(16, 185, 129, 0.8)',
                'rgba(239, 68, 68, 0.8)',
                'rgba(251, 191, 36, 0.8)'
              ],
              borderWidth: 0
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  padding: 15,
                  font: { size: 12 }
                }
              }
            }
          }
        });
      }
    }
    
    function manualVerifyBets() {
      if (confirm('Vuoi verificare automaticamente i risultati delle partite terminate?\n\nQuesto potrebbe richiedere alcuni minuti.')) {
        state.loading = true;
        render();
        
        autoVerifyPendingBets().then(() => {
          state.loading = false;
          const stats = getTrackingStats();
          alert(`âœ… Verifica completata!\n\nWin Rate: ${stats.winRate}%\nVinti: ${stats.won}\nPersi: ${stats.lost}\nPendenti: ${stats.pending}`);
          render();
        }).catch(e => {
          state.loading = false;
          alert('âŒ Errore durante la verifica:\n\n' + e.message);
          render();
        });
      }
    }
    
    // === DEBUG FUNCTIONS ===
    window.debugTracking = function() {
      const stats = getTrackingStats();
      console.log('=== &#x1F4CA; TRACKING SYSTEM DEBUG ===');
      console.log(`Total Bets: ${stats.total}`);
      console.log(`Won: ${stats.won} | Lost: ${stats.lost} | Pending: ${stats.pending}`);
      console.log(`Win Rate: ${stats.winRate}%`);
      console.log('\n=== &#x1F916; MACHINE LEARNING STATUS ===');
      Object.entries(state.mlThresholds).forEach(([market, data]) => {
        console.log(`[${market}] Accuracy: ${data.accuracy}% (${data.correctPredictions}/${data.totalPredictions}) | Threshold: ${data.threshold}%`);
      });
      console.log('\n=== &#x1F4C8; PERFORMANCE HISTORY ===');
      console.log(`Records: ${state.performanceHistory.length}`);
      if (state.performanceHistory.length > 0) {
        const latest = state.performanceHistory[state.performanceHistory.length - 1];
        console.log(`Latest: ${latest.date} - WR: ${latest.winRate}% (${latest.won}W/${latest.lost}L)`);
      }
      console.log('\n=== &#x1F3AF; TRACKED BETS ===');
      state.trackedBets.forEach((bet, idx) => {
        console.log(`${idx + 1}. [${bet.status.toUpperCase()}] ${bet.matchName} â†’ ${bet.pick} (${bet.prob}%)`);
      });
      console.log('\n&#x1F4A1; Tip: Scrivi debugTracking() in console per vedere queste info');
    };
    
    window.debugFirebase = function() {
      console.log('=== â˜ï¸ FIREBASE DEBUG ===');
      console.log(`Status: ${firebaseEnabled ? 'âœ… ONLINE' : 'âŒ OFFLINE'}`);
      console.log(`User ID: ${USER_ID}`);
      console.log(`Database URL: https://bettingpro2-9f1d9-default-rtdb.europe-west1.firebasedatabase.app/`);
      console.log(`Firebase Path: users/${USER_ID}/`);
      
      if (firebaseEnabled && db) {
        console.log('\n&#x1F4E5; Caricamento dati da Firebase...');
        
        Promise.all([
          loadFromFirebase('trackedBets'),
          loadFromFirebase('mlThresholds'),
          loadFromFirebase('performanceHistory')
        ]).then(([bets, ml, perf]) => {
          console.log('\nâœ… Dati Firebase:');
          console.log(`  Tracked Bets: ${bets ? (Array.isArray(bets) ? bets.length : 'Invalid') : 'Nessuno'}`);
          console.log(`  ML Thresholds: ${ml ? Object.keys(ml).length + ' mercati' : 'Nessuno'}`);
          console.log(`  Performance History: ${perf ? (Array.isArray(perf) ? perf.length + ' records' : 'Invalid') : 'Nessuno'}`);
        }).catch(e => {
          console.error('âŒ Errore caricamento:', e);
        });
      } else {
        console.log('\nâš ï¸ Firebase non disponibile - dati salvati solo in localStorage');
      }
      
      console.log('\n&#x1F4A1; Tips:');
      console.log('  - debugFirebase() per vedere questo status');
      console.log('  - debugTracking() per vedere i dati locali');
    };
    
    function backToLeagues() {
      state.view = 'leagues';
      state.selectedLeague = null;
      render();
    }
    
    function backToMatches() {
      state.view = 'matches';
      state.selectedMatch = null;
      state.analysis = null;
      state.superAnalysis = null;
      state.superAIAnalysis = null;
      state.superAnalysisRunning = false;
      state.superAIRunning = false;
      render();
    }
    
    async function triggerSuperAnalysis() {
      if (!state.analysis || state.superAnalysisRunning) return;
      
      state.superAnalysisRunning = true;
      state.superAIRunning = false;
      state.superAnalysis = null;
      state.superAIAnalysis = null;
      render();
      
      // STEP 1: calcolo locale istantaneo (~400ms)
      await new Promise(r => setTimeout(r, 300));
      try {
        state.superAnalysis = runSuperAlgorithm(state.selectedMatch, state.analysis);
        console.log('&#x1F9E0; Super Algo locale completato:', state.superAnalysis.picks.length, 'mercati');
      } catch (e) {
        console.error('Super Algo locale error:', e);
        state.superAnalysis = null;
      }
      state.superAnalysisRunning = false;
      render();
      
      // Scroll immediato al pannello
      await new Promise(r => setTimeout(r, 100));
      const panel = document.getElementById('superAlgoPanel');
      if (panel) panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
      
      // STEP 2: analisi AI Claude con news (asincrona)
      if (!state.superAnalysis) return;
      state.superAIRunning = true;
      render();
      
      try {
        const aiResult = await callClaudeForSuperAnalysis(state.selectedMatch, state.analysis, state.superAnalysis);
        state.superAIAnalysis = aiResult;
      } catch (e) {
        console.error('Super AI error:', e);
        state.superAIAnalysis = { error: e.message, newsFound: false };
      }
      state.superAIRunning = false;
      render();
    }
    
    async function callClaudeForSuperAnalysis(match, analysis, superData) {
      const homeTeam = match.homeTeam || match.teams?.home?.name || match.home?.name || match.home || 'Team Casa';
      const awayTeam = match.awayTeam || match.teams?.away?.name || match.away?.name || match.away || 'Team Ospite';
      const league = match.league?.name || match.competition?.name || match.leagueName || '';
      const country = match.league?.country || match.country || '';
      const matchDate = match.date || match.fixture?.date || match.kickoff || 'oggi';
      const { xG, p1X2, pOU, pBTTS, exactScores, h2h, homeForm, awayForm, homePosition, awayPosition, homeInjuries, awayInjuries } = analysis;
      
      // Costruisce sommario infortuni
      const homeInj = (homeInjuries||[]).slice(0,3).map(i => i.player?.name||i.name||'N/D').join(', ') || 'nessuno noto';
      const awayInj = (awayInjuries||[]).slice(0,3).map(i => i.player?.name||i.name||'N/D').join(', ') || 'nessuno noto';
      
      // Top esiti attesi
      const topPicks = superData.picks.slice(0,6).map((p,i) => 
        `${i+1}. ${p.value}: prob ${p.prob.toFixed(1)}%, superScore ${p.superScore.toFixed(1)}, convergenza ${(p.convergence*100).toFixed(0)}%, confidenza ${p.confidence}`
      ).join('\n');
      
      // Exact scores top 3
      const topScores = (exactScores||[]).slice(0,4).map(s => `${s.h}-${s.a}(${s.p.toFixed(1)}%)`).join(' ');
      
      // H2H summary
      const h2hSummary = h2h ? `${h2h.homeWins}V-${h2h.draws}P-${h2h.awayWins}S, media gol: ${h2h.avgGoals}` : 'N/D';
      
      const prompt = `Sei Oracle AI, il sistema di pronostico calcistico piu' avanzato al mondo. La tua missione e' analizzare questa partita con la massima precisione possibile e fornire il pronostico ottimale. NON puoi permetterti errori â€” ogni previsione deve essere basata su dati solidi.

=== PARTITA ===
${homeTeam} vs ${awayTeam}
Campionato: ${league} ${country ? '('+country+')' : ''}
Data: ${matchDate}

=== DATI STATISTICI ALGORITMO PRINCIPALE ===
PROBABILITA' 1X2 (Poisson + Dixon-Coles):
  Casa (1): ${p1X2.home.toFixed(2)}%
  Pareggio (X): ${p1X2.draw.toFixed(2)}%
  Ospite (2): ${p1X2.away.toFixed(2)}%

xG ATTESI:
  ${homeTeam}: ${xG.home.toFixed(3)}
  ${awayTeam}: ${xG.away.toFixed(3)}
  Totale: ${xG.total.toFixed(3)}

GOL:
  Over 1.5: ${pOU[1.5].over.toFixed(1)}% | Under 1.5: ${pOU[1.5].under.toFixed(1)}%
  Over 2.5: ${pOU[2.5].over.toFixed(1)}% | Under 2.5: ${pOU[2.5].under.toFixed(1)}%
  Over 3.5: ${pOU[3.5].over.toFixed(1)}% | Under 3.5: ${pOU[3.5].under.toFixed(1)}%
  GG: ${pBTTS.toFixed(1)}% | NG: ${(100-pBTTS).toFixed(1)}%

RISULTATI ESATTI PIU' PROBABILI: ${topScores}

TESTA A TESTA: ${h2hSummary}
FORMA RECENTE: ${homeTeam}: ${homeForm||'N/D'} | ${awayTeam}: ${awayForm||'N/D'}
CLASSIFICA: ${homeTeam} pos.${homePosition||'?'} | ${awayTeam} pos.${awayPosition||'?'}
INFORTUNI NOTI: ${homeTeam}: ${homeInj} | ${awayTeam}: ${awayInj}

=== RANKING SUPER ALGORITMO MULTI-SEGNALE ===
${topPicks}

=== ISTRUZIONI OBBLIGATORIE ===
1. USA IL WEB SEARCH per cercare OBBLIGATORIAMENTE:
   a) Notizie ultimissimi giorni su ${homeTeam}: infortuni, squalifiche, formazione attesa, stato di forma
   b) Notizie ultimissimi giorni su ${awayTeam}: infortuni, squalifiche, formazione attesa, stato di forma  
   c) Contesto della partita: importanza per classifica, derby, rivalita', motivazioni
   d) Quote bookmakers attuali (se disponibili)
   e) Meteo/campo (se rilevante)

2. ANALISI CRITICA:
   - Valuta se i dati statistici riflettono la realta' attuale
   - Identifica se ci sono informazioni che cambiano il quadro
   - Considera pattern e tendenze recenti
   - Valuta il contesto tattico (sistema di gioco, punti di forza/debolezza)

3. PRONOSTICO FINALE:
   - Scegli il pick con il rapporto rischio/rendimento MIGLIORE
   - Deve essere realistico e ben motivato
   - Considera la varianza: preferisci pick ad alta probabilita' a quelli speculativi

Rispondi ESCLUSIVAMENTE con questo JSON preciso (zero testo fuori dal JSON):
{
  "newsFound": true,
  "keyNews": [
    "Notizia specifica e concreta 1 con dettagli",
    "Notizia specifica e concreta 2 con dettagli", 
    "Notizia specifica e concreta 3 con dettagli"
  ],
  "teamsContext": "Analisi tattica e contesto motivazionale in 2-3 frasi concrete",
  "aiVerdict": "Analisi finale in 3-4 frasi: perche' questo e' il momento giusto/sbagliato per giocare, quali fattori incidono di piu', qual e' la lettura corretta della partita",
  "bestPick": "Mercato + Esito specifico es. 'Over 2.5' o '1 (Casa)' o 'GG'",
  "bestPickProb": 72,
  "bestPickReasoning": "Motivazione in 1-2 frasi del perche' questo pick",
  "alternativePick": "Secondo pick consigliato",
  "alternativePickProb": 65,
  "riskLevel": "basso",
  "algoConfirmed": true,
  "adjustedTop3": ["pick 1", "pick 2", "pick 3"],
  "recommendation": "GIOCA",
  "confidence": 74,
  "keyFactors": ["fattore 1", "fattore 2", "fattore 3", "fattore 4"],
  "warningFlags": ["eventuale warning o stringa vuota"],
  "bookmakerOdds": "quote trovate o null"
}`;

      const response = await fetch('https://bettingpro-ai.lucalagan.workers.dev/', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: 'claude-opus-4-6',
          max_tokens: 2000,
          tools: [{ type: 'web_search_20250305', name: 'web_search' }],
          messages: [{ role: 'user', content: prompt }]
        })
      });
      
      if (!response.ok) {
        const errText = await response.text().catch(() => '');
        throw new Error(`API ${response.status}: ${errText.slice(0,200)}`);
      }
      const data = await response.json();
      console.log('Oracle raw:', JSON.stringify(data).slice(0,400));
      
      if (data.error) throw new Error(data.error.message || JSON.stringify(data.error));
      
      // Combina tutti i text blocks (inclusi quelli dopo tool_use)
      const fullText = (data.content || [])
        .filter(item => item.type === 'text')
        .map(item => item.text)
        .join('\n');
      
      if (!fullText) throw new Error('Nessun testo nella risposta AI');
      console.log('Oracle text:', fullText.slice(0,300));
      
      // Estrai JSON robusto
      let parsed = null;
      const mdMatch = fullText.match(/```(?:json)?\s*([\s\S]*?)```/);
      if (mdMatch) { try { parsed = JSON.parse(mdMatch[1].trim()); } catch(e) {} }
      if (!parsed) {
        const s = fullText.indexOf('{'); const e2 = fullText.lastIndexOf('}');
        if (s !== -1 && e2 !== -1) { try { parsed = JSON.parse(fullText.slice(s, e2+1)); } catch(e) {} }
      }
      if (!parsed) throw new Error('JSON non trovato: ' + fullText.slice(0,100));
      
      // Normalizza recommendation
      if (!['GIOCA','SKIP','ATTENDI'].includes(parsed.recommendation)) {
        const r = (parsed.recommendation||'').toUpperCase();
        parsed.recommendation = r.includes('GIOCA') || r.includes('PLAY') || r.includes('YES') ? 'GIOCA' :
                                r.includes('SKIP') || r.includes('EVITA') || r.includes('NO') ? 'SKIP' : 'ATTENDI';
      }
      
      return parsed;
    }
    function showPerformance() {
      state.view = 'performance';
      render();
    }
    
    function renderLeagues() {
      const picks = state.dailyPicks;
      
      return `
        <div class="date-tabs">
          ${[-1, 0, 1, 2].map(d => `
            <div class="date-tab ${state.selectedDate === d ? 'active' : ''}" data-date="${d}">
              ${getDateLabel(d)} ${d !== 0 ? `(${formatDate(getDateString(d))})` : ''}
            </div>
          `).join('')}
        </div>
        
        <!-- SELEZIONA CAMPIONATO -->
        <div class="panel" style="margin-bottom: 16px;">
          <div class="panel-title">&#x1F4CB; Seleziona Campionato (${state.matches.length} partite)</div>
          ${state.leagues.length === 0 ? `<div class="empty"><div class="empty-icon">&#x1F4ED;</div>Nessuna partita</div>` : `
            <select class="select-field" id="leagueSelect">
              <option value="">-- Scegli un campionato --</option>
              ${state.leagues.map(l => `<option value="${l.id}">${esc(l.country)} - ${esc(l.name)} (${l.matchCount})</option>`).join('')}
            </select>
          `}
        </div>
        
        <!-- RADDOPPI DEL GIORNO -->
        ${picks.raddoppi.length > 0 ? `
        <div class="panel" style="margin-bottom: 20px; border: 1px solid var(--accent-green); background: linear-gradient(135deg, rgba(16,185,129,0.05), rgba(34,197,94,0.02));">
          <div class="panel-title" style="color: var(--accent-green); display: flex; align-items: center; gap: 10px;">
            <span style="font-size: 1.3rem;">&#x1F4B0;</span> Raddoppi del Giorno
            <span style="background: var(--accent-green); color: white; padding: 2px 10px; border-radius: 12px; font-size: 0.75rem; font-weight: 700;">${picks.raddoppi.length} COMBO</span>
          </div>
          <div style="font-size: 0.8rem; color: var(--text-gray); margin-bottom: 16px;">
            Combinazioni ad alta probabilitÃ  con quota target ~2.00
          </div>
          <div class="raddoppi-grid">
            ${picks.raddoppi.map((r, idx) => `
              <div class="raddoppio-card" data-raddoppio="${idx}">
                <div class="raddoppio-header">
                  <span class="raddoppio-badge">COMBO #${idx + 1}</span>
                  <span class="raddoppio-odds">@ ${r.totalOdds}</span>
                </div>
                <div class="raddoppio-bets">
                  ${r.bets.map(b => `
                    <div class="raddoppio-bet">
                      <div class="raddoppio-match">${esc(b.shortName)}</div>
                      <div class="raddoppio-pick">${b.bet} <span style="opacity: 0.7; font-size: 0.75rem;">(${(b.prob || 0).toFixed(0)}%)</span></div>
                    </div>
                  `).join('')}
                </div>
                <div class="raddoppio-footer">
                  <div class="raddoppio-prob">${(r.prob || 0).toFixed(0)}% prob. combinata</div>
                </div>
              </div>
            `).join('')}
          </div>
        </div>
        ` : `
        <!-- PLACEHOLDER QUANDO NON CI SONO RADDOPPI -->
        <div class="panel" style="margin-bottom: 20px; text-align: center; padding: 40px 20px;">
          <div style="font-size: 4rem; margin-bottom: 16px;">âš½</div>
          <div style="font-size: 1.2rem; font-weight: 700; color: var(--text-white); margin-bottom: 8px;">Analisi in corso...</div>
          <div style="font-size: 0.9rem; color: var(--text-gray); max-width: 400px; margin: 0 auto;">
            I raddoppi del giorno appariranno qui quando saranno disponibili partite con probabilitÃ  elevate.
          </div>
          <div style="margin-top: 20px; display: flex; justify-content: center; gap: 12px; flex-wrap: wrap;">
            <div style="background: var(--bg-card-light); padding: 12px 20px; border-radius: 12px; border: 1px solid var(--border);">
              <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-cyan);">${state.matches.length}</div>
              <div style="font-size: 0.7rem; color: var(--text-dark);">Partite caricate</div>
            </div>
            <div style="background: var(--bg-card-light); padding: 12px 20px; border-radius: 12px; border: 1px solid var(--border);">
              <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-green);">${state.leagues.length}</div>
              <div style="font-size: 0.7rem; color: var(--text-dark);">Campionati</div>
            </div>
            <div style="background: var(--bg-card-light); padding: 12px 20px; border-radius: 12px; border: 1px solid var(--border);">
              <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-gold);">${picks.matchAdvices.length}</div>
              <div style="font-size: 0.7rem; color: var(--text-dark);">Partite analizzate</div>
            </div>
          </div>
        </div>
        `}
        
        <!-- PRONOSTICI AI DEL GIORNO -->
        ${renderPronosticiAIList(picks)}
        
      `;
    }
    
    // === SCHEDINA VIRTUALE ===
    function renderSchedinaVirtuale() {
      const myBets = state.trackedBets;
      if (myBets.length === 0) return '';
      const won = myBets.filter(b => b.status === 'won').length;
      const lost = myBets.filter(b => b.status === 'lost').length;
      const pending = myBets.filter(b => b.status === 'pending').length;
      const completed = won + lost;
      const wr = completed > 0 ? ((won / completed) * 100) : 0;
      const sorted = [...myBets].sort((a, b) => {
        if (a.status === 'pending' && b.status !== 'pending') return -1;
        if (a.status !== 'pending' && b.status === 'pending') return 1;
        return new Date(b.timestamp) - new Date(a.timestamp);
      }).slice(0, 25);
      const timeAgo = ts => {
        const d = Math.floor((Date.now() - new Date(ts)) / 60000);
        if (d < 60) return d + 'min fa';
        if (d < 1440) return Math.floor(d/60) + 'h fa';
        return Math.floor(d/1440) + 'g fa';
      };
      return `
        <div class="schedina-section">
          <div class="schedina-head">
            <div class="schedina-title">&#x1F3AB; La Mia Schedina</div>
            <div class="schedina-stats">
              <div class="schedina-stat"><div class="schedina-stat-n g">${won}</div><div class="schedina-stat-l">Vinte</div></div>
              <div class="schedina-stat"><div class="schedina-stat-n r">${lost}</div><div class="schedina-stat-l">Perse</div></div>
              <div class="schedina-stat"><div class="schedina-stat-n y">${pending}</div><div class="schedina-stat-l">Attesa</div></div>
            </div>
          </div>
          ${completed > 0 ? `<div class="schedina-wr">
            <span style="font-size:0.75rem;font-weight:700;color:var(--text-gray);">Win Rate</span>
            <div class="schedina-wr-bar"><div class="schedina-wr-fill" style="width:${wr}%;background:${wr>=60?'var(--accent-green)':wr>=45?'var(--accent-yellow)':'var(--accent-red)'}"></div></div>
            <span style="font-size:1rem;font-weight:800;color:${wr>=60?'var(--accent-green)':wr>=45?'var(--accent-yellow)':'var(--accent-red)'}">${wr.toFixed(0)}%</span>
          </div>` : ''}
          <div class="schedina-list">
            ${sorted.map(b => `
              <div class="schedina-item ${b.status}">
                <div class="schedina-item-left">
                  <div class="schedina-item-match">${esc(b.matchName)}</div>
                  <div class="schedina-item-info">${timeAgo(b.timestamp)} ${b.result ? 'â€¢ ' + b.result : 'â€¢ â³ In attesa'}</div>
                </div>
                <div class="schedina-item-right">
                  <div class="schedina-item-pick">${esc(b.pick)}</div>
                  <span style="font-size:0.72rem;font-weight:700;color:var(--accent-cyan)">${b.prob?b.prob.toFixed(0)+'%':''}</span>
                  <div class="schedina-item-status">${b.status==='won'?'âœ…':b.status==='lost'?'âŒ':'â³'}</div>
                </div>
              </div>
            `).join('')}
          </div>
        </div>
      `;
    }
    
    // === NUOVA: Lista Consiglio AI per ogni partita (identico al dettaglio) ===
    function renderPronosticiAIList(picks) {
      const advices = picks.matchAdvices || [];
      
      if (advices.length === 0) {
        return `
          <div class="panel" style="text-align:center;padding:30px;">
            <div style="font-size:2.5rem;margin-bottom:12px;">&#x1F916;</div>
            <div style="font-size:1rem;color:var(--text-gray);">Analisi AI in corso...</div>
            <div style="font-size:0.8rem;color:var(--text-dark);margin-top:8px;">Carica le partite per vedere il Consiglio AI</div>
          </div>
        `;
      }
      
      const highCount = advices.filter(a => a.confidence === 'high').length;
      
      return `
        ${renderSchedinaVirtuale()}
        
        <div class="panel" style="margin-bottom:20px;">
          <div class="panel-title" style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px;">
            <span>&#x1F916; Consiglio AI - Tutte le Partite</span>
            <div style="display:flex;gap:6px;">
              ${highCount > 0 ? `<span style="background:rgba(16,185,129,0.15);color:var(--accent-green);padding:3px 10px;border-radius:12px;font-size:0.7rem;font-weight:700;">&#x1F525; ${highCount} Alta</span>` : ''}
              <span style="background:var(--bg-input);padding:3px 10px;border-radius:12px;font-size:0.7rem;font-weight:700;color:var(--text-gray);">${advices.length} partite</span>
            </div>
          </div>
          <div style="font-size:0.75rem;color:var(--text-gray);margin-bottom:14px;">
            Stesso Consiglio AI della pagina dettaglio: pick, motivazioni e alternative
          </div>
          <div class="advice-grid">
            ${advices.map(a => {
              const isTracked = state.trackedBets.some(b => b.matchId === a.matchId);
              const probClass = a.prob >= 80 ? 'high' : a.prob >= 60 ? 'medium' : 'low';
              return `
              <div class="advice-card">
                <div class="advice-card-head">
                  <div class="advice-league">${a.leagueLogo ? `<img src="${a.leagueLogo}" onerror="this.style.display='none'">` : ''} ${esc(a.league)}</div>
                  <div class="advice-time">â° ${a.time}</div>
                </div>
                <div class="advice-body">
                  <div class="advice-teams">
                    <div class="advice-team">
                      ${a.homeLogo ? `<img src="${a.homeLogo}" onerror="this.style.display='none'">` : ''}
                      <span class="advice-team-name">${esc(a.homeName)}</span>
                    </div>
                    <div class="advice-vs">VS</div>
                    <div class="advice-team">
                      <span class="advice-team-name">${esc(a.awayName)}</span>
                      ${a.awayLogo ? `<img src="${a.awayLogo}" onerror="this.style.display='none'">` : ''}
                    </div>
                  </div>
                  <div class="advice-xg-bar">
                    <span>xG &#x1F3E0; <span class="advice-xg-val">${a.xgHome}</span></span>
                    <span>xG Tot <span class="advice-xg-val">${a.xgTotal}</span></span>
                    <span>xG âœˆï¸ <span class="advice-xg-val">${a.xgAway}</span></span>
                    ${a.dataQuality === 'high' ? '<span style="color:var(--accent-green)">âœ“ Dati</span>' : ''}
                  </div>
                  <div class="advice-main">
                    <div class="advice-main-top">
                      <div class="advice-main-label">Pronostico Consigliato</div>
                      <div class="advice-main-conf ${a.confidence}">${a.confidence === 'high' ? '&#x1F7E2; Alta' : a.confidence === 'medium' ? '&#x1F7E1; Media' : 'âšª Bassa'}</div>
                    </div>
                    <div class="advice-main-row">
                      <div class="advice-main-pick">${esc(a.pick)}</div>
                      <div class="advice-main-prob ${probClass}">${typeof a.prob === 'number' ? a.prob.toFixed(0) : a.prob}%</div>
                    </div>
                  </div>
                  ${a.reasons.length > 0 ? `
                  <div class="advice-reasons">
                    ${a.reasons.slice(0, 3).map(r => `
                      <div class="advice-reason ${r.type}">
                        ${r.type === 'positive' ? 'âœ…' : r.type === 'negative' ? 'âš ï¸' : 'â„¹ï¸'} ${esc(r.text)}
                      </div>
                    `).join('')}
                  </div>
                  ` : ''}
                  ${a.alternatives.length > 0 ? `
                  <div style="font-size:0.65rem;color:var(--text-dark);margin-bottom:4px;font-weight:600;">Alternative valide:</div>
                  <div class="advice-alts">
                    ${a.alternatives.map(alt => `
                      <div class="advice-alt-chip">${esc(alt.pick)} <b>${alt.prob}%</b></div>
                    `).join('')}
                  </div>
                  ` : ''}
                  <div class="advice-footer">
                    <button class="btn-giocato ${isTracked ? 'tracked' : ''}"
                            data-track-matchid="${a.matchId}"
                            data-track-pick="${esc(a.pick)}"
                            data-track-prob="${typeof a.prob === 'number' ? a.prob.toFixed(1) : a.prob}"
                            ${isTracked ? 'disabled' : ''}>
                      ${isTracked ? 'âœ… Tracciato' : '&#x1F3AF; GIOCATO - Traccia questo pronostico'}
                    </button>
                    <button class="btn-dettaglio" onclick="selectMatch(${a.matchId})">&#x1F4CA;</button>
                  </div>
                </div>
              </div>
              `;
            }).join('')}
          </div>
        </div>
      `;
    }
    
    function renderLiveSection() {
      if (state.liveLoading) {
        return `
          <div class="live-section">
            <div class="live-header">
              <div class="live-title"><span class="live-dot"></span> LIVE Alerts</div>
            </div>
            <div class="loading"><div class="spinner"></div><div class="loading-text">Caricamento partite live...</div></div>
          </div>
        `;
      }
      
      const alerts = state.liveAlerts;
      
      return `
        <div class="live-section">
          <div class="live-header">
            <div class="live-title"><span class="live-dot"></span> LIVE Alerts</div>
            <div style="display: flex; align-items: center; gap: 12px;">
              <div class="live-auto-refresh">&#x1F504; Auto-refresh <span class="live-countdown">${state.liveCountdown}s</span></div>
              <button class="live-refresh-btn" id="refreshLive">âŸ³ Aggiorna</button>
            </div>
          </div>
          
          ${alerts.length === 0 ? `
            <div class="live-empty">
              <div class="live-empty-icon">&#x1F4E1;</div>
              <div>Nessun alert al momento</div>
              <div style="font-size: 0.8rem; margin-top: 8px; color: var(--text-dark);">
                ${state.liveMatches.length} partite live monitorate
              </div>
            </div>
          ` : `
            <div class="live-alerts-grid">
              ${alerts.map(alert => `
                <div class="live-alert-card ${alert.level}">
                  <div class="live-alert-header">
                    <div class="live-alert-level">${alert.level === 'high' ? '&#x1F6A8; ALERT ALTO' : alert.level === 'medium' ? 'âš ï¸ ALERT MEDIO' : '&#x1F535; INFO'}</div>
                    <div class="live-alert-time"><span class="live-dot"></span> ${alert.match.elapsed}'</div>
                  </div>
                  <div class="live-alert-body">
                    <div class="live-alert-match">
                      <div class="live-alert-teams">${esc(alert.match.home.name)} vs ${esc(alert.match.away.name)}</div>
                      <div class="live-alert-score">${alert.match.goals.home} - ${alert.match.goals.away}</div>
                    </div>
                    <div class="live-alert-stats">
                      <div class="live-stat">&#x1F3AF; Tiri in porta: <strong>${alert.stats.shotsOnHome || 0}-${alert.stats.shotsOnAway || 0}</strong></div>
                      <div class="live-stat">âš½ Tiri totali: <strong>${alert.stats.shotsHome || 0}-${alert.stats.shotsAway || 0}</strong></div>
                      <div class="live-stat">&#x1F6A9; Corner: <strong>${alert.stats.cornersHome || 0}-${alert.stats.cornersAway || 0}</strong></div>
                      <div class="live-stat">&#x1F4CA; Possesso: <strong>${alert.stats.possessionHome || 50}%-${alert.stats.possessionAway || 50}%</strong></div>
                    </div>
                    <div class="live-alert-pick">
                      <div class="live-pick-label">CONSIGLIO LIVE</div>
                      <div class="live-pick-value">${alert.pick}</div>
                      <div class="live-pick-details">
                        <span class="live-pick-prob">&#x1F4C8; ${alert.prob}% prob</span>
                        <span style="color: var(--accent-yellow);">&#x1F4B0; ~@${alert.quota}</span>
                      </div>
                      <div class="live-pick-reason">&#x1F4A1; ${alert.reason}</div>
                      <button class="live-track-btn ${state.trackedBets.some(b => b.matchId === alert.match.id && b.isLive) ? 'tracked' : ''}"
                              onclick="trackLiveBet(${alert.match.id}, '${esc(alert.match.home.name)} vs ${esc(alert.match.away.name)}', '${esc(alert.pick)}', ${alert.prob}, ${alert.quota}, event)"
                              ${state.trackedBets.some(b => b.matchId === alert.match.id && b.isLive) ? 'disabled' : ''}>
                        ${state.trackedBets.some(b => b.matchId === alert.match.id && b.isLive) ? 'âœ… Tracciato' : '&#x1F3AF; GIOCATO'}
                      </button>
                    </div>
                  </div>
                </div>
              `).join('')}
            </div>
          `}
          
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
            <div style="font-size: 0.8rem; color: var(--text-dark); margin-bottom: 8px;">&#x1F4CA; Statistiche Monitorate</div>
            <div style="display: flex; gap: 16px; flex-wrap: wrap; font-size: 0.85rem; color: var(--text-gray);">
              <span>&#x1F534; Partite LIVE: <strong style="color: var(--text-white);">${state.liveMatches.length}</strong></span>
              <span>&#x1F6A8; Alert Alti: <strong style="color: var(--accent-red);">${alerts.filter(a => a.level === 'high').length}</strong></span>
              <span>âš ï¸ Alert Medi: <strong style="color: var(--accent-yellow);">${alerts.filter(a => a.level === 'medium').length}</strong></span>
            </div>
          </div>
        </div>
      `;
    }

    function renderMatches() {
      const matches = state.matches.filter(m => m.league.id === state.selectedLeague.id).sort((a, b) => a.timestamp - b.timestamp);
      
      return `
        <div class="back-btn" id="backToLeagues" onclick="backToLeagues()">â† Campionati</div>
        <div class="panel">
          <div class="panel-title">âš½ ${esc(state.selectedLeague.country)} - ${esc(state.selectedLeague.name)}</div>
          <div class="matches-list">
            ${matches.map(m => {
              const isLive = ['1H','2H','HT','ET','P','LIVE'].includes(m.status);
              return `
                <div class="match-item" data-id="${m.id}">
                  <div class="match-item-left">
                    <div class="match-item-time">${isLive ? m.elapsed+"'" : formatTime(m.date)}</div>
                    <div class="match-item-teams">${esc(m.home.name)} vs ${esc(m.away.name)}</div>
                  </div>
                  <div class="match-item-badge ${isLive ? 'live' : ''}">${isLive ? 'LIVE' : formatDate(m.date)}</div>
                </div>
              `;
            }).join('')}
          </div>
        </div>
      `;
    }

    function renderAnalysis() {
      const m = state.selectedMatch;
      const d = state.analysis;
      if (!d) return `<div class="back-btn" id="backToMatches" onclick="backToMatches()">â† Partite</div><div class="empty">Errore analisi</div>`;
      
      // Genera consiglio AI
      const ai = generateAIAdvice(m, d);
      const stat = generateStatisticalAdvice(m, d);

      return `
        <div class="analizza-btn-area">
          <div class="back-btn" id="backToMatches" onclick="backToMatches()" style="margin-bottom:0">â† Partite</div>
          <button class="analizza-btn ${state.superAnalysisRunning ? 'loading' : ''}" id="analizzaBtn" onclick="triggerSuperAnalysis()">
            ${state.superAnalysisRunning ? '&#9203; Analisi in corso...' : '&#128302; ANALIZZA con Super AI'}
          </button>
        </div>
        
        ${state.superAnalysis ? renderSuperAnalysis(state.superAnalysis, m) : ''}
        
        <div class="analysis-hero">
          <div class="hero-league">${esc(m.league.country)} â€¢ ${esc(m.league.name)} â€¢ ${formatDateFull(m.date)} ${formatTime(m.date)}</div>
          <div class="hero-match">
            <div class="hero-team">
              ${m.home.logo ? `<img src="${m.home.logo}" class="hero-team-logo" onerror="this.style.display='none'">` : `<div class="hero-team-logo-fallback">${getInitials(m.home.name)}</div>`}
              <div class="hero-team-name">${esc(m.home.name)}</div>
            </div>
            <div class="hero-prediction">
              <div class="hero-score-box">${d.exactScores[0].h}</div>
              <div class="hero-vs">VS</div>
              <div class="hero-score-box">${d.exactScores[0].a}</div>
            </div>
            <div class="hero-team">
              ${m.away.logo ? `<img src="${m.away.logo}" class="hero-team-logo" onerror="this.style.display='none'">` : `<div class="hero-team-logo-fallback">${getInitials(m.away.name)}</div>`}
              <div class="hero-team-name">${esc(m.away.name)}</div>
            </div>
          </div>
          
          <!-- MG CASA / MG OSPITE sotto risultato esatto previsto -->
          <div class="hero-mg-section">
            <div class="hero-mg-box">
              <div class="hero-mg-label">&#x1F3E0; MG ${m.home.name.split(' ')[0]}</div>
              <div class="hero-mg-value">${d.multigoalHome ? d.multigoalHome.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).range : 'N/A'}</div>
              <div class="hero-mg-prob">${d.multigoalHome ? d.multigoalHome.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).prob.toFixed(0) : 0}%</div>
            </div>
            <div class="hero-mg-box">
              <div class="hero-mg-label">âœˆï¸ MG ${m.away.name.split(' ')[0]}</div>
              <div class="hero-mg-value">${d.multigoalAway ? d.multigoalAway.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).range : 'N/A'}</div>
              <div class="hero-mg-prob">${d.multigoalAway ? d.multigoalAway.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).prob.toFixed(0) : 0}%</div>
            </div>
          </div>
        </div>
        
        <!-- DUAL ADVICE: AI + STATISTICAL -->
        <div class="dual-advice-container">

          <!-- AI CONSIGLIO -->
          <div class="ai-advice">
          <div class="ai-header">
            <div class="ai-icon">&#x1F916;</div>
            <div class="ai-title-group">
              <div class="ai-title">Consiglio AI</div>
              <div class="ai-subtitle">Analisi basata su xG, statistiche e probabilitÃ </div>
            </div>
            <div class="ai-confidence ${ai.confidence}">${ai.confidence === 'high' ? '&#x1F3AF; Alta' : ai.confidence === 'medium' ? 'âœ“ Media' : 'âš ï¸ Bassa'}</div>
          </div>
          
          <div class="ai-pick">
            <div class="ai-pick-label">Pronostico Consigliato</div>
            <div class="ai-pick-value">${ai.pick}</div>
            <div class="ai-pick-prob">${ai.prob.toFixed(0)}% probabilitÃ </div>
          </div>
          
          <div class="ai-reasoning">
            <div class="ai-reasoning-title">&#x1F4A1; PerchÃ© questo pronostico</div>
            <div class="ai-reasoning-list">
              ${ai.reasons.map(r => `
                <div class="ai-reason ${r.type}">
                  <span class="ai-reason-icon">${r.type === 'positive' ? 'âœ…' : r.type === 'negative' ? 'âš ï¸' : '&#x1F4CA;'}</span>
                  <span>${r.text}</span>
                </div>
              `).join('')}
            </div>
          </div>
          
          ${ai.alternatives.length > 0 ? `
            <div class="ai-alternatives">
              <div class="ai-alt-title">Alternative valide:</div>
              <div class="ai-alt-grid">
                ${ai.alternatives.map(a => `
                  <div class="ai-alt-chip">${a.pick}<span>${a.prob}%</span></div>
                `).join('')}
              </div>
            </div>
          ` : ''}
          
          <button class="track-btn ${state.trackedBets.some(b => b.matchId === m.id && b.type === 'prematch') ? 'tracked' : ''}" 
                  onclick="trackPrematchBet(${m.id}, '${esc(m.home.name)} vs ${esc(m.away.name)}', '${esc(ai.pick)}', ${ai.prob.toFixed(0)}, event)"
                  ${state.trackedBets.some(b => b.matchId === m.id && b.type === 'prematch') ? 'disabled' : ''}>
            ${state.trackedBets.some(b => b.matchId === m.id && b.type === 'prematch') ? 'âœ… Pronostico Tracciato' : '&#x1F3AF; GIOCATO - Traccia questo pronostico'}
          </button>
        </div>

        <!-- PRONOSTICO STATISTICO -->
        <div class="statistical-advice">
          <div class="ai-header">
            <div class="ai-icon">&#x1F4CA;</div>
            <div class="ai-title-group">
              <div class="ai-title" style="background: linear-gradient(135deg, var(--accent-cyan), var(--accent-green)); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Pronostico Statistico</div>
              <div class="ai-subtitle">Basato solo sulla probabilitÃ  piÃ¹ alta</div>
            </div>
            <div class="ai-confidence ${stat.confidence}">${stat.confidence === 'high' ? '&#x1F3AF; Alta' : stat.confidence === 'medium' ? 'âœ“ Media' : 'âš ï¸ Bassa'}</div>
          </div>

          <div class="ai-pick">
            <div class="ai-pick-label">Pronostico con Prob. Massima</div>
            <div class="ai-pick-value">${stat.pick}</div>
            <div class="ai-pick-prob">${stat.prob.toFixed(0)}% probabilitÃ </div>
          </div>

          <div class="ai-reasoning">
            <div class="ai-reasoning-title">&#x1F4C8; Dettagli Statistici</div>
            <div class="ai-reasoning-list">
              <div class="ai-reason positive">
                <span class="ai-reason-icon">âœ…</span>
                <span>Mercato: ${stat.market}</span>
              </div>
              <div class="ai-reason positive">
                <span class="ai-reason-icon">&#x1F4CA;</span>
                <span>ProbabilitÃ  piÃ¹ alta tra tutti i pronostici</span>
              </div>
              <div class="ai-reason neutral">
                <span class="ai-reason-icon">&#x1F522;</span>
                <span>Basato su calcoli Poisson e xG</span>
              </div>
            </div>
          </div>

          ${stat.alternatives.length > 0 ? `
            <div class="ai-alternatives">
              <div class="ai-alt-title">Top 3 alternative:</div>
              <div class="ai-alt-grid">
                ${stat.alternatives.map(a => `
                  <div class="ai-alt-chip">${a.pick}<span>${a.prob}%</span></div>
                `).join('')}
              </div>
            </div>
          ` : ''}
        </div>

      </div>
      
      <!-- TRADER VERDICT -->
      ${renderTraderVerdict(ai, stat, d)}
      
      <!-- STORICO VARIAZIONI -->
      ${renderHistorySection(m.id)}
      
        <div class="combo-panel">
          <div class="combo-title">&#x1F525; Combo Suggerite</div>
          <div class="combo-grid">
            ${d.combos.map(c => `
              <div class="combo-card ${isInSlip(m.id, 'combo_'+c.value) ? 'selected' : ''}" data-market="combo_${c.value}" data-value="${c.value}" data-prob="${c.prob.toFixed(0)}">
                <div class="combo-value">${c.value}</div>
                <div class="combo-stats">
                  <span class="combo-prob">${c.prob.toFixed(0)}%</span>
                  <span class="combo-odds">@${c.odds}</span>
                </div>
              </div>
            `).join('')}
          </div>
        </div>
        
        <div class="analysis-grid">
          <div class="analysis-card">
            <div class="card-title">
              <div class="card-title-icon">&#x1F4CA;</div>
              <span>Expected Goals</span>
              <span class="card-title-badge">${d.xG.total.toFixed(2)}</span>
            </div>
            <div class="prob-row">
              <span class="prob-label">${m.home.name.split(' ')[0]}</span>
              <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${(d.xG.home/3)*100}%"></div></div>
              <span class="prob-value">${d.xG.home.toFixed(2)}</span>
            </div>
            <div class="prob-row">
              <span class="prob-label">${m.away.name.split(' ')[0]}</span>
              <div class="prob-bar-track"><div class="prob-bar-fill green" style="width:${(d.xG.away/3)*100}%"></div></div>
              <span class="prob-value">${d.xG.away.toFixed(2)}</span>
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">&#x1F3AF;</div><span>1X2</span></div>
            <div class="prob-row">
              <span class="prob-label">1 Casa</span>
              <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${d.p1X2.home}%"></div></div>
              <span class="prob-value">${d.p1X2.home.toFixed(0)}%</span>
            </div>
            <div class="prob-row">
              <span class="prob-label">X Pari</span>
              <div class="prob-bar-track"><div class="prob-bar-fill yellow" style="width:${d.p1X2.draw}%"></div></div>
              <span class="prob-value">${d.p1X2.draw.toFixed(0)}%</span>
            </div>
            <div class="prob-row">
              <span class="prob-label">2 Ospite</span>
              <div class="prob-bar-track"><div class="prob-bar-fill purple" style="width:${d.p1X2.away}%"></div></div>
              <span class="prob-value">${d.p1X2.away.toFixed(0)}%</span>
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">âš½</div><span>Over/Under & GG</span></div>
            ${[1.5, 2.5, 3.5].map(l => `
              <div class="prob-row">
                <span class="prob-label">O/U ${l}</span>
                <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${d.pOU[l].over}%"></div></div>
                <span class="prob-value">${d.pOU[l].over.toFixed(0)}%</span>
              </div>
            `).join('')}
            <div class="prob-row">
              <span class="prob-label">GG</span>
              <div class="prob-bar-track"><div class="prob-bar-fill green" style="width:${d.pBTTS}%"></div></div>
              <span class="prob-value">${d.pBTTS.toFixed(0)}%</span>
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">&#x1F6A9;</div><span>Corner</span></div>
            <div class="stat-grid">
              <div class="stat-box"><div class="stat-box-label">Casa</div><div class="stat-box-value">${d.corners.home.toFixed(1)}</div><div class="stat-box-sub">media</div></div>
              <div class="stat-box"><div class="stat-box-label">Tot</div><div class="stat-box-value">${d.corners.total.toFixed(1)}</div><div class="stat-box-sub">media</div></div>
              <div class="stat-box"><div class="stat-box-label">Ospite</div><div class="stat-box-value">${d.corners.away.toFixed(1)}</div><div class="stat-box-sub">media</div></div>
            </div>
            <div class="ou-lines" style="margin-top: 12px;">
              ${d.corners.probs ? Object.entries(d.corners.probs).map(([line, p]) => `
                <div class="ou-line-row">
                  <span class="ou-line-label">Corner ${line}</span>
                  <span class="ou-line-over ${p.over >= 55 ? 'highlight' : ''}">O ${p.over.toFixed(0)}%</span>
                  <span class="ou-line-under ${p.under >= 55 ? 'highlight' : ''}">U ${p.under.toFixed(0)}%</span>
                </div>
              `).join('') : ''}
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">&#x1F7E8;</div><span>Cartellini</span></div>
            <div class="stat-grid">
              <div class="stat-box"><div class="stat-box-label">Casa</div><div class="stat-box-value">${d.cards.home.toFixed(1)}</div><div class="stat-box-sub">media</div></div>
              <div class="stat-box"><div class="stat-box-label">Tot</div><div class="stat-box-value">${d.cards.total.toFixed(1)}</div><div class="stat-box-sub">media</div></div>
              <div class="stat-box"><div class="stat-box-label">Ospite</div><div class="stat-box-value">${d.cards.away.toFixed(1)}</div><div class="stat-box-sub">media</div></div>
            </div>
            <div class="ou-lines" style="margin-top: 12px;">
              ${d.cards.probs ? Object.entries(d.cards.probs).map(([line, p]) => `
                <div class="ou-line-row">
                  <span class="ou-line-label">Carte ${line}</span>
                  <span class="ou-line-over ${p.over >= 55 ? 'highlight' : ''}">O ${p.over.toFixed(0)}%</span>
                  <span class="ou-line-under ${p.under >= 55 ? 'highlight' : ''}">U ${p.under.toFixed(0)}%</span>
                </div>
              `).join('') : ''}
            </div>
          </div>
          
          <!-- SEZIONE SCOMMESSE SPECIALI -->
          <div class="analysis-card wide">
            <div class="card-title"><div class="card-title-icon">&#x1F3B0;</div><span>Multigoal Range</span></div>
            <div class="multigoal-grid">
              ${d.multigoal ? d.multigoal.slice(0, 6).map((mg, i) => `
                <div class="multigoal-box ${i === 0 ? 'best' : ''}">
                  <div class="multigoal-range">${mg.range}</div>
                  <div class="multigoal-prob">${mg.prob.toFixed(0)}%</div>
                  <div class="multigoal-quota">@${mg.quota}</div>
                </div>
              `).join('') : '<div>N/A</div>'}
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">â±ï¸</div><span>Gol per Tempo</span></div>
            ${d.temporalDistribution ? `
              <div class="prob-row">
                <span class="prob-label">Over 0.5 1Â°T</span>
                <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${d.temporalDistribution.primoTempo.over05}%"></div></div>
                <span class="prob-value">${d.temporalDistribution.primoTempo.over05.toFixed(0)}%</span>
              </div>
              <div class="prob-row">
                <span class="prob-label">Over 0.5 2Â°T</span>
                <div class="prob-bar-track"><div class="prob-bar-fill green" style="width:${d.temporalDistribution.secondoTempo.over05}%"></div></div>
                <span class="prob-value">${d.temporalDistribution.secondoTempo.over05.toFixed(0)}%</span>
              </div>
              <div class="prob-row">
                <span class="prob-label">Over 1.5 1Â°T</span>
                <div class="prob-bar-track"><div class="prob-bar-fill yellow" style="width:${d.temporalDistribution.primoTempo.over15}%"></div></div>
                <span class="prob-value">${d.temporalDistribution.primoTempo.over15.toFixed(0)}%</span>
              </div>
              <div class="tempo-highlight">
                <span>âš¡ Tempo con piÃ¹ gol:</span>
                <strong>${d.temporalDistribution.tempoConPiuGol}</strong>
                <span class="tempo-prob">(${d.temporalDistribution.probTempoConPiuGol.toFixed(0)}%)</span>
              </div>
            ` : '<div>N/A</div>'}
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">&#x1F3E0;</div><span>MG ${m.home.name.split(' ')[0]}</span></div>
            ${d.multigoalHome ? d.multigoalHome.map(mg => `
              <div class="prob-row">
                <span class="prob-label">${mg.range} gol</span>
                <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${mg.prob}%"></div></div>
                <span class="prob-value">${mg.prob.toFixed(0)}%</span>
              </div>
            `).join('') : '<div>N/A</div>'}
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">âœˆï¸</div><span>MG ${m.away.name.split(' ')[0]}</span></div>
            ${d.multigoalAway ? d.multigoalAway.map(mg => `
              <div class="prob-row">
                <span class="prob-label">${mg.range} gol</span>
                <div class="prob-bar-track"><div class="prob-bar-fill purple" style="width:${mg.prob}%"></div></div>
                <span class="prob-value">${mg.prob.toFixed(0)}%</span>
              </div>
            `).join('') : '<div>N/A</div>'}
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">&#x1F4C8;</div><span>Forma + MG Consigliato</span></div>
            <div class="form-display">
              <div class="form-team">
                <span class="form-team-name">${m.home.name.split(' ')[0]}</span>
                <span class="form-string">${d.homeForm ? d.homeForm.split('').map(c => 
                  c === 'W' ? '<span class="form-w">V</span>' : 
                  c === 'D' ? '<span class="form-d">P</span>' : 
                  '<span class="form-l">S</span>'
                ).join('') : 'N/A'}</span>
              </div>
              <div class="form-team">
                <span class="form-team-name">${m.away.name.split(' ')[0]}</span>
                <span class="form-string">${d.awayForm ? d.awayForm.split('').map(c => 
                  c === 'W' ? '<span class="form-w">V</span>' : 
                  c === 'D' ? '<span class="form-d">P</span>' : 
                  '<span class="form-l">S</span>'
                ).join('') : 'N/A'}</span>
              </div>
            </div>
            <!-- MG PIÃ™ PROBABILE -->
            <div style="display: flex; gap: 10px; margin-top: 12px;">
              <div class="mg-best-box" style="flex:1">
                <div class="mg-best-label">&#x1F3E0; MG ${m.home.name.split(' ')[0]}</div>
                <div class="mg-best-value">${d.multigoalHome ? d.multigoalHome.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).range : 'N/A'}</div>
                <div class="mg-best-prob">${d.multigoalHome ? d.multigoalHome.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).prob.toFixed(0) : 0}%</div>
              </div>
              <div class="mg-best-box" style="flex:1">
                <div class="mg-best-label">âœˆï¸ MG ${m.away.name.split(' ')[0]}</div>
                <div class="mg-best-value">${d.multigoalAway ? d.multigoalAway.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).range : 'N/A'}</div>
                <div class="mg-best-prob">${d.multigoalAway ? d.multigoalAway.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).prob.toFixed(0) : 0}%</div>
              </div>
            </div>
          </div>
          
          <!-- CLASSIFICA E MOTIVAZIONE -->
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">&#x1F3C6;</div><span>Classifica</span></div>
            ${d.homePosition ? `
              <div class="standings-card">
                <div class="standings-header">
                  <div>
                    <span style="font-weight:600; font-size:0.85rem;">${m.home.name.split(' ')[0]}</span>
                    <span class="standings-position">${d.homePosition.position}Â°<sup>/${d.homePosition.totalTeams}</sup></span>
                  </div>
                  <span class="motivation-badge ${d.homePosition.motivationColor}">${d.homePosition.motivationText}</span>
                </div>
                <div class="standings-stats">
                  <span class="standings-stat">&#x1F4CA; ${d.homePosition.points} pt</span>
                  <span class="standings-stat">âœ… ${d.homePosition.won}V</span>
                  <span class="standings-stat">âž– ${d.homePosition.draw}P</span>
                  <span class="standings-stat">âŒ ${d.homePosition.lost}S</span>
                </div>
              </div>
            ` : '<div class="standings-card"><span style="color:var(--text-dark)">Classifica non disponibile</span></div>'}
            ${d.awayPosition ? `
              <div class="standings-card">
                <div class="standings-header">
                  <div>
                    <span style="font-weight:600; font-size:0.85rem;">${m.away.name.split(' ')[0]}</span>
                    <span class="standings-position">${d.awayPosition.position}Â°<sup>/${d.awayPosition.totalTeams}</sup></span>
                  </div>
                  <span class="motivation-badge ${d.awayPosition.motivationColor}">${d.awayPosition.motivationText}</span>
                </div>
                <div class="standings-stats">
                  <span class="standings-stat">&#x1F4CA; ${d.awayPosition.points} pt</span>
                  <span class="standings-stat">âœ… ${d.awayPosition.won}V</span>
                  <span class="standings-stat">âž– ${d.awayPosition.draw}P</span>
                  <span class="standings-stat">âŒ ${d.awayPosition.lost}S</span>
                </div>
              </div>
            ` : ''}
          </div>
          
          <!-- INFORTUNATI -->
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">&#x1F3E5;</div><span>Assenze</span></div>
            <div class="injuries-card" style="margin-bottom: 8px;">
              <div class="injuries-header">
                <span>&#x1F3E0; ${m.home.name.split(' ')[0]}</span>
              </div>
              ${d.homeInjuries && d.homeInjuries.length > 0 ? `
                <div class="injuries-list">
                  ${d.homeInjuries.slice(0, 5).map(inj => `
                    <span class="injury-chip">âŒ ${inj.player}</span>
                  `).join('')}
                  ${d.homeInjuries.length > 5 ? `<span class="injury-chip">+${d.homeInjuries.length - 5} altri</span>` : ''}
                </div>
              ` : '<span class="no-injuries">âœ… Rosa completa</span>'}
            </div>
            <div class="injuries-card">
              <div class="injuries-header">
                <span>âœˆï¸ ${m.away.name.split(' ')[0]}</span>
              </div>
              ${d.awayInjuries && d.awayInjuries.length > 0 ? `
                <div class="injuries-list">
                  ${d.awayInjuries.slice(0, 5).map(inj => `
                    <span class="injury-chip">âŒ ${inj.player}</span>
                  `).join('')}
                  ${d.awayInjuries.length > 5 ? `<span class="injury-chip">+${d.awayInjuries.length - 5} altri</span>` : ''}
                </div>
              ` : '<span class="no-injuries">âœ… Rosa completa</span>'}
            </div>
          </div>
          
          <div class="analysis-card wide">
            <div class="card-title"><div class="card-title-icon">&#x1F3B2;</div><span>Risultati Esatti</span></div>
            <div class="scores-grid">
              ${d.exactScores.map((s, i) => `
                <div class="score-box ${i === 0 ? 'highlight' : ''}">
                  <div class="score-box-value">${s.h}-${s.a}</div>
                  <div class="score-box-prob">${s.p.toFixed(1)}%</div>
                </div>
              `).join('')}
            </div>
            <!-- MG CASA / MG OSPITE sotto risultati esatti -->
            <div class="mg-under-scores">
              <div class="mg-box-compact">
                <div class="mg-box-label">&#x1F3E0; MG ${m.home.name.split(' ')[0]}</div>
                <div class="mg-box-value">${d.multigoalHome ? d.multigoalHome.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).range : 'N/A'}</div>
                <div class="mg-box-prob">${d.multigoalHome ? d.multigoalHome.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).prob.toFixed(0) : 0}%</div>
              </div>
              <div class="mg-box-compact">
                <div class="mg-box-label">âœˆï¸ MG ${m.away.name.split(' ')[0]}</div>
                <div class="mg-box-value">${d.multigoalAway ? d.multigoalAway.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).range : 'N/A'}</div>
                <div class="mg-box-prob">${d.multigoalAway ? d.multigoalAway.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).prob.toFixed(0) : 0}%</div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="predictions-panel">
          <div class="predictions-header">
            <div class="predictions-title">âš½ PRONOSTICI AI</div>
            <div class="predictions-subtitle">Clicca per aggiungere alla schedina</div>
            <div class="predictions-legend">
              <div class="legend-item"><span class="legend-dot high"></span> Alta (&gt;65%)</div>
              <div class="legend-item"><span class="legend-dot mid"></span> Media (50-65%)</div>
              <div class="legend-item"><span class="legend-dot low"></span> Bassa (&lt;50%)</div>
            </div>
          </div>
          <div class="predictions-grid">
            ${d.predictions.map(p => `
              <div class="prediction-card ${isInSlip(m.id, p.market) ? 'selected' : ''}" data-market="${p.market}" data-value="${p.value}" data-prob="${p.prob.toFixed(0)}">
                <div class="prediction-market">${p.market}</div>
                <div class="prediction-value">${p.value}</div>
                <div class="prediction-prob ${getProbClass(p.prob)}">${p.prob.toFixed(0)}%</div>
              </div>
            `).join('')}
          </div>
        </div>
      `;
    }

    function renderSlipFloating() {
      if (state.slip.length === 0) return '';
      return `
        <div class="slip-floating">
          <div class="slip-count">&#x1F3AB; ${state.slip.length} pronostici</div>
          <button class="slip-btn primary" id="viewSlip">&#x1F4CB; Vedi</button>
          <button class="slip-btn secondary" id="copySlip">&#x1F4CB; Copia</button>
          <button class="slip-btn danger" id="clearSlip">&#x1F5D1;ï¸</button>
        </div>
      `;
    }

    function renderSlipModal() {
      const totalProb = state.slip.reduce((acc, s) => acc * (s.prob / 100), 1) * 100;
      return `
        <div class="slip-modal" id="slipModal">
          <div class="slip-modal-content">
            <div class="slip-modal-header">
              <div class="slip-modal-title">&#x1F3AB; La Tua Schedina</div>
              <button class="slip-modal-close" id="closeSlip">Ã—</button>
            </div>
            <div class="slip-modal-body">
              ${state.slip.map(s => `
                <div class="slip-item">
                  <div class="slip-item-info">
                    <div class="slip-item-match">${esc(s.matchName)}</div>
                    <div class="slip-item-bet">${s.market}: ${s.value}</div>
                    <div class="slip-item-prob">${s.prob}%</div>
                  </div>
                  <button class="slip-item-remove" data-key="${s.key}">Ã—</button>
                </div>
              `).join('')}
              <div class="slip-total">
                <div class="slip-total-label">ProbabilitÃ  Combinata</div>
                <div class="slip-total-value">${totalProb.toFixed(2)}%</div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function attachEvents() {
      // === EVENT DELEGATION - Un solo listener per tutto ===
      const app = document.getElementById('app');
      if (!app) return;
      
      // Handler per tutti i click
      app.onclick = function(e) {
        const target = e.target;
        
        // === BACK BUTTONS (prioritÃ  massima) ===
        const backBtn = target.closest('.back-btn, .btn-secondary, #backToLeagues, #backFromPerformance, #backToMatches');
        if (backBtn) {
          const text = backBtn.textContent || '';
          const id = backBtn.id || '';
          
          // Torna ai campionati
          if (id === 'backToLeagues' || id === 'backFromPerformance' || text.includes('Campionati')) {
            e.preventDefault();
            e.stopPropagation();
            console.log('&#x1F519; Tornando ai campionati...');
            state.view = 'leagues';
            state.selectedLeague = null;
            render();
            return false;
          }
          
          // Torna alle partite
          if (id === 'backToMatches' || text.includes('Partite')) {
            e.preventDefault();
            e.stopPropagation();
            console.log('&#x1F519; Tornando alle partite...');
            state.view = 'matches';
            state.selectedMatch = null;
            state.analysis = null;
            render();
            return false;
          }
        }
        
        // === DATE TABS ===
        const dateTab = target.closest('.date-tab[data-date]');
        if (dateTab) {
          if (state.liveMode) {
            state.liveMode = false;
            stopLiveAutoRefresh();
          }
          state.consigliMode = false;
          loadMatches(parseInt(dateTab.dataset.date));
          return;
        }
        
        // === MATCH ITEMS ===
        const matchItem = target.closest('.match-item[data-id]');
        if (matchItem) {
          const m = state.matches.find(x => x.id === parseInt(matchItem.dataset.id));
          if (m) analyzeMatch(m);
          return;
        }
        
        // === GIOCATO BUTTONS (from home advice cards) ===
        const giocatoBtn = target.closest('.btn-giocato[data-track-matchid]');
        if (giocatoBtn && !giocatoBtn.disabled) {
          const matchId = parseInt(giocatoBtn.dataset.trackMatchid);
          const pick = giocatoBtn.dataset.trackPick;
          const prob = parseFloat(giocatoBtn.dataset.trackProb);
          const match = state.matches.find(m => m.id === matchId);
          const matchName = match ? `${match.home.name} vs ${match.away.name}` : 'Match';
          trackFromHome(matchId, matchName, pick, prob, null);
          return;
        }
        
        // === PICK CARDS ===
        const pickCard = target.closest('.pick-card[data-matchid]');
        if (pickCard) {
          const matchId = parseInt(pickCard.dataset.matchid);
          const match = state.matches.find(m => m.id === matchId);
          if (match) {
            addToSlip(match, pickCard.dataset.market, pickCard.dataset.value, parseFloat(pickCard.dataset.prob));
          }
          return;
        }
        
        // === RADDOPPIO CARDS ===
        const raddoppioCard = target.closest('.raddoppio-card[data-raddoppio]');
        if (raddoppioCard) {
          const idx = parseInt(raddoppioCard.dataset.raddoppio);
          const raddoppio = state.dailyPicks.raddoppi[idx];
          if (raddoppio) {
            raddoppio.bets.forEach(b => {
              addToSlip(b.match, 'radd_' + b.bet, b.bet, b.prob);
            });
          }
          return;
        }
        
        // === PREDICTION/COMBO CARDS ===
        const predCard = target.closest('.prediction-card, .combo-card');
        if (predCard && state.selectedMatch) {
          addToSlip(state.selectedMatch, predCard.dataset.market, predCard.dataset.value, parseFloat(predCard.dataset.prob));
          return;
        }
        
        // === CONSIGLIO CARDS (onclick inline) ===
        const consiglioCard = target.closest('.consiglio-card[onclick]');
        if (consiglioCard) {
          // L'onclick inline gestisce giÃ  questo
          return;
        }
        
        // === SLIP REMOVE ===
        const removeBtn = target.closest('.slip-item-remove[data-key]');
        if (removeBtn) {
          removeFromSlip(removeBtn.dataset.key);
          return;
        }
        
        // === SLIP BUTTONS ===
        if (target.id === 'openSlip' || target.id === 'viewSlip' || target.closest('#openSlip, #viewSlip')) {
          state.slipModal = true;
          render();
          return;
        }
        if (target.id === 'closeSlip' || target.closest('#closeSlip')) {
          state.slipModal = false;
          render();
          return;
        }
        if (target.id === 'clearSlip' || target.closest('#clearSlip')) {
          clearSlip();
          return;
        }
        if (target.id === 'slipModal') {
          state.slipModal = false;
          render();
          return;
        }
        
        // === REFRESH LIVE ===
        if (target.id === 'refreshLive' || target.closest('#refreshLive')) {
          loadLiveMatches();
          return;
        }
        
        // === BET RESULT BUTTONS ===
        if (target.id === 'betWin' || target.closest('#betWin')) {
          recordBetResult(true);
          return;
        }
        if (target.id === 'betLoss' || target.closest('#betLoss')) {
          recordBetResult(false);
          return;
        }
        if (target.id === 'betReset' || target.closest('#betReset')) {
          resetMoney();
          return;
        }
        
        // === COPY SLIP ===
        if (target.id === 'copySlip' || target.closest('#copySlip')) {
          const text = state.slip.map(s => `${s.matchName}: ${s.market} ${s.value} (${s.prob}%)`).join('\n');
          navigator.clipboard.writeText(text);
          alert('Schedina copiata!');
          return;
        }
      };
      
      // === CHANGE EVENTS (devono essere attaccati singolarmente) ===
      const leagueSelect = document.getElementById('leagueSelect');
      if (leagueSelect) {
        leagueSelect.onchange = function(e) {
          const id = parseInt(e.target.value);
          if (id) {
            state.selectedLeague = state.leagues.find(l => l.id === id);
            state.view = 'matches';
            render();
          }
        };
      }
      
      const bankrollInput = document.getElementById('bankrollInput');
      if (bankrollInput) {
        bankrollInput.onchange = function(e) {
          state.money.bankroll = parseFloat(e.target.value) || 100;
          saveMoney();
          render();
        };
      }
      
      const targetInput = document.getElementById('targetInput');
      if (targetInput) {
        targetInput.onchange = function(e) {
          state.money.target = parseFloat(e.target.value) || 500;
          saveMoney();
          render();
        };
      }
      
      const totalBetsInput = document.getElementById('totalBetsInput');
      if (totalBetsInput) {
        totalBetsInput.onchange = function(e) {
          state.money.totalBets = parseInt(e.target.value) || 10;
          saveMoney();
          render();
        };
      }
      
      const oddsInput = document.getElementById('oddsInput');
      if (oddsInput) {
        oddsInput.onchange = function(e) {
          state.money.currentOdds = parseFloat(e.target.value) || 1.80;
          saveMoney();
          render();
        };
      }
    }

    // === GLOBAL FUNCTIONS (for inline onclick handlers) ===
    window.addToSlip = addToSlip;   // usato in super pick cards onclick inline
    window.state = state;            // accessibile da onclick inline
    window.selectMatch = selectMatch;
    window.toggleSettingsPanel = toggleSettingsPanel;
    window.showPerformance = showPerformance;
    window.toggleSetting = toggleSetting;
    window.backToLeagues = backToLeagues;
    window.backToMatches = backToMatches;
    window.manualVerifyBets = manualVerifyBets;
    window.trackFromHome = trackFromHome;
    window.trackLiveBet = trackLiveBet;
    window.trackPrematchBet = trackPrematchBet;
    window.resetAllData = resetAllData;
    window.toggleConsigliMode = toggleConsigliMode;
    window.loadLiveMatches = loadLiveMatches;
    window.triggerSuperAnalysis = triggerSuperAnalysis;
    
    // === AUTH GLOBAL FUNCTIONS ===
    window.firebaseLogin = firebaseLogin;
    window.firebaseLogout = firebaseLogout;
    window.firebaseRegister = firebaseRegister;
    window.toggleLoginModal = toggleLoginModal;
    window.handleLogin = handleLogin;
    window.handleRegister = handleRegister;
    
    // === INIT ===
    async function init() {
      console.log('&#x1F680; BettingPro v6 + Firebase Auth starting...');
      
      // Ripristina sessione se salvata
      const sessionRestored = await restoreAuthSession();
      console.log(`&#x1F464; User ID: ${USER_ID} ${sessionRestored ? '(session restored)' : '(local)'}`);
      
      // Mostra interfaccia subito con dati localStorage
      loadSlipFromLocalStorage();
      render();
      
      // Carica dati da Firebase in background (non bloccante)
      Promise.all([
        loadTrackingFromLocalStorage(),
        loadMLThresholdsFromCloud(),
        loadMLStatsFromCloud(),
        loadPerformanceHistoryFromCloud()
      ]).then(() => {
        console.log('âœ… Dati utente caricati da cloud');
        // Aggiorna ML stats con i dati tracciati
        if (state.trackedBets.length >= 5) {
          updateMLFromResults();
        }
        render(); // Re-render con dati Firebase
      }).catch(e => console.warn('Cloud data load partial failure:', e));
      
      // Check API status in background (non bloccante)
      checkAPIStatus().catch(e => console.warn('API check failed:', e));
      
      // Carica partite
      try {
        await loadMatches(0);
      } catch (e) {
        console.error('Load matches failed:', e);
        state.loading = false;
        render();
      }
      
      // Verifica automatica risultati pronostici pendenti (non bloccante)
      autoVerifyPendingBets().catch(e => console.warn('Auto-verify failed:', e));
      
      // Controlla risultati ogni 10 minuti
      setInterval(() => {
        autoVerifyPendingBets().catch(e => console.warn('Auto-verify interval failed:', e));
      }, 10 * 60 * 1000);
      
      // Sync con Firebase ogni 5 minuti (backup automatico)
      setInterval(() => {
        if (firebaseEnabled) {
          console.log('&#x1F504; Sync automatico con Firebase...');
          saveToFirebase('trackedBets', state.trackedBets).catch(e => console.warn('Auto-sync failed:', e));
          saveToFirebase('mlThresholds', state.mlThresholds).catch(e => console.warn('Auto-sync ML failed:', e));
          saveToFirebase('mlStats', state.mlStats).catch(e => console.warn('Auto-sync mlStats failed:', e));
          saveToFirebase('performanceHistory', state.performanceHistory).catch(e => console.warn('Auto-sync perf failed:', e));
        }
      }, 5 * 60 * 1000);
    }

    init();
  </script>
</body>
</html>


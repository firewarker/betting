<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¯ PRO BETTING SYSTEM V2 | All Leagues</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; }
        .loader { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .pulse { animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .tab-active { border-bottom: 3px solid #10b981; color: #10b981; background: #ecfdf5; }
        .hot { animation: glow 2s infinite; }
        @keyframes glow { 0%, 100% { box-shadow: 0 0 5px #10b981; } 50% { box-shadow: 0 0 20px #10b981; } }
        select { max-width: 100%; }
    </style>
</head>
<body class="bg-gray-100">
    <div id="root"></div>

    <script>
        // ============================================================
        // ğŸ¯ PRO BETTING SYSTEM V2 - ALL LEAGUES
        // ============================================================

        const PROXY = (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`;
        const FD_API = 'https://api.football-data.org/v4';
        const DB_KEY = 'proBettingHistoryV2';

        // ============================================================
        // ğŸ“Š TUTTI I CAMPIONATI DISPONIBILI (12 competizioni FREE)
        // ============================================================
        const LEAGUES = {
            // ğŸ† TOP 5 EUROPEI
            SA: { 
                name: "Serie A", 
                country: "Italia",
                flag: "ğŸ‡®ğŸ‡¹", 
                category: "top5",
                avgGoals: 2.72, avgHomeGoals: 1.51, avgAwayGoals: 1.21, 
                avgCorners: 10.3, avgCards: 4.2,
                homeWinRate: 45, drawRate: 25, awayWinRate: 30
            },
            PL: { 
                name: "Premier League", 
                country: "Inghilterra",
                flag: "ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿", 
                category: "top5",
                avgGoals: 2.88, avgHomeGoals: 1.58, avgAwayGoals: 1.30, 
                avgCorners: 10.8, avgCards: 3.6,
                homeWinRate: 43, drawRate: 24, awayWinRate: 33
            },
            PD: { 
                name: "La Liga", 
                country: "Spagna",
                flag: "ğŸ‡ªğŸ‡¸", 
                category: "top5",
                avgGoals: 2.58, avgHomeGoals: 1.45, avgAwayGoals: 1.13, 
                avgCorners: 9.9, avgCards: 4.8,
                homeWinRate: 47, drawRate: 26, awayWinRate: 27
            },
            BL1: { 
                name: "Bundesliga", 
                country: "Germania",
                flag: "ğŸ‡©ğŸ‡ª", 
                category: "top5",
                avgGoals: 3.12, avgHomeGoals: 1.72, avgAwayGoals: 1.40, 
                avgCorners: 10.6, avgCards: 3.5,
                homeWinRate: 44, drawRate: 22, awayWinRate: 34
            },
            FL1: { 
                name: "Ligue 1", 
                country: "Francia",
                flag: "ğŸ‡«ğŸ‡·", 
                category: "top5",
                avgGoals: 2.68, avgHomeGoals: 1.48, avgAwayGoals: 1.20, 
                avgCorners: 10.1, avgCards: 4.0,
                homeWinRate: 46, drawRate: 25, awayWinRate: 29
            },
            
            // ğŸ¥ˆ SECONDE LEGHE & ALTRI CAMPIONATI
            ELC: { 
                name: "Championship", 
                country: "Inghilterra",
                flag: "ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿", 
                category: "second",
                avgGoals: 2.75, avgHomeGoals: 1.52, avgAwayGoals: 1.23, 
                avgCorners: 10.5, avgCards: 3.8,
                homeWinRate: 44, drawRate: 26, awayWinRate: 30
            },
            DED: { 
                name: "Eredivisie", 
                country: "Olanda",
                flag: "ğŸ‡³ğŸ‡±", 
                category: "second",
                avgGoals: 3.20, avgHomeGoals: 1.78, avgAwayGoals: 1.42, 
                avgCorners: 10.2, avgCards: 4.0,
                homeWinRate: 47, drawRate: 22, awayWinRate: 31
            },
            PPL: { 
                name: "Primeira Liga", 
                country: "Portogallo",
                flag: "ğŸ‡µğŸ‡¹", 
                category: "second",
                avgGoals: 2.65, avgHomeGoals: 1.50, avgAwayGoals: 1.15, 
                avgCorners: 9.8, avgCards: 4.5,
                homeWinRate: 48, drawRate: 24, awayWinRate: 28
            },
            BSA: { 
                name: "Serie A", 
                country: "Brasile",
                flag: "ğŸ‡§ğŸ‡·", 
                category: "second",
                avgGoals: 2.45, avgHomeGoals: 1.42, avgAwayGoals: 1.03, 
                avgCorners: 9.5, avgCards: 4.8,
                homeWinRate: 50, drawRate: 26, awayWinRate: 24
            },
            
            // ğŸ† COPPE EUROPEE & NAZIONALI
            CL: { 
                name: "Champions League", 
                country: "Europa",
                flag: "ğŸ†", 
                category: "cups",
                avgGoals: 2.95, avgHomeGoals: 1.62, avgAwayGoals: 1.33, 
                avgCorners: 10.8, avgCards: 3.2,
                homeWinRate: 46, drawRate: 23, awayWinRate: 31
            },
            EC: { 
                name: "Europei", 
                country: "Europa",
                flag: "ğŸ‡ªğŸ‡º", 
                category: "cups",
                avgGoals: 2.35, avgHomeGoals: 1.30, avgAwayGoals: 1.05, 
                avgCorners: 9.5, avgCards: 3.0,
                homeWinRate: 42, drawRate: 28, awayWinRate: 30
            },
            WC: { 
                name: "Mondiali", 
                country: "Mondo",
                flag: "ğŸŒ", 
                category: "cups",
                avgGoals: 2.55, avgHomeGoals: 1.40, avgAwayGoals: 1.15, 
                avgCorners: 9.8, avgCards: 3.5,
                homeWinRate: 44, drawRate: 26, awayWinRate: 30
            }
        };

        // Categorie per il selettore
        const CATEGORIES = {
            top5: { name: "ğŸ† Top 5 Europei", leagues: ['SA', 'PL', 'PD', 'BL1', 'FL1'] },
            second: { name: "ğŸ¥ˆ Altri Campionati", leagues: ['ELC', 'DED', 'PPL', 'BSA'] },
            cups: { name: "ğŸ† Coppe", leagues: ['CL', 'EC', 'WC'] }
        };

        let state = {
            apiKey: localStorage.getItem('footballDataApiKey') || '',
            showSetup: !localStorage.getItem('footballDataApiKey'),
            selectedLeague: 'SA',
            selectedCategory: 'top5',
            matches: [],
            loading: false,
            error: null,
            activeTab: 'matches',
            selectedMatch: null,
            analysisData: null,
            isAnalyzing: false,
            analysisStep: '',
            externalData: {
                homeCorners: '', awayCorners: '',
                homeCards: '', awayCards: '',
                h2hCorners: '', h2hCards: '',
                refereeCards: '',
                homeAbsences: '', awayAbsences: '',
                homeForm: '', awayForm: '',
                hunterBetTip: '', hunterBetConfidence: ''
            },
            showExternalInput: false,
            minConfidence: 60,
            history: JSON.parse(localStorage.getItem(DB_KEY) || '[]'),
            historyFilter: 'all'
        };

        // ============================================================
        // FUNZIONI MATEMATICHE
        // ============================================================

        function factorial(n) {
            if (n <= 1) return 1;
            let r = 1;
            for (let i = 2; i <= n; i++) r *= i;
            return r;
        }

        function poisson(lambda, k) {
            if (lambda <= 0) return k === 0 ? 1 : 0;
            return (Math.pow(lambda, k) * Math.exp(-lambda)) / factorial(k);
        }

        function probToScore(lambda) {
            return (1 - Math.exp(-lambda)) * 100;
        }

        function poissonOver(lambda, threshold) {
            let under = 0;
            for (let k = 0; k <= Math.floor(threshold); k++) {
                under += poisson(lambda, k);
            }
            return (1 - under) * 100;
        }

        function bivariatePoissonOver(lambdaH, lambdaA, threshold) {
            let probUnder = 0;
            const max = Math.floor(threshold);
            for (let h = 0; h <= max; h++) {
                for (let a = 0; a <= max - h; a++) {
                    if (h + a <= max) {
                        probUnder += poisson(lambdaH, h) * poisson(lambdaA, a);
                    }
                }
            }
            return (1 - probUnder) * 100;
        }

        function calculate1X2(lambdaH, lambdaA) {
            let home = 0, draw = 0, away = 0;
            for (let h = 0; h <= 10; h++) {
                for (let a = 0; a <= 10; a++) {
                    const prob = poisson(lambdaH, h) * poisson(lambdaA, a);
                    if (h > a) home += prob;
                    else if (h === a) draw += prob;
                    else away += prob;
                }
            }
            return { home: home * 100, draw: draw * 100, away: away * 100 };
        }

        function calculateLambda(attack, oppDefense, leagueAvg, isHome, formFactor = 1, absenceFactor = 1) {
            const attackStrength = attack / leagueAvg;
            const defenseWeakness = oppDefense / leagueAvg;
            let lambda = leagueAvg * attackStrength * defenseWeakness;
            lambda *= isHome ? 1.12 : 0.88;
            lambda *= formFactor;
            lambda *= absenceFactor;
            return Math.max(0.3, Math.min(4.0, lambda));
        }

        // ============================================================
        // ANALISI MERCATI
        // ============================================================

        function analyzeAllMarkets(homeStats, awayStats, league, extData) {
            const ld = LEAGUES[league];
            
            let homeFormFactor = 1, awayFormFactor = 1;
            if (extData.homeForm) homeFormFactor = 0.7 + (parseFloat(extData.homeForm) / 10) * 0.6;
            if (extData.awayForm) awayFormFactor = 0.7 + (parseFloat(extData.awayForm) / 10) * 0.6;
            
            let homeAbsenceFactor = 1, awayAbsenceFactor = 1;
            if (extData.homeAbsences) homeAbsenceFactor = Math.max(0.7, 1 - parseInt(extData.homeAbsences) * 0.05);
            if (extData.awayAbsences) awayAbsenceFactor = Math.max(0.7, 1 - parseInt(extData.awayAbsences) * 0.05);
            
            const homeLambda = calculateLambda(homeStats.avgGoalsFor, awayStats.avgGoalsAgainst, ld.avgHomeGoals, true, homeFormFactor, homeAbsenceFactor);
            const awayLambda = calculateLambda(awayStats.avgGoalsFor, homeStats.avgGoalsAgainst, ld.avgAwayGoals, false, awayFormFactor, awayAbsenceFactor);
            const totalLambda = homeLambda + awayLambda;
            
            // 1X2
            const result1X2 = calculate1X2(homeLambda, awayLambda);
            const adj1X2 = {
                home: result1X2.home * 0.7 + (homeStats.homeWinRate || ld.homeWinRate) * 0.3,
                draw: result1X2.draw * 0.7 + (homeStats.drawRate || ld.drawRate) * 0.3,
                away: result1X2.away * 0.7 + (awayStats.awayWinRate || ld.awayWinRate) * 0.3
            };
            const total1X2 = adj1X2.home + adj1X2.draw + adj1X2.away;
            adj1X2.home = (adj1X2.home / total1X2) * 100;
            adj1X2.draw = (adj1X2.draw / total1X2) * 100;
            adj1X2.away = (adj1X2.away / total1X2) * 100;
            
            // Double Chance
            const doubleChance = {
                '1X': adj1X2.home + adj1X2.draw,
                'X2': adj1X2.draw + adj1X2.away,
                '12': adj1X2.home + adj1X2.away
            };
            
            // GG/NG
            const homeScores = probToScore(homeLambda);
            const awayScores = probToScore(awayLambda);
            let ggProb = (homeScores * awayScores) / 100;
            const histBtts = (homeStats.bttsRate + awayStats.bttsRate) / 2;
            ggProb = ggProb * 0.7 + histBtts * 0.3;
            
            // Over/Under Goals
            const overUnderGoals = {};
            [0.5, 1.5, 2.5, 3.5, 4.5].forEach(line => {
                const over = bivariatePoissonOver(homeLambda, awayLambda, line);
                const histOver = line === 2.5 ? (homeStats.over25Rate + awayStats.over25Rate) / 2 : over;
                const adjOver = line === 2.5 ? over * 0.7 + histOver * 0.3 : over;
                overUnderGoals[line] = { over: adjOver, under: 100 - adjOver };
            });
            
            // Over/Under Casa/Trasferta
            const overUnderHome = {};
            const overUnderAway = {};
            [0.5, 1.5, 2.5].forEach(line => {
                overUnderHome[line] = { over: poissonOver(homeLambda, line), under: 100 - poissonOver(homeLambda, line) };
                overUnderAway[line] = { over: poissonOver(awayLambda, line), under: 100 - poissonOver(awayLambda, line) };
            });
            
            // Corner
            let homeCorners, awayCorners;
            const baseCorner = ld.avgCorners / 2;
            
            if (extData.homeCorners && extData.awayCorners) {
                homeCorners = parseFloat(extData.homeCorners);
                awayCorners = parseFloat(extData.awayCorners);
            } else {
                const homeAttackFactor = Math.pow(homeStats.avgGoalsFor / ld.avgHomeGoals, 0.42);
                const homeDominance = homeStats.avgGoalsFor / (homeStats.avgGoalsFor + homeStats.avgGoalsAgainst + 0.1);
                homeCorners = baseCorner * homeAttackFactor * (0.7 + homeDominance * 0.6) * 1.15;
                
                const awayAttackFactor = Math.pow(awayStats.avgGoalsFor / ld.avgAwayGoals, 0.42);
                const awayDominance = awayStats.avgGoalsFor / (awayStats.avgGoalsFor + awayStats.avgGoalsAgainst + 0.1);
                awayCorners = baseCorner * awayAttackFactor * (0.7 + awayDominance * 0.6) * 0.90;
            }
            
            if (extData.h2hCorners) {
                const h2h = parseFloat(extData.h2hCorners);
                const adj = (h2h - (homeCorners + awayCorners)) * 0.25;
                homeCorners += adj / 2;
                awayCorners += adj / 2;
            }
            
            homeCorners = Math.max(3, Math.min(8, homeCorners));
            awayCorners = Math.max(3, Math.min(8, awayCorners));
            const totalCorners = homeCorners + awayCorners;
            
            const cornerPredictions = {};
            [8.5, 9.5, 10.5, 11.5, 12.5].forEach(line => {
                const diff = totalCorners - line;
                const prob = 50 + (diff / 2.2) * 28;
                cornerPredictions[line] = { over: Math.max(15, Math.min(85, prob)), under: Math.max(15, Math.min(85, 100 - prob)) };
            });
            
            const homeCornerPreds = {}, awayCornerPreds = {};
            [3.5, 4.5, 5.5].forEach(line => {
                const hProb = 50 + ((homeCorners - line) / 1.5) * 25;
                const aProb = 50 + ((awayCorners - line) / 1.5) * 25;
                homeCornerPreds[line] = { over: Math.max(20, Math.min(80, hProb)), under: Math.max(20, Math.min(80, 100 - hProb)) };
                awayCornerPreds[line] = { over: Math.max(20, Math.min(80, aProb)), under: Math.max(20, Math.min(80, 100 - aProb)) };
            });
            
            // Cards
            let homeCards, awayCards;
            const baseCards = ld.avgCards / 2;
            
            if (extData.homeCards && extData.awayCards) {
                homeCards = parseFloat(extData.homeCards);
                awayCards = parseFloat(extData.awayCards);
            } else {
                const homeDefPressure = Math.pow(homeStats.avgGoalsAgainst / ld.avgAwayGoals, 0.35);
                const homeFrustration = Math.pow(ld.avgHomeGoals / Math.max(homeStats.avgGoalsFor, 0.5), 0.25);
                homeCards = baseCards * homeDefPressure * homeFrustration * 0.88;
                
                const awayDefPressure = Math.pow(awayStats.avgGoalsAgainst / ld.avgHomeGoals, 0.35);
                const awayFrustration = Math.pow(ld.avgAwayGoals / Math.max(awayStats.avgGoalsFor, 0.5), 0.25);
                awayCards = baseCards * awayDefPressure * awayFrustration * 1.18;
            }
            
            if (extData.refereeCards) {
                const refAvg = parseFloat(extData.refereeCards);
                const adj = (refAvg - (homeCards + awayCards)) * 0.35;
                homeCards += adj * 0.45;
                awayCards += adj * 0.55;
            }
            
            homeCards = Math.max(1, Math.min(4, homeCards));
            awayCards = Math.max(1, Math.min(4, awayCards));
            const totalCards = homeCards + awayCards;
            
            const cardPredictions = {};
            [2.5, 3.5, 4.5, 5.5, 6.5].forEach(line => {
                const diff = totalCards - line;
                const prob = 50 + (diff / 1.6) * 30;
                cardPredictions[line] = { over: Math.max(15, Math.min(85, prob)), under: Math.max(15, Math.min(85, 100 - prob)) };
            });
            
            const homeCardPreds = {}, awayCardPreds = {};
            [0.5, 1.5, 2.5].forEach(line => {
                const hProb = 50 + ((homeCards - line) / 1.2) * 28;
                const aProb = 50 + ((awayCards - line) / 1.2) * 28;
                homeCardPreds[line] = { over: Math.max(20, Math.min(80, hProb)), under: Math.max(20, Math.min(80, 100 - hProb)) };
                awayCardPreds[line] = { over: Math.max(20, Math.min(80, aProb)), under: Math.max(20, Math.min(80, 100 - aProb)) };
            });
            
            // Combo
            const combos = {
                'GG + O2.5': ggProb * (overUnderGoals[2.5].over / 100) * 1.1,
                'GG + U3.5': ggProb * (overUnderGoals[3.5].under / 100),
                'NG + U2.5': (100 - ggProb) * (overUnderGoals[2.5].under / 100) * 1.1,
                '1 + O1.5': adj1X2.home * (overUnderGoals[1.5].over / 100) / 100,
                '2 + O1.5': adj1X2.away * (overUnderGoals[1.5].over / 100) / 100,
                '1 + GG': adj1X2.home * (ggProb / 100),
                '2 + GG': adj1X2.away * (ggProb / 100)
            };
            
            let hunterBetData = null;
            if (extData.hunterBetTip && extData.hunterBetConfidence) {
                hunterBetData = { tip: extData.hunterBetTip, confidence: parseFloat(extData.hunterBetConfidence) };
            }
            
            return {
                xG: { home: homeLambda, away: awayLambda, total: totalLambda },
                result1X2: adj1X2,
                doubleChance,
                btts: { gg: ggProb, ng: 100 - ggProb },
                overUnderGoals,
                overUnderHome,
                overUnderAway,
                corners: { home: homeCorners, away: awayCorners, total: totalCorners, predictions: cornerPredictions, homePreds: homeCornerPreds, awayPreds: awayCornerPreds },
                cards: { home: homeCards, away: awayCards, total: totalCards, predictions: cardPredictions, homePreds: homeCardPreds, awayPreds: awayCardPreds },
                combos,
                hunterBet: hunterBetData,
                dataSource: (extData.homeCorners || extData.refereeCards) ? 'external' : 'algorithm'
            };
        }

        function generatePredictions(markets, match) {
            const predictions = [];
            const homeName = match.homeTeam.shortName || match.homeTeam.name;
            const awayName = match.awayTeam.shortName || match.awayTeam.name;
            
            // 1X2
            const best1X2 = Object.entries({ '1': markets.result1X2.home, 'X': markets.result1X2.draw, '2': markets.result1X2.away }).sort((a, b) => b[1] - a[1])[0];
            predictions.push({ market: '1X2', selection: best1X2[0], label: best1X2[0] === '1' ? homeName : (best1X2[0] === '2' ? awayName : 'Pareggio'), probability: best1X2[1], confidence: Math.min(85, 40 + best1X2[1] * 0.5), category: 'esito' });
            
            // Double Chance
            const bestDC = Object.entries(markets.doubleChance).sort((a, b) => b[1] - a[1])[0];
            predictions.push({ market: 'Double Chance', selection: bestDC[0], label: bestDC[0], probability: bestDC[1], confidence: Math.min(88, 45 + bestDC[1] * 0.45), category: 'esito' });
            
            // GG/NG
            const bestBtts = markets.btts.gg > 50 ? { sel: 'GG', prob: markets.btts.gg } : { sel: 'NG', prob: markets.btts.ng };
            predictions.push({ market: 'GG/NG', selection: bestBtts.sel, label: bestBtts.sel === 'GG' ? 'Goal' : 'No Goal', probability: bestBtts.prob, confidence: Math.min(85, 45 + Math.abs(bestBtts.prob - 50) * 0.7), category: 'goal' });
            
            // Over/Under Goals
            Object.entries(markets.overUnderGoals).forEach(([line, data]) => {
                const best = data.over > 50 ? { sel: 'OVER', prob: data.over } : { sel: 'UNDER', prob: data.under };
                predictions.push({ market: `Goal ${best.sel} ${line}`, selection: `${best.sel} ${line}`, label: `${best.sel} ${line}`, probability: best.prob, confidence: Math.min(85, 45 + Math.abs(best.prob - 50) * 0.65), category: 'goal' });
            });
            
            // Over/Under Casa
            Object.entries(markets.overUnderHome).forEach(([line, data]) => {
                const best = data.over > 50 ? { sel: 'OVER', prob: data.over } : { sel: 'UNDER', prob: data.under };
                predictions.push({ market: `${homeName} ${best.sel} ${line}`, selection: `Casa ${best.sel} ${line}`, label: `${homeName} ${best.sel} ${line}`, probability: best.prob, confidence: Math.min(82, 42 + Math.abs(best.prob - 50) * 0.6), category: 'goal' });
            });
            
            // Over/Under Trasferta
            Object.entries(markets.overUnderAway).forEach(([line, data]) => {
                const best = data.over > 50 ? { sel: 'OVER', prob: data.over } : { sel: 'UNDER', prob: data.under };
                predictions.push({ market: `${awayName} ${best.sel} ${line}`, selection: `Trasf ${best.sel} ${line}`, label: `${awayName} ${best.sel} ${line}`, probability: best.prob, confidence: Math.min(82, 42 + Math.abs(best.prob - 50) * 0.6), category: 'goal' });
            });
            
            // Corner
            const boost = markets.dataSource === 'external' ? 5 : 0;
            Object.entries(markets.corners.predictions).forEach(([line, data]) => {
                const best = data.over > 50 ? { sel: 'OVER', prob: data.over } : { sel: 'UNDER', prob: data.under };
                predictions.push({ market: `Corner ${best.sel} ${line}`, selection: `Corner ${best.sel} ${line}`, label: `Corner ${best.sel} ${line}`, probability: best.prob, confidence: Math.min(85, 42 + Math.abs(best.prob - 50) * 0.6 + boost), category: 'corner' });
            });
            
            Object.entries(markets.corners.homePreds).forEach(([line, data]) => {
                const best = data.over > 50 ? { sel: 'OVER', prob: data.over } : { sel: 'UNDER', prob: data.under };
                predictions.push({ market: `${homeName} Corner ${best.sel} ${line}`, selection: `Corner Casa ${best.sel} ${line}`, label: `${homeName} C. ${best.sel} ${line}`, probability: best.prob, confidence: Math.min(80, 40 + Math.abs(best.prob - 50) * 0.55), category: 'corner' });
            });
            
            Object.entries(markets.corners.awayPreds).forEach(([line, data]) => {
                const best = data.over > 50 ? { sel: 'OVER', prob: data.over } : { sel: 'UNDER', prob: data.under };
                predictions.push({ market: `${awayName} Corner ${best.sel} ${line}`, selection: `Corner Trasf ${best.sel} ${line}`, label: `${awayName} C. ${best.sel} ${line}`, probability: best.prob, confidence: Math.min(80, 40 + Math.abs(best.prob - 50) * 0.55), category: 'corner' });
            });
            
            // Cards
            Object.entries(markets.cards.predictions).forEach(([line, data]) => {
                const best = data.over > 50 ? { sel: 'OVER', prob: data.over } : { sel: 'UNDER', prob: data.under };
                predictions.push({ market: `Cards ${best.sel} ${line}`, selection: `Cards ${best.sel} ${line}`, label: `Cartellini ${best.sel} ${line}`, probability: best.prob, confidence: Math.min(82, 40 + Math.abs(best.prob - 50) * 0.55 + boost), category: 'cards' });
            });
            
            // Combo
            Object.entries(markets.combos).forEach(([combo, prob]) => {
                if (prob > 25) {
                    predictions.push({ market: `Combo: ${combo}`, selection: combo, label: combo, probability: prob, confidence: Math.min(78, 35 + prob * 0.5), category: 'combo' });
                }
            });
            
            // HunterBet
            if (markets.hunterBet) {
                predictions.push({ market: 'HunterBet', selection: markets.hunterBet.tip, label: `ğŸ¯ ${markets.hunterBet.tip}`, probability: markets.hunterBet.confidence, confidence: markets.hunterBet.confidence, category: 'external', isHunterBet: true });
            }
            
            return predictions.sort((a, b) => b.confidence - a.confidence);
        }

        // ============================================================
        // STORICO
        // ============================================================

        function saveToHistory(match, predictions, selectedPreds) {
            const entry = {
                id: Date.now(),
                matchId: match.id,
                date: match.utcDate,
                homeTeam: match.homeTeam.shortName || match.homeTeam.name,
                awayTeam: match.awayTeam.shortName || match.awayTeam.name,
                league: state.selectedLeague,
                predictions: selectedPreds.map(p => ({ market: p.market, selection: p.selection, confidence: p.confidence, result: null })),
                status: 'pending',
                createdAt: new Date().toISOString()
            };
            state.history.unshift(entry);
            localStorage.setItem(DB_KEY, JSON.stringify(state.history));
            render();
        }

        function updateHistoryResult(entryId, predIndex, won) {
            const entry = state.history.find(e => e.id === entryId);
            if (entry) {
                entry.predictions[predIndex].result = won ? 'won' : 'lost';
                const allResolved = entry.predictions.every(p => p.result !== null);
                if (allResolved) {
                    const allWon = entry.predictions.every(p => p.result === 'won');
                    const anyWon = entry.predictions.some(p => p.result === 'won');
                    entry.status = allWon ? 'won' : (anyWon ? 'partial' : 'lost');
                }
                localStorage.setItem(DB_KEY, JSON.stringify(state.history));
                render();
            }
        }

        function getHistoryStats() {
            const resolved = state.history.filter(e => e.status !== 'pending');
            const won = resolved.filter(e => e.status === 'won').length;
            const partial = resolved.filter(e => e.status === 'partial').length;
            const lost = resolved.filter(e => e.status === 'lost').length;
            let totalPreds = 0, wonPreds = 0;
            state.history.forEach(entry => {
                entry.predictions.forEach(p => {
                    if (p.result !== null) { totalPreds++; if (p.result === 'won') wonPreds++; }
                });
            });
            return {
                total: state.history.length, resolved: resolved.length, won, partial, lost,
                winRate: resolved.length > 0 ? (won / resolved.length * 100).toFixed(1) : 0,
                predTotal: totalPreds, predWon: wonPreds,
                predHitRate: totalPreds > 0 ? (wonPreds / totalPreds * 100).toFixed(1) : 0
            };
        }

        function clearHistory() {
            if (confirm('Cancellare tutto lo storico?')) {
                state.history = [];
                localStorage.setItem(DB_KEY, JSON.stringify([]));
                render();
            }
        }

        // ============================================================
        // API
        // ============================================================

        async function apiCall(endpoint) {
            const url = PROXY(`${FD_API}${endpoint}`);
            const response = await fetch(url, { headers: { 'X-Auth-Token': state.apiKey } });
            if (!response.ok) throw new Error(`Error ${response.status}`);
            return await response.json();
        }

        async function loadMatches() {
            state.loading = true;
            state.error = null;
            render();
            
            try {
                const data = await apiCall(`/competitions/${state.selectedLeague}/matches?status=SCHEDULED,TIMED`);
                state.matches = (data.matches || []).slice(0, 30);
                if (state.matches.length === 0) state.error = 'Nessuna partita in programma';
            } catch (err) {
                state.error = 'Errore: ' + err.message;
            } finally {
                state.loading = false;
                render();
            }
        }

        function calcStats(matches, teamId) {
            if (!matches || matches.length === 0) {
                return { played: 0, avgGoalsFor: 1.3, avgGoalsAgainst: 1.1, bttsRate: 50, over25Rate: 50, cleanSheets: 0, homeWinRate: 45, drawRate: 25, awayWinRate: 30 };
            }
            let gf = 0, ga = 0, btts = 0, o25 = 0, cs = 0, homeW = 0, draws = 0, awayW = 0, homeGames = 0, awayGames = 0;
            matches.forEach(m => {
                const isHome = m.homeTeam.id === teamId;
                const scored = isHome ? (m.score.fullTime.home || 0) : (m.score.fullTime.away || 0);
                const conceded = isHome ? (m.score.fullTime.away || 0) : (m.score.fullTime.home || 0);
                const total = (m.score.fullTime.home || 0) + (m.score.fullTime.away || 0);
                gf += scored; ga += conceded;
                if (scored > 0 && conceded > 0) btts++;
                if (total > 2) o25++;
                if (conceded === 0) cs++;
                if (isHome) { homeGames++; if (scored > conceded) homeW++; else if (scored === conceded) draws++; }
                else { awayGames++; if (scored > conceded) awayW++; else if (scored === conceded) draws++; }
            });
            const played = matches.length;
            return {
                played, avgGoalsFor: gf / played, avgGoalsAgainst: ga / played,
                bttsRate: (btts / played) * 100, over25Rate: (o25 / played) * 100, cleanSheets: cs,
                homeWinRate: homeGames > 0 ? (homeW / homeGames) * 100 : 45,
                drawRate: played > 0 ? (draws / played) * 100 : 25,
                awayWinRate: awayGames > 0 ? (awayW / awayGames) * 100 : 30
            };
        }

        async function analyzeMatch(match) {
            state.isAnalyzing = true;
            state.selectedMatch = match;
            state.activeTab = 'analysis';
            state.externalData = { homeCorners: '', awayCorners: '', homeCards: '', awayCards: '', h2hCorners: '', h2hCards: '', refereeCards: '', homeAbsences: '', awayAbsences: '', homeForm: '', awayForm: '', hunterBetTip: '', hunterBetConfidence: '' };
            render();

            try {
                state.analysisStep = 'Caricamento...';
                render();
                const [homeData, awayData] = await Promise.all([
                    apiCall(`/teams/${match.homeTeam.id}/matches?status=FINISHED&limit=15`),
                    apiCall(`/teams/${match.awayTeam.id}/matches?status=FINISHED&limit=15`)
                ]);
                state.analysisStep = 'Analisi...';
                render();
                const homeStats = calcStats(homeData.matches || [], match.homeTeam.id);
                const awayStats = calcStats(awayData.matches || [], match.awayTeam.id);
                const markets = analyzeAllMarkets(homeStats, awayStats, state.selectedLeague, state.externalData);
                const predictions = generatePredictions(markets, match);
                state.analysisData = { match, homeStats, awayStats, markets, predictions, selectedPredictions: [] };
            } catch (err) {
                state.error = 'Errore: ' + err.message;
            } finally {
                state.isAnalyzing = false;
                state.analysisStep = '';
                render();
            }
        }

        function recalculate() {
            if (!state.analysisData) return;
            const { homeStats, awayStats, match } = state.analysisData;
            const markets = analyzeAllMarkets(homeStats, awayStats, state.selectedLeague, state.externalData);
            const predictions = generatePredictions(markets, match);
            state.analysisData.markets = markets;
            state.analysisData.predictions = predictions;
            state.showExternalInput = false;
            render();
        }

        function togglePrediction(pred) {
            const idx = state.analysisData.selectedPredictions.findIndex(p => p.market === pred.market);
            if (idx >= 0) state.analysisData.selectedPredictions.splice(idx, 1);
            else state.analysisData.selectedPredictions.push(pred);
            render();
        }

        function savePredictions() {
            if (state.analysisData.selectedPredictions.length === 0) { alert('Seleziona almeno un pronostico!'); return; }
            saveToHistory(state.analysisData.match, state.analysisData.predictions, state.analysisData.selectedPredictions);
            alert('âœ… Salvato!');
            state.analysisData.selectedPredictions = [];
            render();
        }

        // ============================================================
        // RENDER HELPERS
        // ============================================================

        function formatDate(dateStr) {
            const d = new Date(dateStr);
            return { date: d.toLocaleDateString('it-IT', { weekday: 'short', day: '2-digit', month: '2-digit' }), time: d.toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' }) };
        }

        function badge(value, size = 'sm') {
            const v = parseFloat(value);
            let cls = 'bg-red-100 text-red-700';
            if (v >= 70) cls = 'bg-green-100 text-green-700';
            else if (v >= 55) cls = 'bg-amber-100 text-amber-700';
            const sizeClass = size === 'lg' ? 'px-3 py-1.5 text-sm' : 'px-2 py-0.5 text-xs';
            return `<span class="rounded font-bold ${cls} ${sizeClass}">${Math.round(v)}%</span>`;
        }

        function categoryIcon(cat) {
            return { esito: 'ğŸ†', goal: 'âš½', corner: 'ğŸš©', cards: 'ğŸŸ¨', combo: 'ğŸ°', external: 'ğŸ¯' }[cat] || 'ğŸ“Š';
        }

        function updateExtData(field, value) { state.externalData[field] = value; }
        function saveKey() {
            const key = document.getElementById('apiKeyInput').value.trim();
            if (key) { localStorage.setItem('footballDataApiKey', key); state.apiKey = key; state.showSetup = false; render(); loadMatches(); }
        }
        function changeLeague(code) { state.selectedLeague = code; state.selectedMatch = null; state.analysisData = null; loadMatches(); }
        function changeCategory(cat) { state.selectedCategory = cat; state.selectedLeague = CATEGORIES[cat].leagues[0]; state.selectedMatch = null; state.analysisData = null; loadMatches(); }
        function setTab(tab) { state.activeTab = tab; render(); }
        function toggleExternalInput() { state.showExternalInput = !state.showExternalInput; render(); }
        function setMinConfidence(val) { state.minConfidence = parseInt(val); render(); }
        function setHistoryFilter(f) { state.historyFilter = f; render(); }
        function resetApp() { localStorage.removeItem('footballDataApiKey'); state.apiKey = ''; state.showSetup = true; state.matches = []; render(); }

        // ============================================================
        // MAIN RENDER
        // ============================================================

        function render() {
            const root = document.getElementById('root');

            if (state.showSetup) {
                root.innerHTML = `
                    <div class="min-h-screen flex items-center justify-center p-4 bg-gradient-to-br from-gray-900 via-green-900 to-gray-900">
                        <div class="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full">
                            <div class="text-center mb-8">
                                <div class="w-24 h-24 bg-gradient-to-br from-green-400 to-emerald-600 rounded-3xl flex items-center justify-center mx-auto mb-4 shadow-xl">
                                    <span class="text-5xl">ğŸ¯</span>
                                </div>
                                <h1 class="text-3xl font-black text-gray-900">PRO BETTING V2</h1>
                                <p class="text-green-600 font-medium">12 Campionati â€¢ Tutti i Mercati</p>
                            </div>
                            
                            <div class="bg-gradient-to-r from-green-50 to-emerald-50 rounded-2xl p-5 mb-6 border border-green-200">
                                <p class="font-bold text-green-800 mb-2">ğŸ† Campionati inclusi:</p>
                                <div class="grid grid-cols-2 gap-1 text-xs text-green-700">
                                    <div>ğŸ‡®ğŸ‡¹ Serie A</div>
                                    <div>ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿ Premier League</div>
                                    <div>ğŸ‡ªğŸ‡¸ La Liga</div>
                                    <div>ğŸ‡©ğŸ‡ª Bundesliga</div>
                                    <div>ğŸ‡«ğŸ‡· Ligue 1</div>
                                    <div>ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿ Championship</div>
                                    <div>ğŸ‡³ğŸ‡± Eredivisie</div>
                                    <div>ğŸ‡µğŸ‡¹ Primeira Liga</div>
                                    <div>ğŸ‡§ğŸ‡· Serie A Brasil</div>
                                    <div>ğŸ† Champions League</div>
                                    <div>ğŸ‡ªğŸ‡º Europei</div>
                                    <div>ğŸŒ Mondiali</div>
                                </div>
                            </div>
                            
                            <div class="mb-6">
                                <label class="block text-sm font-bold text-gray-700 mb-2">ğŸ”‘ API Key</label>
                                <input id="apiKeyInput" type="text" placeholder="Da football-data.org..." class="w-full px-4 py-4 border-2 border-gray-200 rounded-2xl font-mono text-center"/>
                                <p class="text-xs text-gray-500 mt-2 text-center"><a href="https://www.football-data.org/client/register" target="_blank" class="text-green-600 underline">Registrati gratis</a></p>
                            </div>
                            
                            <button onclick="saveKey()" class="w-full py-4 bg-gradient-to-r from-green-500 to-emerald-600 text-white rounded-2xl font-bold text-lg shadow-lg">ğŸš€ INIZIA</button>
                        </div>
                    </div>
                `;
                return;
            }

            const league = LEAGUES[state.selectedLeague];
            let content = '';

            // MATCHES TAB
            if (state.activeTab === 'matches') {
                if (state.loading) {
                    content = `<div class="bg-white rounded-2xl p-12 text-center shadow-lg"><div class="w-12 h-12 border-4 border-green-500 border-t-transparent rounded-full loader mx-auto mb-4"></div><p>Caricamento...</p></div>`;
                } else if (state.matches.length === 0) {
                    content = `<div class="bg-white rounded-2xl p-12 text-center shadow-lg"><p class="text-5xl mb-4">ğŸ“­</p><p>Nessuna partita</p></div>`;
                } else {
                    content = `
                        <div class="bg-white rounded-2xl shadow-lg overflow-hidden">
                            <div class="px-5 py-4 bg-gradient-to-r from-green-600 to-emerald-600 flex justify-between items-center">
                                <span class="font-bold text-white">${league.flag} ${league.name}</span>
                                <button onclick="loadMatches()" class="text-white/80 hover:text-white">ğŸ”„</button>
                            </div>
                            <div class="divide-y max-h-[450px] overflow-y-auto">
                                ${state.matches.map((m, i) => {
                                    const { date, time } = formatDate(m.utcDate);
                                    return `<div class="px-4 py-3 hover:bg-green-50 cursor-pointer" onclick="analyzeMatch(state.matches[${i}])">
                                        <div class="flex items-center gap-3">
                                            <div class="w-14 text-center"><p class="text-xs text-gray-500">${date}</p><p class="font-bold">${time}</p></div>
                                            <div class="flex-1 min-w-0"><p class="font-semibold text-sm truncate">${m.homeTeam.shortName || m.homeTeam.name}</p><p class="text-gray-600 text-sm truncate">${m.awayTeam.shortName || m.awayTeam.name}</p></div>
                                            <div class="w-9 h-9 rounded-lg bg-green-100 flex items-center justify-center text-green-600">â†’</div>
                                        </div>
                                    </div>`;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }
            }

            // ANALYSIS TAB
            if (state.activeTab === 'analysis') {
                if (state.isAnalyzing) {
                    content = `<div class="bg-white rounded-2xl p-8 text-center shadow-lg"><div class="w-12 h-12 border-4 border-green-500 border-t-transparent rounded-full loader mx-auto mb-4"></div><p class="font-bold mb-2">Analisi</p><p class="text-green-600 pulse">${state.analysisStep}</p></div>`;
                } else if (!state.analysisData) {
                    content = `<div class="bg-white rounded-2xl p-12 text-center shadow-lg"><p class="text-5xl mb-4">ğŸ¯</p><p class="font-bold">Seleziona una partita</p></div>`;
                } else {
                    const a = state.analysisData;
                    const m = a.match;
                    const { date, time } = formatDate(m.utcDate);
                    const homeName = m.homeTeam.shortName || m.homeTeam.name;
                    const awayName = m.awayTeam.shortName || m.awayTeam.name;
                    const filteredPreds = a.predictions.filter(p => p.confidence >= state.minConfidence);
                    
                    const extPanel = state.showExternalInput ? `
                        <div class="bg-blue-50 border-2 border-blue-300 rounded-2xl p-4 mb-4">
                            <div class="flex justify-between items-center mb-3">
                                <h4 class="font-bold text-blue-800 text-sm">ğŸ“Š Dati Esterni</h4>
                                <a href="https://makeyourstats.com/it" target="_blank" class="text-xs bg-blue-500 text-white px-2 py-1 rounded">MakeYourStats</a>
                            </div>
                            <div class="grid grid-cols-2 gap-2 mb-2">
                                <input type="number" step="0.1" placeholder="${homeName} Corner/p" value="${state.externalData.homeCorners}" onchange="updateExtData('homeCorners', this.value)" class="px-2 py-1.5 border rounded text-xs"/>
                                <input type="number" step="0.1" placeholder="${awayName} Corner/p" value="${state.externalData.awayCorners}" onchange="updateExtData('awayCorners', this.value)" class="px-2 py-1.5 border rounded text-xs"/>
                                <input type="number" step="0.1" placeholder="${homeName} Cards/p" value="${state.externalData.homeCards}" onchange="updateExtData('homeCards', this.value)" class="px-2 py-1.5 border rounded text-xs"/>
                                <input type="number" step="0.1" placeholder="${awayName} Cards/p" value="${state.externalData.awayCards}" onchange="updateExtData('awayCards', this.value)" class="px-2 py-1.5 border rounded text-xs"/>
                            </div>
                            <div class="grid grid-cols-3 gap-2 mb-2">
                                <input type="number" step="0.1" placeholder="H2H Corner" value="${state.externalData.h2hCorners}" onchange="updateExtData('h2hCorners', this.value)" class="px-2 py-1.5 border rounded text-xs"/>
                                <input type="number" step="0.1" placeholder="H2H Cards" value="${state.externalData.h2hCards}" onchange="updateExtData('h2hCards', this.value)" class="px-2 py-1.5 border rounded text-xs"/>
                                <input type="number" step="0.1" placeholder="Arbitro Cards" value="${state.externalData.refereeCards}" onchange="updateExtData('refereeCards', this.value)" class="px-2 py-1.5 border rounded text-xs"/>
                            </div>
                            <div class="grid grid-cols-2 gap-2 mb-2">
                                <input type="number" min="0" max="10" placeholder="${homeName} Forma (0-10)" value="${state.externalData.homeForm}" onchange="updateExtData('homeForm', this.value)" class="px-2 py-1.5 border rounded text-xs"/>
                                <input type="number" min="0" max="10" placeholder="${awayName} Forma (0-10)" value="${state.externalData.awayForm}" onchange="updateExtData('awayForm', this.value)" class="px-2 py-1.5 border rounded text-xs"/>
                                <input type="number" min="0" max="10" placeholder="${homeName} Assenze" value="${state.externalData.homeAbsences}" onchange="updateExtData('homeAbsences', this.value)" class="px-2 py-1.5 border rounded text-xs"/>
                                <input type="number" min="0" max="10" placeholder="${awayName} Assenze" value="${state.externalData.awayAbsences}" onchange="updateExtData('awayAbsences', this.value)" class="px-2 py-1.5 border rounded text-xs"/>
                            </div>
                            <div class="grid grid-cols-2 gap-2 mb-3">
                                <input type="text" placeholder="HunterBet Tip" value="${state.externalData.hunterBetTip}" onchange="updateExtData('hunterBetTip', this.value)" class="px-2 py-1.5 border rounded text-xs"/>
                                <input type="number" placeholder="HunterBet %" value="${state.externalData.hunterBetConfidence}" onchange="updateExtData('hunterBetConfidence', this.value)" class="px-2 py-1.5 border rounded text-xs"/>
                            </div>
                            <button onclick="recalculate()" class="w-full py-2 bg-blue-500 text-white rounded-lg font-bold text-sm">ğŸ”„ RICALCOLA</button>
                        </div>
                    ` : '';

                    content = `
                        <div class="bg-gradient-to-r from-gray-800 to-gray-900 rounded-2xl p-4 text-white mb-4">
                            <div class="text-center">
                                <p class="font-bold">${homeName} vs ${awayName}</p>
                                <p class="text-white/60 text-xs">${date} â€¢ ${time} â€¢ ${league.flag} ${league.name}</p>
                            </div>
                            <div class="grid grid-cols-3 gap-2 mt-3 text-center text-sm">
                                <div class="bg-white/10 rounded-lg p-2"><p class="text-white/60 text-xs">xG Casa</p><p class="font-bold text-lg">${a.markets.xG.home.toFixed(2)}</p></div>
                                <div class="bg-white/10 rounded-lg p-2"><p class="text-white/60 text-xs">Totale</p><p class="font-bold text-lg text-green-400">${a.markets.xG.total.toFixed(2)}</p></div>
                                <div class="bg-white/10 rounded-lg p-2"><p class="text-white/60 text-xs">xG Trasf</p><p class="font-bold text-lg">${a.markets.xG.away.toFixed(2)}</p></div>
                            </div>
                        </div>

                        <button onclick="toggleExternalInput()" class="w-full mb-4 py-2.5 ${state.showExternalInput ? 'bg-blue-100 border-blue-400 text-blue-700' : 'bg-white border-gray-200 text-gray-700'} border-2 rounded-xl font-bold text-sm">
                            ğŸ“Š ${state.showExternalInput ? 'Chiudi' : '+'} Dati Esterni
                        </button>

                        ${extPanel}

                        <div class="bg-white rounded-xl p-3 mb-4 flex items-center justify-between">
                            <span class="text-sm font-medium">ğŸšï¸ Min:</span>
                            <div class="flex items-center gap-2">
                                <input type="range" min="40" max="80" value="${state.minConfidence}" onchange="setMinConfidence(this.value)" class="w-24"/>
                                <span class="font-bold text-green-600 w-10">${state.minConfidence}%</span>
                            </div>
                        </div>

                        <div class="bg-white rounded-2xl shadow-lg overflow-hidden mb-4">
                            <div class="px-4 py-2.5 bg-gradient-to-r from-green-500 to-emerald-500 flex justify-between items-center">
                                <span class="font-bold text-white text-sm">ğŸ¯ Pronostici (${filteredPreds.length})</span>
                                <span class="text-white/80 text-xs">${a.markets.dataSource === 'external' ? 'âœ“ Dati ext' : 'Algo'}</span>
                            </div>
                            <div class="divide-y max-h-[350px] overflow-y-auto">
                                ${filteredPreds.length === 0 ? '<p class="p-4 text-center text-gray-500 text-sm">Nessun pronostico</p>' : ''}
                                ${filteredPreds.map((p, i) => {
                                    const isSelected = a.selectedPredictions.some(sp => sp.market === p.market);
                                    const isHot = p.confidence >= 70;
                                    return `
                                        <div class="px-3 py-2.5 flex items-center gap-2 cursor-pointer hover:bg-gray-50 ${isSelected ? 'bg-green-50' : ''} ${isHot ? 'hot' : ''}" onclick="togglePrediction(state.analysisData.predictions[${a.predictions.indexOf(p)}])">
                                            <div class="w-7 h-7 rounded-lg ${isSelected ? 'bg-green-500 text-white' : 'bg-gray-100'} flex items-center justify-center text-sm">
                                                ${isSelected ? 'âœ“' : categoryIcon(p.category)}
                                            </div>
                                            <div class="flex-1 min-w-0">
                                                <p class="font-semibold text-gray-900 text-sm truncate">${p.label}</p>
                                                <p class="text-xs text-gray-500 truncate">${p.market}</p>
                                            </div>
                                            ${badge(p.confidence, 'lg')}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>

                        ${a.selectedPredictions.length > 0 ? `
                            <button onclick="savePredictions()" class="w-full py-3 bg-gradient-to-r from-green-500 to-emerald-600 text-white rounded-2xl font-bold shadow-lg mb-4">
                                ğŸ’¾ SALVA ${a.selectedPredictions.length} PRONOSTICI
                            </button>
                        ` : ''}

                        <div class="grid grid-cols-2 gap-2">
                            <div class="bg-white rounded-xl p-3">
                                <p class="text-xs text-gray-500 mb-1">1X2</p>
                                <div class="flex justify-between text-xs font-bold">
                                    <span>1: ${a.markets.result1X2.home.toFixed(0)}%</span>
                                    <span>X: ${a.markets.result1X2.draw.toFixed(0)}%</span>
                                    <span>2: ${a.markets.result1X2.away.toFixed(0)}%</span>
                                </div>
                            </div>
                            <div class="bg-white rounded-xl p-3">
                                <p class="text-xs text-gray-500 mb-1">GG/NG</p>
                                <div class="flex justify-between text-xs font-bold">
                                    <span>GG: ${a.markets.btts.gg.toFixed(0)}%</span>
                                    <span>NG: ${a.markets.btts.ng.toFixed(0)}%</span>
                                </div>
                            </div>
                            <div class="bg-white rounded-xl p-3">
                                <p class="text-xs text-gray-500 mb-1">ğŸš© Corner: ${a.markets.corners.total.toFixed(1)}</p>
                                <div class="flex justify-between text-xs">${homeName}: ${a.markets.corners.home.toFixed(1)} | ${awayName}: ${a.markets.corners.away.toFixed(1)}</div>
                            </div>
                            <div class="bg-white rounded-xl p-3">
                                <p class="text-xs text-gray-500 mb-1">ğŸŸ¨ Cards: ${a.markets.cards.total.toFixed(1)}</p>
                                <div class="flex justify-between text-xs">${homeName}: ${a.markets.cards.home.toFixed(1)} | ${awayName}: ${a.markets.cards.away.toFixed(1)}</div>
                            </div>
                        </div>
                    `;
                }
            }

            // HISTORY TAB
            if (state.activeTab === 'history') {
                const stats = getHistoryStats();
                const filtered = state.historyFilter === 'all' ? state.history : state.history.filter(e => e.status === state.historyFilter);

                content = `
                    <div class="bg-gradient-to-r from-gray-800 to-gray-900 rounded-2xl p-4 text-white mb-4">
                        <h3 class="font-bold mb-3 text-center text-sm">ğŸ“Š Statistiche</h3>
                        <div class="grid grid-cols-4 gap-2 text-center mb-3">
                            <div class="bg-white/10 rounded-lg p-2"><p class="text-xl font-black">${stats.total}</p><p class="text-xs text-white/60">Tot</p></div>
                            <div class="bg-green-500/30 rounded-lg p-2"><p class="text-xl font-black text-green-400">${stats.won}</p><p class="text-xs text-white/60">Vinti</p></div>
                            <div class="bg-amber-500/30 rounded-lg p-2"><p class="text-xl font-black text-amber-400">${stats.partial}</p><p class="text-xs text-white/60">Parz</p></div>
                            <div class="bg-red-500/30 rounded-lg p-2"><p class="text-xl font-black text-red-400">${stats.lost}</p><p class="text-xs text-white/60">Persi</p></div>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <div class="bg-white/10 rounded-lg p-2 text-center"><p class="text-2xl font-black text-green-400">${stats.winRate}%</p><p class="text-xs text-white/60">Win Rate</p></div>
                            <div class="bg-white/10 rounded-lg p-2 text-center"><p class="text-2xl font-black text-blue-400">${stats.predHitRate}%</p><p class="text-xs text-white/60">Hit Rate (${stats.predWon}/${stats.predTotal})</p></div>
                        </div>
                    </div>

                    <div class="flex gap-2 mb-4 overflow-x-auto pb-1">
                        ${['all', 'pending', 'won', 'partial', 'lost'].map(f => `
                            <button onclick="setHistoryFilter('${f}')" class="px-3 py-1.5 rounded-full text-xs font-bold whitespace-nowrap ${state.historyFilter === f ? 'bg-green-500 text-white' : 'bg-white text-gray-600'}">
                                ${f === 'all' ? 'Tutti' : f === 'pending' ? 'â³' : f === 'won' ? 'âœ…' : f === 'partial' ? 'ğŸŸ¡' : 'âŒ'}
                            </button>
                        `).join('')}
                    </div>

                    <div class="space-y-3">
                        ${filtered.length === 0 ? '<div class="bg-white rounded-2xl p-8 text-center"><p class="text-gray-500">Nessun pronostico</p></div>' : ''}
                        ${filtered.map(entry => {
                            const { date, time } = formatDate(entry.date);
                            const statusColors = { pending: 'border-gray-300', won: 'border-green-400 bg-green-50', partial: 'border-amber-400 bg-amber-50', lost: 'border-red-400 bg-red-50' };
                            const statusIcons = { pending: 'â³', won: 'âœ…', partial: 'ğŸŸ¡', lost: 'âŒ' };
                            const leagueInfo = LEAGUES[entry.league];
                            
                            return `
                                <div class="bg-white rounded-2xl shadow-md overflow-hidden border-2 ${statusColors[entry.status]}">
                                    <div class="px-4 py-2.5 border-b flex justify-between items-center">
                                        <div>
                                            <p class="font-bold text-gray-900 text-sm">${entry.homeTeam} vs ${entry.awayTeam}</p>
                                            <p class="text-xs text-gray-500">${date} â€¢ ${leagueInfo?.flag || ''} ${leagueInfo?.name || ''}</p>
                                        </div>
                                        <span class="text-xl">${statusIcons[entry.status]}</span>
                                    </div>
                                    <div class="p-3 space-y-2">
                                        ${entry.predictions.map((p, pIdx) => `
                                            <div class="flex items-center justify-between py-1.5 px-2.5 rounded-lg ${p.result === 'won' ? 'bg-green-100' : p.result === 'lost' ? 'bg-red-100' : 'bg-gray-50'}">
                                                <div class="flex-1 min-w-0">
                                                    <p class="font-medium text-sm truncate">${p.selection}</p>
                                                    <p class="text-xs text-gray-500">${p.confidence.toFixed(0)}%</p>
                                                </div>
                                                ${p.result === null ? `
                                                    <div class="flex gap-1">
                                                        <button onclick="updateHistoryResult(${entry.id}, ${pIdx}, true)" class="px-2.5 py-1 bg-green-500 text-white rounded text-xs font-bold">âœ“</button>
                                                        <button onclick="updateHistoryResult(${entry.id}, ${pIdx}, false)" class="px-2.5 py-1 bg-red-500 text-white rounded text-xs font-bold">âœ—</button>
                                                    </div>
                                                ` : `<span class="text-lg">${p.result === 'won' ? 'âœ…' : 'âŒ'}</span>`}
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>

                    ${state.history.length > 0 ? `<button onclick="clearHistory()" class="w-full mt-4 py-2.5 bg-red-100 text-red-600 rounded-xl font-bold text-sm">ğŸ—‘ï¸ Cancella Storico</button>` : ''}
                `;
            }

            // League selector HTML
            const leagueSelector = `
                <div class="flex gap-1 overflow-x-auto pb-1 mb-1">
                    ${Object.entries(CATEGORIES).map(([catKey, cat]) => `
                        <button onclick="changeCategory('${catKey}')" class="px-2 py-1 rounded text-xs font-bold whitespace-nowrap ${state.selectedCategory === catKey ? 'bg-green-500 text-white' : 'bg-gray-200 text-gray-600'}">
                            ${cat.name}
                        </button>
                    `).join('')}
                </div>
                <select onchange="changeLeague(this.value)" class="w-full px-3 py-2 bg-gray-100 rounded-xl text-sm font-bold">
                    ${CATEGORIES[state.selectedCategory].leagues.map(code => {
                        const l = LEAGUES[code];
                        return `<option value="${code}" ${code === state.selectedLeague ? 'selected' : ''}>${l.flag} ${l.name} (${l.country})</option>`;
                    }).join('')}
                </select>
            `;

            root.innerHTML = `
                <div class="max-w-lg mx-auto min-h-screen flex flex-col">
                    <header class="bg-white shadow-md sticky top-0 z-40">
                        <div class="px-4 py-2">
                            <div class="flex items-center justify-between mb-2">
                                <div class="flex items-center gap-2">
                                    <span class="text-2xl">ğŸ¯</span>
                                    <div><h1 class="font-black text-gray-900 text-sm">PRO BETTING V2</h1></div>
                                </div>
                                <span class="text-xs text-green-600 font-bold">12 Leghe</span>
                            </div>
                            ${leagueSelector}
                        </div>
                        <div class="flex border-t">
                            <button onclick="setTab('matches')" class="flex-1 py-2.5 text-xs font-bold ${state.activeTab === 'matches' ? 'tab-active' : 'text-gray-500'}">ğŸ“… Partite</button>
                            <button onclick="setTab('analysis')" class="flex-1 py-2.5 text-xs font-bold ${state.activeTab === 'analysis' ? 'tab-active' : 'text-gray-500'}">ğŸ¯ Analisi</button>
                            <button onclick="setTab('history')" class="flex-1 py-2.5 text-xs font-bold ${state.activeTab === 'history' ? 'tab-active' : 'text-gray-500'}">ğŸ“Š Storico</button>
                        </div>
                    </header>
                    <main class="flex-1 p-4 pb-16">${content}</main>
                    <footer class="fixed bottom-0 left-0 right-0 bg-white border-t p-2 flex justify-between items-center text-xs text-gray-500 max-w-lg mx-auto">
                        <span>ğŸ§  AI System</span>
                        <button onclick="resetApp()" class="text-red-500 font-medium">Reset</button>
                    </footer>
                </div>
            `;
        }

        render();
        if (state.apiKey && !state.showSetup) loadMatches();
    </script>
</body>
</html>

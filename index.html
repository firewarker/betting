<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BettingPro - AI Betting Intelligence</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  
  <!-- Chart.js per grafici interattivi -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  
  <style>
    :root {
      /* Colori moderni con alto contrasto */
      --bg-dark: #f5f7fa;
      --bg-card: #ffffff;
      --bg-card-light: #f8fafc;
      --bg-input: #f1f5f9;
      --accent-cyan: #0284c7;
      --accent-blue: #3b82f6;
      --accent-green: #10b981;
      --accent-yellow: #f59e0b;
      --accent-red: #ef4444;
      --accent-purple: #8b5cf6;
      --accent-gold: #d97706;
      --accent-emerald: #059669;
      --text: #1e293b;
      --text-white: #0f172a;
      --text-gray: #64748b;
      --text-dark: #94a3b8;
      --border: rgba(0,0,0,0.08);
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.06);
      --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
      --shadow-lg: 0 10px 20px rgba(0,0,0,0.1);
      --glow-cyan: 0 0 24px rgba(2, 132, 199, 0.2);
      --glow-gold: 0 0 24px rgba(217, 119, 6, 0.2);
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, sans-serif;
      background: var(--bg-dark);
      background-image: 
        radial-gradient(ellipse at top left, rgba(2,132,199,0.08) 0%, transparent 50%),
        radial-gradient(ellipse at bottom right, rgba(16,185,129,0.06) 0%, transparent 50%);
      color: var(--text);
      min-height: 100vh;
      padding-bottom: 100px;
    }
    .header {
      background: rgba(255, 255, 255, 0.98);
      backdrop-filter: blur(24px);
      border-bottom: 1px solid var(--border);
      padding: 12px 24px;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 2px 12px rgba(0,0,0,0.06);
    }
    .header-inner {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
    }
    .brand { display: flex; align-items: center; gap: 12px; }
    .brand-icon {
      width: 40px; height: 40px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      border-radius: 10px;
      display: flex; align-items: center; justify-content: center;
      font-size: 1.3rem;
    }
    .brand-name {
      font-size: 1.3rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .header-right { display: flex; align-items: center; gap: 16px; }
    .status-bar { display: flex; gap: 12px; }
    .status-item { display: flex; align-items: center; gap: 6px; font-size: 0.7rem; color: var(--text-dark); }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--text-dark); }
    .status-dot.online { background: var(--accent-green); box-shadow: 0 0 8px var(--accent-green); }
    .status-dot.loading { background: var(--accent-yellow); animation: blink 1s infinite; }
    @keyframes blink { 0%,100%{opacity:1} 50%{opacity:.3} }
    .slip-badge {
      display: flex; align-items: center; gap: 8px;
      padding: 8px 16px;
      background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
      border-radius: 20px;
      font-size: 0.8rem; font-weight: 700;
      cursor: pointer;
      color: white;
      box-shadow: 0 2px 8px rgba(16,185,129,0.3);
      transition: all 0.2s;
    }
    .slip-badge:hover { 
      transform: scale(1.05); 
      box-shadow: 0 4px 12px rgba(16,185,129,0.4);
    }
    .main { max-width: 1400px; margin: 0 auto; padding: 24px; }
    .date-tabs {
      display: flex; gap: 8px; margin-bottom: 20px; flex-wrap: wrap;
    }
    .date-tab {
      padding: 10px 20px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.85rem; font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .date-tab:hover { 
      border-color: var(--accent-cyan); 
      color: var(--accent-cyan);
      box-shadow: 0 2px 8px rgba(2,132,199,0.15);
    }
    .date-tab.active {
      background: linear-gradient(135deg, rgba(2,132,199,0.12), rgba(59,130,246,0.12));
      border-color: var(--accent-cyan);
      color: var(--accent-cyan);
      border-width: 2px;
      box-shadow: 0 2px 8px rgba(2,132,199,0.2);
    }
    .panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
      transition: box-shadow 0.2s;
    }
    .panel:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    }
    .panel-title { font-size: 1rem; font-weight: 700; margin-bottom: 16px; color: var(--accent-cyan); }
    .select-field {
      width: 100%;
      padding: 14px 18px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-white);
      font-size: 0.95rem;
      cursor: pointer;
    }
    .select-field:focus { outline: none; border-color: var(--accent-cyan); }
    .matches-list { display: flex; flex-direction: column; gap: 10px; }
    .match-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 18px;
      background: var(--bg-card-light);
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .match-item:hover {
      border-color: var(--accent-cyan);
      transform: translateX(4px);
      box-shadow: 0 2px 8px rgba(2,132,199,0.15);
      background: var(--bg-card);
    }
    .match-item-left { display: flex; align-items: center; gap: 14px; flex: 1; min-width: 0; }
    .match-item-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      color: var(--accent-cyan);
      min-width: 45px;
    }
    .match-item-teams { font-weight: 600; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .match-item-badge {
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.65rem;
      font-weight: 700;
      background: var(--bg-input);
      color: var(--text-gray);
      flex-shrink: 0;
    }
    .match-item-badge.live { background: var(--accent-red); color: white; }
    .back-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 20px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.85rem;
      cursor: pointer;
      margin-bottom: 20px;
      transition: all 0.2s;
    }
    .back-btn:hover { 
      border-color: var(--accent-cyan); 
      color: var(--accent-cyan); 
      box-shadow: 0 2px 8px rgba(2,132,199,0.15);
      transform: translateX(-2px);
    }
    .analysis-hero {
      background: linear-gradient(145deg, var(--bg-card), var(--bg-card-light));
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 30px;
      margin-bottom: 20px;
      text-align: center;
      box-shadow: 0 4px 16px rgba(0,0,0,0.06);
    }
    .hero-league { font-size: 0.8rem; color: var(--text-dark); margin-bottom: 20px; }
    .hero-match { display: flex; align-items: center; justify-content: center; gap: 24px; margin-bottom: 20px; flex-wrap: wrap; }
    .hero-team { display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .hero-team-logo { width: 60px; height: 60px; object-fit: contain; }
    .hero-team-logo-fallback {
      width: 60px; height: 60px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      border-radius: 14px;
      display: flex; align-items: center; justify-content: center;
      font-weight: 700; font-size: 1rem;
    }
    .hero-team-name { font-size: 1rem; font-weight: 700; max-width: 120px; text-align: center; }
    
    /* MG NELL'HERO */
    .hero-mg-section {
      display: flex;
      gap: 16px;
      justify-content: center;
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    .hero-mg-box {
      background: linear-gradient(135deg, rgba(217,119,6,0.1), rgba(16,185,129,0.1));
      border: 2px solid var(--accent-gold);
      border-radius: 12px;
      padding: 12px 20px;
      text-align: center;
      min-width: 120px;
      box-shadow: 0 2px 8px rgba(217,119,6,0.15);
    }
    .hero-mg-label {
      font-size: 0.75rem;
      color: #b45309;
      margin-bottom: 4px;
      font-weight: 600;
    }
    .hero-mg-value {
      font-size: 1.3rem;
      font-weight: 800;
      color: #d97706;
    }
    .hero-mg-prob {
      font-size: 0.85rem;
      color: var(--accent-emerald);
      font-family: 'JetBrains Mono', monospace;
      font-weight: 700;
    }
    
    .hero-prediction { display: flex; align-items: center; gap: 10px; }
    .hero-score-box {
      width: 50px; height: 50px;
      background: var(--bg-input);
      border: 2px solid var(--accent-cyan);
      border-radius: 12px;
      display: flex; align-items: center; justify-content: center;
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.5rem; font-weight: 700;
      box-shadow: 0 2px 8px rgba(2,132,199,0.2);
      color: var(--accent-cyan);
    }
    .hero-vs { 
      padding: 6px 12px; 
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue)); 
      border-radius: 6px; 
      font-weight: 700; 
      font-size: 0.8rem; 
      color: white;
      box-shadow: 0 2px 6px rgba(59,130,246,0.3);
    }
    .analysis-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; margin-bottom: 20px; }
    .analysis-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
      transition: all 0.2s;
    }
    .analysis-card:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      transform: translateY(-2px);
    }
    .analysis-card.wide { grid-column: 1 / -1; }
    .card-title {
      display: flex; align-items: center; gap: 10px;
      margin-bottom: 16px;
      font-size: 0.9rem; font-weight: 700;
    }
    .card-title-icon {
      width: 32px; height: 32px;
      background: linear-gradient(135deg, rgba(2,132,199,0.15), rgba(59,130,246,0.15));
      border-radius: 8px;
      display: flex; align-items: center; justify-content: center;
      font-size: 1rem;
      box-shadow: 0 2px 6px rgba(2,132,199,0.15);
    }
    .card-title-badge {
      margin-left: auto;
      padding: 4px 10px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      border-radius: 6px;
      font-size: 0.7rem; font-weight: 700;
      color: white;
      box-shadow: 0 2px 4px rgba(2,132,199,0.3);
    }
    .prob-row { display: flex; align-items: center; gap: 10px; margin-bottom: 12px; }
    .prob-row:last-child { margin-bottom: 0; }
    .prob-label { width: 80px; font-size: 0.8rem; color: var(--text-gray); font-weight: 600; }
    .prob-bar-track { flex: 1; height: 10px; background: var(--bg-input); border-radius: 6px; overflow: hidden; box-shadow: inset 0 1px 3px rgba(0,0,0,0.08); }
    .prob-bar-fill { height: 100%; border-radius: 6px; transition: width 0.3s; }
    .prob-bar-fill.cyan { background: linear-gradient(90deg, #0284c7, #3b82f6); box-shadow: 0 2px 4px rgba(2,132,199,0.3); }
    .prob-bar-fill.green { background: linear-gradient(90deg, #10b981, #059669); box-shadow: 0 2px 4px rgba(16,185,129,0.3); }
    .prob-bar-fill.yellow { background: linear-gradient(90deg, #f59e0b, #d97706); box-shadow: 0 2px 4px rgba(245,158,11,0.3); }
    .prob-bar-fill.purple { background: linear-gradient(90deg, #8b5cf6, #7c3aed); box-shadow: 0 2px 4px rgba(139,92,246,0.3); }
    .prob-value {
      width: 50px; text-align: right;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem; font-weight: 700;
      color: var(--accent-cyan);
    }
    .stat-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
    .stat-box {
      background: var(--bg-card-light);
      border-radius: 10px;
      padding: 12px;
      text-align: center;
      border: 1px solid var(--border);
      transition: all 0.2s;
    }
    .stat-box:hover {
      border-color: var(--accent-cyan);
      box-shadow: 0 2px 8px rgba(2,132,199,0.15);
    }
    .stat-box-label { font-size: 0.65rem; color: var(--text-gray); margin-bottom: 4px; text-transform: uppercase; font-weight: 600; }
    .stat-box-value { font-family: 'JetBrains Mono', monospace; font-size: 1.2rem; font-weight: 800; color: var(--accent-cyan); }
    .stat-box-sub { font-size: 0.6rem; color: var(--text-gray); margin-top: 2px; }
    .scores-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 8px; }
    .score-box {
      background: var(--bg-card-light);
      border-radius: 8px;
      padding: 10px 6px;
      text-align: center;
      border: 1px solid var(--border);
      transition: all 0.2s;
      cursor: pointer;
    }
    .score-box:hover {
      border-color: var(--accent-cyan);
      box-shadow: 0 2px 8px rgba(2,132,199,0.15);
    }
    .score-box.highlight { 
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue)); 
      border-color: var(--accent-blue);
      box-shadow: 0 2px 8px rgba(59,130,246,0.3);
    }
    .score-box-value { font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; font-weight: 700; }
    .score-box-prob { font-size: 0.6rem; color: var(--text-gray); margin-top: 2px; font-weight: 600; }
    .score-box.highlight .score-box-prob { color: rgba(255,255,255,0.9); }
    
    /* COMBO SUGGERITE */
    .combo-panel {
      background: linear-gradient(135deg, var(--bg-card), var(--bg-card-light));
      border: 2px solid var(--accent-purple);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 20px;
      box-shadow: 0 4px 16px rgba(139,92,246,0.12);
    }
    .combo-title { font-size: 1.1rem; font-weight: 700; color: var(--accent-purple); margin-bottom: 16px; }
    .combo-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 12px; }
    .combo-card {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    .combo-card:hover { 
      border-color: var(--accent-purple); 
      transform: translateY(-2px); 
      box-shadow: 0 4px 12px rgba(139,92,246,0.2);
    }
    .combo-card.selected { 
      border-color: var(--accent-green); 
      background: rgba(16,185,129,0.08); 
      border-width: 2px;
      box-shadow: 0 4px 12px rgba(16,185,129,0.2);
    }
    .combo-value { font-size: 1rem; font-weight: 700; margin-bottom: 8px; }
    .combo-stats { display: flex; justify-content: center; gap: 12px; font-size: 0.75rem; font-weight: 600; }
    .combo-prob { color: var(--accent-cyan); font-weight: 700; }
    .combo-odds { color: var(--accent-emerald); font-weight: 700; }
    
    /* MULTIGOAL GRID */
    .multigoal-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
      gap: 10px;
    }
    .multigoal-box {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 8px;
      text-align: center;
      transition: all 0.2s;
      cursor: pointer;
    }
    .multigoal-box:hover {
      border-color: var(--accent-cyan);
      box-shadow: 0 2px 8px rgba(2,132,199,0.15);
    }
    .multigoal-box.best {
      border-color: var(--accent-green);
      background: rgba(16,185,129,0.08);
      border-width: 2px;
      box-shadow: 0 2px 8px rgba(16,185,129,0.2);
    }
    .multigoal-range {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 4px;
    }
    .multigoal-prob {
      font-size: 0.9rem;
      color: var(--accent-cyan);
      font-weight: 700;
    }
    .multigoal-quota {
      font-size: 0.75rem;
      color: var(--accent-emerald);
      margin-top: 2px;
      font-weight: 600;
    }
    
    /* TEMPO GOL */
    .tempo-highlight {
      background: linear-gradient(135deg, rgba(139,92,246,0.08), rgba(59,130,246,0.08));
      border: 2px solid var(--accent-purple);
      border-radius: 10px;
      padding: 12px;
      margin-top: 12px;
      text-align: center;
      font-size: 0.85rem;
      box-shadow: 0 2px 6px rgba(139,92,246,0.15);
    }
    .tempo-highlight strong {
      color: var(--accent-cyan);
      margin: 0 6px;
      font-weight: 700;
    }
    .tempo-prob {
      color: var(--accent-emerald);
      font-weight: 700;
    }
    
    /* FORM DISPLAY */
    .form-display {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .form-team {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
    }
    .form-team:last-child { border-bottom: none; }
    .form-team-name {
      font-weight: 600;
      font-size: 0.85rem;
    }
    .form-string {
      display: flex;
      gap: 4px;
    }
    .form-w, .form-d, .form-l {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      font-weight: 700;
    }
    .form-w { background: var(--accent-green); color: white; box-shadow: 0 2px 4px rgba(16,185,129,0.2); }
    .form-d { background: var(--accent-yellow); color: white; box-shadow: 0 2px 4px rgba(245,158,11,0.2); }
    .form-l { background: var(--accent-red); color: white; box-shadow: 0 2px 4px rgba(239,68,68,0.2); }
    
    /* CLASSIFICA E MOTIVAZIONE */
    .standings-card {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 8px;
    }
    .standings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .standings-position {
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--accent-cyan);
    }
    .standings-position sup {
      font-size: 0.7rem;
      color: var(--text-dark);
    }
    .motivation-badge {
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.7rem;
      font-weight: 600;
    }
    .motivation-badge.gold { background: rgba(217,119,6,0.15); color: #d97706; border: 1px solid #d97706; font-weight: 700; }
    .motivation-badge.cyan { background: rgba(6,182,212,0.2); color: var(--accent-cyan); border: 1px solid var(--accent-cyan); }
    .motivation-badge.blue { background: rgba(59,130,246,0.2); color: var(--accent-blue); border: 1px solid var(--accent-blue); }
    .motivation-badge.red { background: rgba(239,68,68,0.2); color: var(--accent-red); border: 1px solid var(--accent-red); }
    .motivation-badge.orange { background: rgba(249,115,22,0.2); color: #f97316; border: 1px solid #f97316; }
    .motivation-badge.gray { background: rgba(156,163,175,0.2); color: var(--text-dark); border: 1px solid var(--border); }
    .standings-stats {
      display: flex;
      gap: 12px;
      font-size: 0.75rem;
      color: var(--text-dark);
    }
    .standings-stat {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    /* INFORTUNATI */
    .injuries-card {
      background: rgba(239,68,68,0.05);
      border: 1px solid rgba(239,68,68,0.3);
      border-radius: 12px;
      padding: 12px;
    }
    .injuries-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-weight: 600;
      color: var(--accent-red);
    }
    .injuries-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .injury-chip {
      background: rgba(239,68,68,0.1);
      border: 1px solid rgba(239,68,68,0.3);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.7rem;
      color: var(--text);
    }
    .no-injuries {
      color: var(--accent-green);
      font-size: 0.8rem;
    }
    
    /* PANNELLO IMPOSTAZIONI */
    .settings-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 320px;
      height: 100vh;
      background: var(--bg-card);
      border-left: 1px solid var(--border);
      padding: 20px;
      z-index: 1000;
      overflow-y: auto;
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }
    .settings-panel.open { transform: translateX(0); }
    .settings-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 999;
      display: none;
    }
    .settings-overlay.open { display: block; }
    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid var(--border);
    }
    .settings-title {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--text);
    }
    .settings-close {
      background: none;
      border: none;
      color: var(--text-dark);
      font-size: 1.5rem;
      cursor: pointer;
    }
    .settings-section {
      margin-bottom: 20px;
    }
    .settings-section-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--accent-cyan);
      margin-bottom: 12px;
    }
    .settings-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .settings-label {
      font-size: 0.85rem;
      color: var(--text);
    }
    .settings-input {
      width: 70px;
      padding: 6px 10px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      text-align: center;
    }
    .settings-toggle {
      position: relative;
      width: 44px;
      height: 24px;
      background: var(--bg-input);
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .settings-toggle.active { background: var(--accent-green); }
    .settings-toggle::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }
    .settings-toggle.active::after { transform: translateX(20px); }
    
    /* STORICO WIN RATE */
    .history-chart {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-top: 12px;
    }
    .history-bars {
      display: flex;
      align-items: flex-end;
      gap: 4px;
      height: 80px;
      margin-bottom: 8px;
    }
    .history-bar {
      flex: 1;
      background: var(--accent-cyan);
      border-radius: 4px 4px 0 0;
      min-height: 4px;
      position: relative;
    }
    .history-bar.won { background: var(--accent-green); }
    .history-bar.lost { background: var(--accent-red); }
    .history-labels {
      display: flex;
      justify-content: space-between;
      font-size: 0.65rem;
      color: var(--text-dark);
    }
    
    /* WIN RATE PER SEGNO */
    .winrate-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 16px;
    }
    .winrate-item {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
    }
    .winrate-label {
      font-weight: 700;
      font-size: 0.85rem;
      color: var(--text-white);
      margin-bottom: 6px;
    }
    .winrate-stats {
      display: flex;
      gap: 12px;
      font-size: 0.75rem;
      color: var(--text-gray);
      margin-bottom: 8px;
    }
    .winrate-won { color: var(--accent-green); }
    .winrate-lost { color: var(--accent-red); }
    .winrate-bar {
      height: 8px;
      background: var(--bg-dark);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 4px;
    }
    .winrate-bar-fill {
      height: 100%;
      border-radius: 4px;
      transition: width 0.3s;
    }
    .winrate-bar-fill.good { background: linear-gradient(90deg, var(--accent-green), var(--accent-cyan)); }
    .winrate-bar-fill.bad { background: linear-gradient(90deg, var(--accent-red), var(--accent-yellow)); }
    .winrate-percent {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      font-weight: 700;
      color: var(--accent-cyan);
      text-align: right;
    }
    .winrate-summary {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      padding: 12px;
      background: var(--bg-card);
      border-radius: 10px;
      border: 1px solid var(--border);
    }
    .winrate-summary-item {
      text-align: center;
    }
    .winrate-summary-item span {
      display: block;
      font-size: 0.65rem;
      color: var(--text-dark);
      margin-bottom: 2px;
    }
    .winrate-summary-item strong {
      font-size: 1rem;
      font-weight: 700;
    }
    
    /* SETTINGS BUTTON */
    .settings-btn {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      color: var(--text);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.85rem;
      transition: all 0.2s;
    }
    .settings-btn:hover {
      border-color: var(--accent-cyan);
      background: rgba(6,182,212,0.1);
    }
    
    /* MG PROBABILE BOX */
    .mg-best-box {
      background: linear-gradient(135deg, rgba(139,92,246,0.08), rgba(59,130,246,0.08));
      border: 2px solid var(--accent-purple);
      border-radius: 10px;
      padding: 10px 12px;
      margin-top: 10px;
      text-align: center;
      box-shadow: 0 2px 6px rgba(139,92,246,0.15);
    }
    .mg-best-label {
      font-size: 0.7rem;
      color: var(--text-gray);
      margin-bottom: 4px;
      font-weight: 600;
    }
    .mg-best-value {
      font-size: 1rem;
      font-weight: 800;
      color: var(--accent-cyan);
    }
    .mg-best-prob {
      font-size: 0.75rem;
      color: var(--accent-emerald);
      font-weight: 700;
    }
    
    /* MG SOTTO RISULTATI ESATTI */
    .mg-under-scores {
      display: flex;
      gap: 12px;
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }
    .mg-box-compact {
      flex: 1;
      background: linear-gradient(135deg, rgba(217,119,6,0.08), rgba(16,185,129,0.08));
      border: 2px solid var(--accent-gold);
      border-radius: 10px;
      padding: 10px;
      text-align: center;
      box-shadow: 0 2px 6px rgba(217,119,6,0.12);
    }
    .mg-box-compact .mg-box-label {
      font-size: 0.7rem;
      color: #b45309;
      margin-bottom: 4px;
      font-weight: 600;
    }
    .mg-box-compact .mg-box-value {
      font-size: 1.1rem;
      font-weight: 800;
      color: #d97706;
    }
    .mg-box-compact .mg-box-prob {
      font-size: 0.8rem;
      color: var(--accent-emerald);
      font-family: 'JetBrains Mono', monospace;
      font-weight: 700;
    }
    
    /* LINEE OVER/UNDER CORNER E CARTELLINI */
    .ou-lines {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .ou-line-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 10px;
      background: var(--bg-input);
      border-radius: 6px;
      font-size: 0.75rem;
    }
    .ou-line-label {
      color: var(--text-gray);
      font-weight: 500;
      flex: 1;
    }
    .ou-line-over, .ou-line-under {
      padding: 3px 8px;
      border-radius: 4px;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 600;
      margin-left: 6px;
    }
    .ou-line-over {
      background: rgba(16,185,129,0.12);
      color: var(--accent-emerald);
      font-weight: 700;
    }
    .ou-line-under {
      background: rgba(239,68,68,0.12);
      color: var(--accent-red);
      font-weight: 700;
    }
    .ou-line-over.highlight {
      background: rgba(16,185,129,0.25);
      border: 1px solid var(--accent-green);
      font-weight: 800;
    }
    .ou-line-under.highlight {
      background: rgba(239,68,68,0.25);
      border: 1px solid var(--accent-red);
      font-weight: 800;
    }
    
    /* PRONOSTICI AI */
    .predictions-panel {
      background: linear-gradient(135deg, var(--bg-card), var(--bg-card-light));
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 20px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.06);
    }
    .predictions-header { text-align: center; margin-bottom: 20px; }
    .predictions-title {
      font-size: 1.3rem; font-weight: 800; margin-bottom: 8px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .predictions-subtitle { font-size: 0.8rem; color: var(--text-dark); }
    .predictions-legend { display: flex; justify-content: center; gap: 16px; margin-top: 10px; font-size: 0.7rem; }
    .legend-item { display: flex; align-items: center; gap: 4px; }
    .legend-dot { width: 10px; height: 10px; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.15); }
    .legend-dot.high { background: var(--accent-green); box-shadow: 0 2px 6px rgba(16,185,129,0.4); }
    .legend-dot.mid { background: var(--accent-yellow); box-shadow: 0 2px 6px rgba(245,158,11,0.4); }
    .legend-dot.low { background: var(--accent-red); box-shadow: 0 2px 6px rgba(239,68,68,0.4); }
    .predictions-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 12px; }
    .prediction-card {
      background: var(--bg-input);
      border: 2px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .prediction-card:hover { 
      border-color: var(--accent-cyan); 
      transform: translateY(-2px); 
      box-shadow: 0 4px 12px rgba(2,132,199,0.2);
    }
    .prediction-card.selected { 
      border-color: var(--accent-green); 
      background: rgba(16,185,129,0.08); 
      box-shadow: 0 4px 12px rgba(16,185,129,0.25);
    }
    .prediction-card.selected::after {
      content: 'âœ“';
      position: absolute;
      top: 8px; right: 8px;
      width: 20px; height: 20px;
      background: var(--accent-green);
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 0.7rem; font-weight: 700;
    }
    .prediction-market { font-size: 0.65rem; color: var(--text-dark); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px; }
    .prediction-value { font-size: 1.1rem; font-weight: 800; margin-bottom: 8px; }
    .prediction-prob {
      display: inline-flex; align-items: center; gap: 4px;
      padding: 4px 10px;
      border-radius: 12px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem; font-weight: 600;
    }
    .prediction-prob.high { background: rgba(16,185,129,0.2); color: var(--accent-green); }
    .prediction-prob.mid { background: rgba(251,191,36,0.2); color: var(--accent-yellow); }
    .prediction-prob.low { background: rgba(239,68,68,0.2); color: var(--accent-red); }
    
    /* HOME SECTIONS - Picks del giorno */
    .home-sections { display: flex; flex-direction: column; gap: 20px; margin-bottom: 24px; }
    .picks-section {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      position: relative;
      overflow: hidden;
    }
    .picks-section::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 3px;
    }
    .picks-section.raddoppi::before { background: linear-gradient(90deg, var(--accent-green), var(--accent-cyan)); }
    .picks-section.gg::before { background: linear-gradient(90deg, var(--accent-yellow), var(--accent-green)); }
    .picks-section.over::before { background: linear-gradient(90deg, var(--accent-cyan), var(--accent-blue)); }
    .picks-section.pareggi::before { background: linear-gradient(90deg, var(--accent-purple), var(--accent-blue)); }
    .picks-section.over1t::before { background: linear-gradient(90deg, var(--accent-red), var(--accent-yellow)); }
    
    /* AI CONSIGLIO */
    .ai-advice {
      background: linear-gradient(135deg, rgba(168,85,247,0.15), rgba(34,211,238,0.15));
      border: 2px solid var(--accent-purple);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 20px;
      position: relative;
      overflow: hidden;
    }
    .ai-advice::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--accent-purple), var(--accent-cyan), var(--accent-green));
    }
    .ai-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .ai-icon {
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
    }
    .ai-title-group { flex: 1; }
    .ai-title {
      font-size: 1.1rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .ai-subtitle { font-size: 0.75rem; color: var(--text-dark); }
    .ai-confidence {
      padding: 6px 14px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 700;
    }
    .ai-confidence.high { background: rgba(16,185,129,0.2); color: var(--accent-green); }
    .ai-confidence.medium { background: rgba(251,191,36,0.2); color: var(--accent-yellow); }
    .ai-confidence.low { background: rgba(239,68,68,0.2); color: var(--accent-red); }
    .ai-pick {
      background: var(--bg-input);
      border-radius: 16px;
      padding: 20px;
      text-align: center;
      margin-bottom: 16px;
    }
    .ai-pick-label { font-size: 0.7rem; color: var(--text-dark); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
    .ai-pick-value {
      font-size: 1.8rem;
      font-weight: 800;
      color: var(--accent-cyan);
      margin-bottom: 4px;
    }
    .ai-pick-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1rem;
      color: var(--accent-green);
    }
    .ai-reasoning {
      background: var(--bg-card-light);
      border-radius: 12px;
      padding: 16px;
    }
    .ai-reasoning-title {
      font-size: 0.75rem;
      color: var(--text-dark);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .ai-reasoning-list { display: flex; flex-direction: column; gap: 8px; }
    .ai-reason {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.85rem;
      color: var(--text-gray);
    }
    .ai-reason-icon { font-size: 1rem; }
    .ai-reason.positive { color: var(--accent-green); }
    .ai-reason.negative { color: var(--accent-red); }
    .ai-reason.neutral { color: var(--accent-yellow); }
    .ai-alternatives {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    .ai-alt-title { font-size: 0.7rem; color: var(--text-dark); margin-bottom: 10px; }
    .ai-alt-grid { display: flex; gap: 10px; flex-wrap: wrap; }
    .ai-alt-chip {
      padding: 8px 14px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 20px;
      font-size: 0.8rem;
      color: var(--text-gray);
      cursor: pointer;
      transition: all 0.2s;
    }
    .ai-alt-chip:hover { border-color: var(--accent-cyan); color: var(--text-white); }
    
    /* LIVE BETTING */
    .live-tab { 
      background: linear-gradient(135deg, var(--accent-red), #ff6b6b) !important; 
      animation: livePulse 2s infinite;
    }
    .live-tab.active { box-shadow: 0 0 20px rgba(239,68,68,0.5); }
    @keyframes livePulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }
    .live-badge-count {
      background: white;
      color: var(--accent-red);
      font-size: 0.7rem;
      font-weight: 800;
      padding: 2px 6px;
      border-radius: 10px;
      margin-left: 6px;
    }
    .live-section {
      background: linear-gradient(145deg, rgba(239,68,68,0.08), rgba(251,191,36,0.08));
      border: 1px solid rgba(239,68,68,0.3);
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .live-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    .live-title {
      font-size: 1.1rem;
      font-weight: 800;
      color: var(--accent-red);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .live-dot {
      width: 10px;
      height: 10px;
      background: var(--accent-red);
      border-radius: 50%;
      animation: livePulse 1s infinite;
    }
    .live-refresh-btn {
      padding: 8px 16px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .live-refresh-btn:hover { border-color: var(--accent-cyan); color: var(--text-white); }
    .live-alerts-grid { display: flex; flex-direction: column; gap: 16px; }
    .live-alert-card {
      background: var(--bg-card);
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid var(--border);
      transition: all 0.3s;
    }
    .live-alert-card:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(0,0,0,0.3); }
    .live-alert-card.high { border-color: var(--accent-red); border-width: 2px; }
    .live-alert-card.medium { border-color: var(--accent-yellow); }
    .live-alert-card.low { border-color: var(--accent-cyan); }
    .live-alert-header {
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .live-alert-card.high .live-alert-header { background: rgba(239,68,68,0.15); }
    .live-alert-card.medium .live-alert-header { background: rgba(251,191,36,0.15); }
    .live-alert-card.low .live-alert-header { background: rgba(34,211,238,0.15); }
    .live-alert-level {
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .live-alert-card.high .live-alert-level { color: var(--accent-red); }
    .live-alert-card.medium .live-alert-level { color: var(--accent-yellow); }
    .live-alert-card.low .live-alert-level { color: var(--accent-cyan); }
    .live-alert-time {
      display: flex;
      align-items: center;
      gap: 6px;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 700;
      color: var(--accent-red);
    }
    .live-alert-body { padding: 16px; }
    .live-alert-match {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .live-alert-teams { font-weight: 600; color: var(--text-white); }
    .live-alert-score {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.2rem;
      font-weight: 800;
      color: var(--accent-cyan);
      background: var(--bg-input);
      padding: 6px 12px;
      border-radius: 8px;
    }
    .live-alert-stats {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      margin-bottom: 12px;
      padding: 10px;
      background: var(--bg-input);
      border-radius: 10px;
    }
    .live-stat {
      font-size: 0.8rem;
      color: var(--text-gray);
    }
    .live-stat strong { color: var(--text-white); }
    .live-alert-pick {
      background: linear-gradient(135deg, rgba(16,185,129,0.15), rgba(34,211,238,0.15));
      border: 1px solid var(--accent-green);
      border-radius: 12px;
      padding: 14px;
      text-align: center;
    }
    .live-pick-label { font-size: 0.7rem; color: var(--text-dark); margin-bottom: 6px; }
    .live-pick-value {
      font-size: 1.3rem;
      font-weight: 800;
      color: var(--accent-green);
    }
    .live-pick-details {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-top: 8px;
      font-size: 0.85rem;
    }
    .live-pick-prob { color: var(--accent-cyan); }
    .live-pick-reason {
      font-size: 0.8rem;
      color: var(--text-gray);
      margin-top: 10px;
      font-style: italic;
    }
    .live-empty {
      text-align: center;
      padding: 40px;
      color: var(--text-dark);
    }
    .live-empty-icon { font-size: 3rem; margin-bottom: 12px; }
    .live-filters {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .live-filter-btn {
      padding: 6px 14px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 20px;
      font-size: 0.8rem;
      color: var(--text-gray);
      cursor: pointer;
      transition: all 0.2s;
    }
    .live-filter-btn:hover { border-color: var(--accent-cyan); }
    .live-filter-btn.active { background: var(--accent-cyan); color: var(--bg-dark); border-color: var(--accent-cyan); }
    .live-auto-refresh {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.75rem;
      color: var(--text-dark);
    }
    .live-countdown {
      font-family: 'JetBrains Mono', monospace;
      color: var(--accent-cyan);
    }
    .ai-alt-chip span { color: var(--accent-green); margin-left: 6px; }

    /* DUAL ADVICE LAYOUT */
    .dual-advice-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }
    @media (max-width: 968px) {
      .dual-advice-container { grid-template-columns: 1fr; }
    }

    /* STATISTICAL ADVICE */
    .statistical-advice {
      background: linear-gradient(135deg, rgba(34,211,238,0.15), rgba(16,185,129,0.15));
      border: 2px solid var(--accent-cyan);
      border-radius: 20px;
      padding: 24px;
      position: relative;
      overflow: hidden;
    }
    .statistical-advice::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--accent-cyan), var(--accent-green), var(--accent-yellow));
    }

    /* SMART FILTERS */
    .smart-filters-section {
      background: linear-gradient(145deg, rgba(168,85,247,0.08), rgba(34,211,238,0.08));
      border: 1px solid rgba(168,85,247,0.3);
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 20px;
      position: relative;
    }
    .smart-filters-section::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--accent-purple), var(--accent-cyan), var(--accent-green));
    }
    .filters-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 10px;
    }
    .filters-title {
      font-size: 1.1rem;
      font-weight: 800;
      color: var(--accent-purple);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .filters-count {
      padding: 4px 12px;
      background: var(--bg-input);
      border-radius: 12px;
      font-size: 0.75rem;
      color: var(--text-gray);
    }
    .filter-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }
    .filter-btn {
      padding: 10px 20px;
      background: var(--bg-input);
      border: 2px solid var(--border);
      border-radius: 12px;
      color: var(--text-gray);
      font-size: 0.85rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }
    .filter-btn:hover {
      border-color: var(--accent-cyan);
      color: var(--text-white);
      transform: translateY(-2px);
    }
    .filter-btn.active {
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      border-color: var(--accent-purple);
      color: white;
      box-shadow: 0 4px 15px rgba(168,85,247,0.4);
    }
    .filtered-picks {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 500px;
      overflow-y: auto;
    }
    .filtered-pick-card {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .filtered-pick-card:hover {
      border-color: var(--accent-cyan);
      transform: translateX(4px);
    }
    .filtered-pick-rank {
      width: 28px;
      height: 28px;
      background: var(--bg-input);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      font-weight: 700;
      color: var(--text-gray);
      flex-shrink: 0;
    }
    .filtered-pick-left {
      flex: 1;
      min-width: 0;
    }
    .filtered-pick-match {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-white);
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .filtered-pick-league {
      font-size: 0.7rem;
      color: var(--text-dark);
    }
    .filtered-pick-right {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }
    .filtered-pick-bet {
      padding: 6px 14px;
      background: var(--accent-purple);
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 700;
      color: white;
    }
    .filtered-pick-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;
      font-weight: 800;
      color: var(--accent-green);
      min-width: 55px;
      text-align: right;
    }
    .picks-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; }
    .picks-title { display: flex; align-items: center; gap: 10px; font-size: 1rem; font-weight: 700; }
    .picks-title-icon { font-size: 1.3rem; }
    .picks-count { 
      padding: 4px 12px; 
      background: var(--bg-input); 
      border-radius: 12px; 
      font-size: 0.75rem; 
      color: var(--text-gray); 
    }
    .picks-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px; }
    .pick-card {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 16px;
      background: var(--bg-card-light);
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .pick-card:hover { border-color: var(--accent-cyan); transform: translateX(4px); }
    .pick-card.selected { border-color: var(--accent-green); background: rgba(16,185,129,0.1); }
    .pick-info { flex: 1; min-width: 0; }
    .pick-match { font-size: 0.8rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 4px; }
    .pick-league { font-size: 0.65rem; color: var(--text-dark); }
    .pick-bet { display: flex; flex-direction: column; align-items: flex-end; gap: 4px; }
    .pick-value { font-weight: 700; color: var(--accent-cyan); }
    .pick-prob { 
      font-family: 'JetBrains Mono', monospace; 
      font-size: 0.75rem; 
      padding: 2px 8px; 
      border-radius: 6px;
      background: rgba(16,185,129,0.2); 
      color: var(--accent-green); 
    }
    
    /* RADDOPPI COMBINATI */
    .raddoppi-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 14px; }
    .raddoppio-card {
      background: linear-gradient(145deg, var(--bg-card-light), var(--bg-input));
      border: 2px solid var(--accent-green);
      border-radius: 14px;
      padding: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .raddoppio-card:hover { transform: translateY(-3px); box-shadow: 0 8px 24px rgba(16,185,129,0.2); }
    .raddoppio-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .raddoppio-badge {
      background: var(--accent-green);
      color: var(--bg-dark);
      padding: 4px 10px;
      border-radius: 8px;
      font-size: 0.7rem;
      font-weight: 700;
    }
    .raddoppio-odds {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--accent-cyan);
    }
    .raddoppio-bets { display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; }
    .raddoppio-bet {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: var(--bg-input);
      border-radius: 8px;
    }
    .raddoppio-match { font-size: 0.8rem; color: var(--text-gray); }
    .raddoppio-pick { 
      font-weight: 700; 
      color: var(--accent-cyan);
      padding: 2px 8px;
      background: rgba(34,211,238,0.15);
      border-radius: 4px;
      font-size: 0.8rem;
    }
    .raddoppio-footer { text-align: center; }
    .raddoppio-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      color: var(--accent-green);
      font-weight: 600;
    }
    
    /* MONEY MANAGEMENT */
    .money-section {
      background: linear-gradient(135deg, var(--bg-card), var(--bg-card-light));
      border: 2px solid var(--accent-purple);
      border-radius: 20px;
      padding: 24px;
    }
    .money-header { text-align: center; margin-bottom: 20px; }
    .money-title { 
      font-size: 1.2rem; font-weight: 800; 
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 6px;
    }
    .money-subtitle { font-size: 0.8rem; color: var(--text-dark); }
    .money-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 20px; }
    .money-input-group { display: flex; flex-direction: column; gap: 6px; }
    .money-label { font-size: 0.75rem; color: var(--text-gray); text-transform: uppercase; letter-spacing: 0.5px; }
    .money-input {
      padding: 14px 16px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-white);
      font-size: 1.1rem;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 600;
    }
    .money-input:focus { outline: none; border-color: var(--accent-cyan); }
    .money-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; }
    .money-stat {
      background: var(--bg-input);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
    }
    .money-stat-label { font-size: 0.65rem; color: var(--text-dark); text-transform: uppercase; margin-bottom: 6px; }
    .money-stat-value { font-family: 'JetBrains Mono', monospace; font-size: 1.3rem; font-weight: 700; }
    .money-stat-value.green { color: var(--accent-green); }
    .money-stat-value.cyan { color: var(--accent-cyan); }
    .money-stat-value.yellow { color: var(--accent-yellow); }
    .money-stat-value.purple { color: var(--accent-purple); }
    .money-strategy { 
      margin-top: 16px; 
      padding: 16px; 
      background: var(--bg-card-light); 
      border-radius: 12px; 
      display: flex; 
      flex-wrap: wrap; 
      gap: 12px; 
      justify-content: center;
    }
    .strategy-btn {
      padding: 10px 20px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .strategy-btn:hover { border-color: var(--accent-cyan); color: var(--text-white); }
    .strategy-btn.active { background: var(--accent-purple); border-color: var(--accent-purple); color: white; }
    
    /* SISTEMA OBIETTIVO */
    .money-grid-4 { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); 
      gap: 12px; 
      margin-bottom: 20px; 
    }
    .progress-section { margin-bottom: 20px; }
    .progress-bar-container {
      position: relative;
      height: 32px;
      background: var(--bg-input);
      border-radius: 16px;
      overflow: hidden;
    }
    .progress-bar-fill {
      position: absolute;
      top: 0; left: 0; bottom: 0;
      background: linear-gradient(90deg, var(--accent-green), var(--accent-cyan));
      border-radius: 16px;
      transition: width 0.5s;
    }
    .progress-bar-text {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--text-white);
      text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }
    .stake-section {
      background: linear-gradient(145deg, rgba(34,211,238,0.1), rgba(59,130,246,0.1));
      border: 2px solid var(--accent-cyan);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      text-align: center;
    }
    .stake-section.warning { border-color: var(--accent-yellow); }
    .stake-section.reached { border-color: var(--accent-green); background: rgba(16,185,129,0.15); }
    .stake-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 16px;
      font-size: 0.85rem;
    }
    .stake-label { color: var(--text-gray); font-weight: 600; }
    .stake-remaining { color: var(--accent-cyan); }
    .stake-reached {
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--accent-green);
      padding: 20px;
    }
    .stake-value { margin-bottom: 12px; }
    .stake-amount {
      font-family: 'JetBrains Mono', monospace;
      font-size: 2.5rem;
      font-weight: 800;
      color: var(--accent-cyan);
      text-shadow: 0 0 20px rgba(34,211,238,0.5);
    }
    .stake-info { font-size: 0.85rem; color: var(--text-gray); margin-top: 8px; }
    .stake-warning { 
      font-size: 0.8rem; 
      color: var(--accent-yellow); 
      margin-top: 8px;
      padding: 6px 12px;
      background: rgba(251,191,36,0.1);
      border-radius: 8px;
      display: inline-block;
    }
    .stake-preview {
      font-size: 0.9rem;
      color: var(--text-gray);
      margin-bottom: 16px;
    }
    .stake-preview strong { color: var(--accent-green); }
    .stake-buttons { display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; }
    .stake-btn {
      padding: 12px 28px;
      border: none;
      border-radius: 10px;
      font-size: 0.95rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }
    .stake-btn.win { background: var(--accent-green); color: white; }
    .stake-btn.win:hover { transform: scale(1.05); box-shadow: 0 4px 16px rgba(16,185,129,0.4); }
    .stake-btn.loss { background: var(--accent-red); color: white; }
    .stake-btn.loss:hover { transform: scale(1.05); box-shadow: 0 4px 16px rgba(239,68,68,0.4); }
    .stake-btn.reset { background: var(--bg-card); border: 1px solid var(--border); color: var(--text-gray); }
    .stake-btn.reset:hover { border-color: var(--accent-cyan); color: var(--text-white); }
    
    /* SCHEDINA FLOATING */
    .slip-floating {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      background: rgba(12,18,34,0.98);
      backdrop-filter: blur(20px);
      border-top: 1px solid var(--border);
      padding: 12px 20px;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
    }
    .slip-count {
      display: flex; align-items: center; gap: 8px;
      padding: 8px 16px;
      background: var(--accent-cyan);
      border-radius: 20px;
      font-weight: 700;
      color: var(--bg-dark);
    }
    .slip-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 10px;
      font-size: 0.85rem; font-weight: 700;
      cursor: pointer;
      display: flex; align-items: center; gap: 6px;
    }
    .slip-btn.primary { background: var(--accent-green); color: white; }
    .slip-btn.secondary { background: var(--bg-card); border: 1px solid var(--border); color: var(--text-white); }
    .slip-btn.danger { background: transparent; border: 1px solid var(--accent-red); color: var(--accent-red); }
    
    /* SLIP MODAL */
    .slip-modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .slip-modal-content {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 20px;
      width: 100%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }
    .slip-modal-header {
      padding: 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .slip-modal-title { font-size: 1.2rem; font-weight: 700; }
    .slip-modal-close {
      width: 32px; height: 32px;
      background: var(--bg-input);
      border: none;
      border-radius: 8px;
      color: var(--text-gray);
      cursor: pointer;
      font-size: 1.2rem;
    }
    .slip-modal-body { padding: 20px; }
    .slip-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      background: var(--bg-card-light);
      border-radius: 10px;
      margin-bottom: 10px;
    }
    .slip-item-info { flex: 1; }
    .slip-item-match { font-size: 0.75rem; color: var(--text-dark); margin-bottom: 4px; }
    .slip-item-bet { font-weight: 700; }
    .slip-item-prob { font-size: 0.8rem; color: var(--accent-cyan); }
    .slip-item-remove {
      width: 28px; height: 28px;
      background: transparent;
      border: 1px solid var(--accent-red);
      border-radius: 6px;
      color: var(--accent-red);
      cursor: pointer;
    }
    .slip-total {
      padding: 16px;
      background: var(--bg-input);
      border-radius: 12px;
      text-align: center;
      margin-top: 16px;
    }
    .slip-total-label { font-size: 0.8rem; color: var(--text-dark); margin-bottom: 4px; }
    .slip-total-value { font-size: 1.5rem; font-weight: 800; color: var(--accent-green); }
    
    .loading { display: flex; flex-direction: column; align-items: center; padding: 40px; }
    .spinner { width: 40px; height: 40px; border: 3px solid var(--border); border-top-color: var(--accent-cyan); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 12px; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-text { color: var(--text-gray); font-size: 0.9rem; }
    .empty { text-align: center; padding: 40px; color: var(--text-dark); }
    .empty-icon { font-size: 2.5rem; margin-bottom: 12px; }
    
    @media (max-width: 768px) {
      .main { padding: 16px; }
      .header { padding: 10px 16px; }
      .brand-name { font-size: 1.1rem; }
      .status-bar { font-size: 0.65rem; }
      .hero-match { gap: 16px; }
      .hero-team-logo, .hero-team-logo-fallback { width: 50px; height: 50px; }
      .hero-score-box { width: 40px; height: 40px; font-size: 1.2rem; }
      .analysis-grid { grid-template-columns: 1fr; }
      .predictions-grid { grid-template-columns: repeat(2, 1fr); }
      .stat-grid { grid-template-columns: repeat(3, 1fr); }
      .combo-grid { grid-template-columns: repeat(2, 1fr); }
      .slip-floating { flex-wrap: wrap; gap: 10px; padding: 10px 16px; }
    }
    
    /* TRACKING & STATS */
    .track-btn {
      background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 10px;
      font-weight: 700;
      cursor: pointer;
      margin-top: 12px;
      width: 100%;
      font-size: 0.95rem;
      transition: all 0.3s;
    }
    .track-btn:hover { transform: scale(1.02); box-shadow: 0 4px 15px rgba(16,185,129,0.4); }
    .track-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    .track-btn.tracked { background: var(--text-dark); }
    
    .stats-section {
      background: linear-gradient(145deg, rgba(168,85,247,0.1), rgba(34,211,238,0.1));
      border: 1px solid rgba(168,85,247,0.3);
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .stats-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    .stats-title {
      font-size: 1.1rem;
      font-weight: 800;
      color: var(--accent-purple);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .stats-overview {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }
    .stats-card {
      background: var(--bg-card);
      padding: 16px;
      border-radius: 12px;
      text-align: center;
    }
    .stats-card-value {
      font-size: 1.8rem;
      font-weight: 800;
      color: var(--text-white);
    }
    .stats-card-value.green { color: var(--accent-green); }
    .stats-card-value.red { color: var(--accent-red); }
    .stats-card-value.yellow { color: var(--accent-yellow); }
    .stats-card-label {
      font-size: 0.75rem;
      color: var(--text-gray);
      margin-top: 4px;
    }
    .stats-winrate {
      background: var(--bg-card);
      padding: 20px;
      border-radius: 16px;
      text-align: center;
      margin-bottom: 20px;
    }
    .stats-winrate-value {
      font-size: 3rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .stats-winrate-label {
      font-size: 0.9rem;
      color: var(--text-gray);
    }
    .stats-breakdown {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .stats-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--bg-card);
      padding: 12px 16px;
      border-radius: 10px;
    }
    .stats-row-label {
      font-weight: 600;
      color: var(--text-white);
    }
    .stats-row-value {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .stats-row-wr {
      font-weight: 700;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.85rem;
    }
    .stats-row-wr.good { background: rgba(16,185,129,0.2); color: var(--accent-green); }
    .stats-row-wr.medium { background: rgba(251,191,36,0.2); color: var(--accent-yellow); }
    .stats-row-wr.bad { background: rgba(239,68,68,0.2); color: var(--accent-red); }
    .stats-row-count {
      font-size: 0.8rem;
      color: var(--text-dark);
    }
    .stats-toggle-btn {
      padding: 8px 16px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .stats-toggle-btn:hover { border-color: var(--accent-purple); color: var(--text-white); }
    .stats-toggle-btn.active { background: var(--accent-purple); color: white; border-color: var(--accent-purple); }
    
    .live-track-btn {
      background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      font-weight: 700;
      cursor: pointer;
      font-size: 0.85rem;
      margin-top: 10px;
      transition: all 0.2s;
    }
    .live-track-btn:hover { transform: scale(1.02); }
    .live-track-btn.tracked { background: var(--text-dark); }
    
    /* === CONSIGLI SECTION === */
    .consigli-section {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .consigli-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
    }
    .consigli-title {
      font-size: 1.2rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .consigli-badge {
      padding: 6px 14px;
      background: linear-gradient(135deg, var(--accent-gold), var(--accent-emerald));
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 700;
    }
    .consigli-category {
      background: var(--bg-card-light);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }
    .consigli-category-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border);
    }
    .consigli-category-icon {
      font-size: 1.2rem;
    }
    .consigli-category-title {
      font-weight: 700;
      font-size: 0.95rem;
      color: var(--accent-gold);
      flex: 1;
    }
    .consigli-category-count {
      padding: 4px 10px;
      background: var(--bg-input);
      border-radius: 8px;
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--text-gray);
    }
    .consigli-grid {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .consiglio-card {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .consiglio-card:hover {
      border-color: var(--accent-gold);
      transform: translateX(4px);
    }
    .consiglio-rank {
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, var(--accent-gold), var(--accent-emerald));
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 0.8rem;
      flex-shrink: 0;
    }
    .consiglio-info {
      flex: 1;
      min-width: 0;
    }
    .consiglio-match {
      font-weight: 600;
      font-size: 0.85rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .consiglio-league {
      font-size: 0.7rem;
      color: var(--text-dark);
    }
    .consiglio-bet {
      text-align: right;
      flex-shrink: 0;
    }
    .consiglio-value {
      display: block;
      font-weight: 700;
      font-size: 0.9rem;
      color: var(--accent-gold);
    }
    .consiglio-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      color: var(--accent-emerald);
    }
    .consigli-tab.active {
      background: linear-gradient(135deg, rgba(245,158,11,0.2), rgba(16,185,129,0.2));
      border-color: var(--accent-gold);
      color: var(--accent-gold);
    }
    
    /* === TRADER SECTION === */
    .trader-section {
      background: linear-gradient(135deg, rgba(245,158,11,0.08), rgba(16,185,129,0.08));
      border: 1px solid rgba(245,158,11,0.25);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .trader-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
      flex-wrap: wrap;
      gap: 12px;
    }
    .trader-title {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .trader-icon {
      width: 44px;
      height: 44px;
      background: linear-gradient(135deg, var(--accent-gold), var(--accent-emerald));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      box-shadow: var(--glow-gold);
    }
    .trader-title-text h3 {
      font-size: 1.1rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-gold), var(--accent-emerald));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .trader-title-text p {
      font-size: 0.7rem;
      color: var(--text-dark);
    }
    .trader-stats {
      display: flex;
      gap: 16px;
    }
    .trader-stat {
      text-align: center;
    }
    .trader-stat-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.3rem;
      font-weight: 800;
      color: var(--accent-gold);
    }
    .trader-stat-label {
      font-size: 0.6rem;
      color: var(--text-dark);
      text-transform: uppercase;
    }
    .trader-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    @media (max-width: 768px) {
      .trader-content { grid-template-columns: 1fr; }
    }
    .trader-box {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
    }
    .trader-box-title {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--accent-gold);
    }
    .trader-picks {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .trader-pick {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .trader-pick:hover {
      border-color: var(--accent-gold);
      transform: translateX(4px);
    }
    .trader-pick-info {
      flex: 1;
      min-width: 0;
    }
    .trader-pick-match {
      font-size: 0.8rem;
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .trader-pick-league {
      font-size: 0.65rem;
      color: var(--text-dark);
    }
    .trader-pick-bet {
      text-align: right;
    }
    .trader-pick-value {
      font-weight: 700;
      color: var(--accent-gold);
      font-size: 0.9rem;
    }
    .trader-pick-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      color: var(--accent-emerald);
    }
    .trader-combined {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      background: linear-gradient(135deg, var(--accent-gold), var(--accent-emerald));
      border-radius: 10px;
      margin-top: 12px;
    }
    .trader-combined-label {
      font-size: 0.75rem;
      font-weight: 600;
    }
    .trader-combined-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.2rem;
      font-weight: 800;
    }
    .trader-strategy {
      font-size: 0.7rem;
      color: var(--text-gray);
      background: var(--bg-input);
      padding: 10px;
      border-radius: 8px;
      margin-top: 10px;
      line-height: 1.5;
    }
    .trader-strategy strong {
      color: var(--accent-gold);
    }
    
    /* === TRADER VERDICT (Analysis Page) === */
    .trader-verdict {
      background: linear-gradient(135deg, rgba(245,158,11,0.1), rgba(16,185,129,0.1));
      border: 2px solid rgba(245,158,11,0.3);
      border-radius: 16px;
      padding: 20px;
      margin-top: 20px;
      margin-bottom: 20px;
    }
    .verdict-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .verdict-icon {
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--accent-gold), var(--accent-emerald));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      box-shadow: var(--glow-gold);
    }
    .verdict-title {
      flex: 1;
    }
    .verdict-title h3 {
      font-size: 1.1rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-gold), var(--accent-emerald));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .verdict-title p {
      font-size: 0.7rem;
      color: var(--text-dark);
    }
    .verdict-badge {
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: 700;
      font-size: 0.85rem;
    }
    .verdict-badge.play { background: rgba(34,197,94,0.2); color: #22c55e; }
    .verdict-badge.caution { background: rgba(234,179,8,0.2); color: #eab308; }
    .verdict-badge.avoid { background: rgba(239,68,68,0.2); color: #ef4444; }
    .verdict-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    @media (max-width: 768px) {
      .verdict-content { grid-template-columns: 1fr; }
    }
    .verdict-box {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
    }
    .verdict-box-title {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--accent-gold);
    }
    .verdict-main-pick {
      text-align: center;
      padding: 16px;
      background: var(--bg-input);
      border-radius: 10px;
      margin-bottom: 12px;
    }
    .verdict-main-pick-label {
      font-size: 0.65rem;
      color: var(--text-dark);
      text-transform: uppercase;
      margin-bottom: 6px;
    }
    .verdict-main-pick-value {
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--accent-gold);
      margin-bottom: 4px;
    }
    .verdict-main-pick-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;
      color: var(--accent-emerald);
    }
    .verdict-stars {
      color: var(--accent-gold);
      font-size: 0.9rem;
      margin-top: 6px;
    }
    .verdict-suggestion {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      background: var(--bg-input);
      border-radius: 8px;
      margin-bottom: 8px;
    }
    .verdict-suggestion-icon {
      font-size: 1rem;
    }
    .verdict-suggestion-text {
      font-size: 0.8rem;
      color: var(--text-gray);
    }
    .verdict-suggestion-text strong {
      color: var(--text-white);
    }
    .verdict-warning {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 10px 12px;
      background: rgba(239,68,68,0.1);
      border: 1px solid rgba(239,68,68,0.2);
      border-radius: 8px;
      margin-top: 12px;
    }
    .verdict-warning-icon {
      font-size: 1rem;
      color: var(--accent-red);
    }
    .verdict-warning-text {
      font-size: 0.75rem;
      color: var(--text-gray);
      line-height: 1.4;
    }
    .verdict-warning-text strong {
      color: var(--accent-red);
    }
    
    /* Cache indicator */
    .cache-indicator {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      background: rgba(245,158,11,0.1);
      border-radius: 6px;
      font-size: 0.65rem;
      color: var(--accent-gold);
      margin-left: 10px;
    }
    
    /* === STORICO VARIAZIONI PRONOSTICI === */
    .history-section {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(59, 130, 246, 0.08));
      border: 1px solid rgba(139, 92, 246, 0.25);
      border-radius: 16px;
      padding: 20px;
      margin-top: 20px;
      margin-bottom: 20px;
    }
    .history-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .history-icon {
      width: 44px;
      height: 44px;
      background: linear-gradient(135deg, var(--accent-purple), #3b82f6);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.3rem;
    }
    .history-title h3 {
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-white);
    }
    .history-title p {
      font-size: 0.7rem;
      color: var(--text-dark);
    }
    .history-timeline {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .history-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
    }
    .history-item.current {
      border-color: var(--accent-gold);
      background: rgba(245, 158, 11, 0.08);
    }
    .history-item.significant {
      border-color: var(--accent-yellow);
      background: rgba(251, 191, 36, 0.08);
    }
    .history-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      color: var(--text-dark);
      min-width: 50px;
    }
    .history-pick {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .history-pick-value {
      font-weight: 700;
      color: var(--accent-gold);
      font-size: 0.85rem;
    }
    .history-pick-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      padding: 2px 8px;
      background: rgba(16, 185, 129, 0.2);
      color: var(--accent-green);
      border-radius: 4px;
    }
    .history-change {
      font-size: 0.65rem;
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: 600;
      white-space: nowrap;
    }
    .history-change.first { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
    .history-change.minor { background: rgba(100, 116, 139, 0.2); color: var(--text-gray); }
    .history-change.significant { background: rgba(251, 191, 36, 0.2); color: var(--accent-yellow); }
    .history-change.major { background: rgba(239, 68, 68, 0.2); color: var(--accent-red); }
    .history-empty {
      text-align: center;
      padding: 20px;
      color: var(--text-dark);
      font-size: 0.85rem;
    }
    .history-stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    .history-stat {
      text-align: center;
    }
    .history-stat-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--accent-purple);
    }
    .history-stat-label {
      font-size: 0.6rem;
      color: var(--text-dark);
      text-transform: uppercase;
    }
    
    /* === PERFORMANCE & GRAFICI === */
    .chart-container {
      position: relative;
      background: var(--bg-card);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      border: 1px solid var(--border);
    }
    .chart-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }
    .chart-title {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--text-white);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .chart-filters {
      display: flex;
      gap: 8px;
    }
    .chart-filter-btn {
      padding: 6px 12px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-gray);
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .chart-filter-btn:hover {
      border-color: var(--accent-cyan);
      color: var(--text-white);
    }
    .chart-filter-btn.active {
      background: var(--accent-cyan);
      color: white;
      border-color: var(--accent-cyan);
    }
    .chart-canvas-wrapper {
      position: relative;
      height: 300px;
    }
    canvas {
      max-height: 100%;
    }
    .performance-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 16px;
      margin-bottom: 20px;
    }
    .performance-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
    }
    .performance-card-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }
    .performance-card-icon {
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-purple));
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
    }
    .performance-card-title {
      flex: 1;
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-white);
    }
    .ml-insights {
      background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(59,130,246,0.1));
      border: 2px solid rgba(139,92,246,0.3);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .ml-insights-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .ml-insights-icon {
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      box-shadow: 0 0 20px rgba(139,92,246,0.4);
    }
    .ml-insights-title {
      font-size: 1.2rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .ml-suggestion-card {
      background: var(--bg-card);
      border: 1px solid rgba(139,92,246,0.3);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 12px;
    }
    .ml-suggestion-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    .ml-suggestion-market {
      font-weight: 700;
      color: var(--accent-purple);
      font-size: 0.95rem;
    }
    .ml-suggestion-status {
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.7rem;
      font-weight: 600;
    }
    .ml-suggestion-status.improving {
      background: rgba(16,185,129,0.2);
      color: var(--accent-green);
    }
    .ml-suggestion-status.declining {
      background: rgba(239,68,68,0.2);
      color: var(--accent-red);
    }
    .ml-suggestion-status.stable {
      background: rgba(251,191,36,0.2);
      color: var(--accent-yellow);
    }
    .ml-suggestion-body {
      font-size: 0.85rem;
      color: var(--text-gray);
      line-height: 1.5;
    }
    .ml-suggestion-body strong {
      color: var(--text-white);
    }
    
    /* Box Confronto Prima vs Ora */
    .history-compare {
      background: linear-gradient(135deg, rgba(245,158,11,0.15), rgba(16,185,129,0.15));
      border: 2px solid rgba(245,158,11,0.4);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }
    .history-compare-title {
      font-size: 0.75rem;
      font-weight: 700;
      color: var(--accent-gold);
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .history-compare-grid {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 12px;
      align-items: center;
    }
    .history-compare-box {
      background: var(--bg-card);
      border-radius: 10px;
      padding: 12px;
      text-align: center;
    }
    .history-compare-box.first {
      border: 1px solid var(--text-dark);
    }
    .history-compare-box.current {
      border: 2px solid var(--accent-gold);
    }
    .history-compare-label {
      font-size: 0.65rem;
      color: var(--text-dark);
      margin-bottom: 4px;
    }
    .history-compare-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      color: var(--text-gray);
      margin-bottom: 6px;
    }
    .history-compare-pick {
      font-size: 1rem;
      font-weight: 700;
      color: var(--accent-gold);
      margin-bottom: 4px;
    }
    .history-compare-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      color: var(--accent-emerald);
    }
    .history-compare-arrow {
      font-size: 1.5rem;
      color: var(--text-dark);
    }
    .history-compare-arrow.changed {
      color: var(--accent-red);
    }
    .history-compare-arrow.stable {
      color: var(--accent-green);
    }
    .history-compare-verdict {
      text-align: center;
      margin-top: 12px;
      padding: 10px;
      border-radius: 8px;
      font-size: 0.8rem;
      font-weight: 600;
    }
    .history-compare-verdict.changed {
      background: rgba(239,68,68,0.15);
      color: var(--accent-red);
    }
    .history-compare-verdict.stable {
      background: rgba(34,197,94,0.15);
      color: var(--accent-green);
    }
    .history-compare-diff {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem;
      margin-top: 4px;
    }
    
    @media (max-width: 600px) {
      .stats-overview { grid-template-columns: repeat(2, 1fr); }
      .history-stats { grid-template-columns: repeat(2, 1fr); }
      .history-compare-grid { grid-template-columns: 1fr; gap: 8px; }
      .history-compare-arrow { transform: rotate(90deg); }
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <script>
    // ===================================================
    // BETTINGPRO v5 - COMPLETO CON SCHEDINA E FIREBASE
    // ===================================================
    
    // ============================================
    // CONFIG: Backend Proxy (SICURO) o Direct API (INSICURO)
    // ============================================
    // IMPORTANTE: Se usi GitHub Pages, devi deployare il backend proxy su Vercel
    // e cambiare USE_BACKEND_PROXY = true + impostare BACKEND_URL
    // Vedi README-SECURITY.md per istruzioni
    
    const USE_BACKEND_PROXY = false; // Cambia a true quando deployi il backend
    const BACKEND_URL = 'https://bettingpro-backend.vercel.app'; // SOSTITUISCI con il tuo URL Vercel
    
    const CONFIG = {
      // Se usi backend proxy, API_FOOTBALL e FOOTYSTATS punteranno al backend
      // Altrimenti usano le keys dirette (INSICURO per produzione!)
      API_FOOTBALL: {
        key: USE_BACKEND_PROXY ? '' : 'aeb2864a3d4dbb8395fa53c83a876a93',
        baseURL: USE_BACKEND_PROXY ? `${BACKEND_URL}/api/football` : 'https://v3.football.api-sports.io'
      },
      FOOTYSTATS: {
        key: USE_BACKEND_PROXY ? '' : 'bec59b6f83404b0bd79c40076be71f6f3abec62afdacf5eeba296f2357993f3e',
        baseURL: USE_BACKEND_PROXY ? `${BACKEND_URL}/api/footystats` : 'https://api.footystats.org'
      },
      // Firebase rimosso per performance
    };

    // Generate unique user ID
    const getUserId = () => {
      let id = localStorage.getItem('bettingpro_uid');
      if (!id) {
        id = 'user_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('bettingpro_uid', id);
      }
      return id;
    };
    const USER_ID = getUserId();

    // Firebase RIMOSSO - Usiamo solo localStorage per performance

    let state = {
      view: 'leagues', // 'leagues', 'matches', 'analysis', 'performance'
      selectedDate: 0, // 0=oggi, -1=ieri, 1=domani, 2=dopodomani
      leagues: [],
      matches: [],
      selectedLeague: null,
      selectedMatch: null,
      analysis: null,
      loading: false,
      api: { 
        football: localStorage.getItem('api_football_status') || 'offline', 
        footystats: localStorage.getItem('api_footystats_status') || 'offline'
      },
      fsData: new Map(),
      slip: [], // Schedina
      slipModal: false,
      // Picks del giorno
      dailyPicks: { raddoppi: [], gg: [], over25: [], pareggi: [], over1T: [], vittorieCasa: [], vittorieOspite: [] },
      // Money Management - Sistema Obiettivo
      money: {
        bankroll: parseFloat(localStorage.getItem('bp2_bankroll')) || 100,
        target: parseFloat(localStorage.getItem('bp2_target')) || 500,
        totalBets: parseInt(localStorage.getItem('bp2_totalbets')) || 10,
        currentBet: parseInt(localStorage.getItem('bp2_currentbet')) || 1,
        currentOdds: parseFloat(localStorage.getItem('bp2_odds')) || 1.80,
        history: JSON.parse(localStorage.getItem('bp2_history') || '[]')
      },
      // LIVE Betting (deprecato - mantengo variabili per compatibilitÃ )
      consigliMode: false,
      liveMode: false,
      liveMatches: [],
      liveAlerts: [],
      liveLoading: false,
      liveInterval: null,
      liveBackgroundInterval: null,
      countdownInterval: null,
      liveCountdown: 60,
      // Tracking Pronostici
      trackedBets: JSON.parse(localStorage.getItem('bp2_tracked') || '[]'),
      // Machine Learning Thresholds
      mlThresholds: JSON.parse(localStorage.getItem('bp2_ml_thresholds') || JSON.stringify({
        '1': { threshold: 50, accuracy: 0, totalPredictions: 0, correctPredictions: 0 },
        'X': { threshold: 28, accuracy: 0, totalPredictions: 0, correctPredictions: 0 },
        '2': { threshold: 50, accuracy: 0, totalPredictions: 0, correctPredictions: 0 },
        'GG': { threshold: 55, accuracy: 0, totalPredictions: 0, correctPredictions: 0 },
        'Over 2.5': { threshold: 50, accuracy: 0, totalPredictions: 0, correctPredictions: 0 }
      })),
      // Performance Charts Data
      performanceHistory: JSON.parse(localStorage.getItem('bp2_performance_history') || '[]'),
      // NUOVO: Cache Classifica e Infortunati
      standingsCache: new Map(),
      injuriesCache: new Map(),
      // NUOVO: Impostazioni soglie configurabili
      settings: JSON.parse(localStorage.getItem('bp2_settings') || JSON.stringify({
        thresholds: {
          '1': 50,
          'X': 28,
          '2': 50,
          'GG': 55,
          'Over 2.5': 50,
          'Over 1.5': 65
        },
        showInjuries: true,
        showStandings: true,
        autoRefresh: true
      })),
      settingsOpen: false,

  smartFilters: {
    active: '1',
    results: []
  },
      statsView: false,
      // TRADER Section
      traderPicks: {
        raddoppio: [],
        singole: []
      },
      // STORICO VARIAZIONI PRONOSTICI
      predictionHistory: JSON.parse(localStorage.getItem('bp2_prediction_history') || '{}')
    };

    // === FUNZIONI STORICO VARIAZIONI ===
    
    function savePredictionToHistory(matchId, matchName, prediction) {
      const key = String(matchId);
      const now = new Date();
      const timestamp = now.toLocaleTimeString('it-IT', {hour:'2-digit', minute:'2-digit'});
      const fullTimestamp = now.getTime();
      
      if (!state.predictionHistory[key]) {
        state.predictionHistory[key] = {
          matchName: matchName,
          date: getDateString(state.selectedDate),
          predictions: []
        };
      }
      
      const history = state.predictionHistory[key].predictions;
      const lastPred = history.length > 0 ? history[history.length - 1] : null;
      
      let changeType = 'first';
      if (lastPred) {
        const pickChanged = lastPred.pick !== prediction.pick;
        const probDiff = Math.abs(prediction.prob - lastPred.prob);
        
        if (pickChanged) {
          changeType = 'major';
        } else if (probDiff >= 10) {
          changeType = 'significant';
        } else if (probDiff >= 3) {
          changeType = 'minor';
        } else {
          return; // Nessun cambiamento rilevante (< 3%)
        }
      }
      
      history.push({
        time: timestamp,
        fullTime: fullTimestamp,
        pick: prediction.pick,
        prob: prediction.prob,
        changeType: changeType
      });
      
      if (history.length > 10) {
        state.predictionHistory[key].predictions = history.slice(-10);
      }
      
      savePredictionHistory();
      console.log('ðŸ“œ Storico:', matchName, changeType, prediction.pick, prediction.prob + '%');
    }
    
    function savePredictionHistory() {
      try {
        const twoDaysAgo = new Date();
        twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);
        const cutoffDate = twoDaysAgo.toISOString().split('T')[0];
        
        Object.keys(state.predictionHistory).forEach(key => {
          if (state.predictionHistory[key].date < cutoffDate) {
            delete state.predictionHistory[key];
          }
        });
        
        localStorage.setItem('bp2_prediction_history', JSON.stringify(state.predictionHistory));
      } catch(e) { console.warn('Errore salvataggio storico:', e); }
    }
    
    function getPredictionHistory(matchId) {
      return state.predictionHistory[String(matchId)]?.predictions || [];
    }
    
    function getHistoryStats(matchId) {
      const history = getPredictionHistory(matchId);
      if (history.length === 0) return null;
      
      return {
        totalChanges: history.length - 1,
        majorChanges: history.filter(h => h.changeType === 'major').length,
        significantChanges: history.filter(h => h.changeType === 'significant').length,
        pickChanged: history.length > 1 ? history[0].pick !== history[history.length - 1].pick : false
      };
    }
    
    function renderHistorySection(matchId) {
      const history = getPredictionHistory(matchId);
      const stats = getHistoryStats(matchId);
      
      // Caso: Prima analisi
      if (!history || history.length === 0) {
        return '<div class="history-section">' +
          '<div class="history-header">' +
            '<div class="history-icon">ðŸ“œ</div>' +
            '<div class="history-title">' +
              '<h3>Storico Variazioni</h3>' +
              '<p>Traccia le variazioni dei pronostici nel tempo</p>' +
            '</div>' +
          '</div>' +
          '<div class="history-empty">' +
            'ðŸ“Š <strong>Prima analisi registrata!</strong><br>' +
            '<span style="font-size:0.75rem;color:var(--text-dark);">Riapri questa partita tra qualche ora per vedere eventuali variazioni del pronostico.</span>' +
          '</div>' +
        '</div>';
      }
      
      // Box CONFRONTO PRIMA vs ORA (solo se ci sono almeno 2 registrazioni o 1 con cambio)
      let compareHtml = '';
      const first = history[0];
      const last = history[history.length - 1];
      
      if (history.length >= 1) {
        const pickChanged = first.pick !== last.pick;
        const probDiff = last.prob - first.prob;
        const probDiffAbs = Math.abs(probDiff);
        const hasChanges = history.length > 1;
        
        let arrowClass = 'stable';
        let verdictClass = 'stable';
        let verdictText = 'âœ… Pronostico stabile - Nessuna variazione rilevata';
        
        if (pickChanged) {
          arrowClass = 'changed';
          verdictClass = 'changed';
          verdictText = 'âš ï¸ ATTENZIONE: Il pronostico Ã¨ cambiato!';
        } else if (hasChanges && probDiffAbs >= 10) {
          arrowClass = 'changed';
          verdictClass = 'changed';
          verdictText = 'âš ï¸ Variazione significativa della probabilitÃ ';
        } else if (hasChanges) {
          verdictText = 'âœ… Pronostico confermato con piccole variazioni';
        }
        
        let diffText = '';
        if (hasChanges) {
          if (probDiff > 0) {
            diffText = '<span style="color:var(--accent-green);">+' + probDiff.toFixed(0) + '%</span>';
          } else if (probDiff < 0) {
            diffText = '<span style="color:var(--accent-red);">' + probDiff.toFixed(0) + '%</span>';
          } else {
            diffText = '<span style="color:var(--text-gray);">Â±0%</span>';
          }
        }
        
        compareHtml = '<div class="history-compare">' +
          '<div class="history-compare-title">ðŸ“Š CONFRONTO PRONOSTICI</div>' +
          '<div class="history-compare-grid">' +
            '<div class="history-compare-box first">' +
              '<div class="history-compare-label">PRIMA ANALISI</div>' +
              '<div class="history-compare-time">ðŸ• ' + first.time + '</div>' +
              '<div class="history-compare-pick">' + first.pick + '</div>' +
              '<div class="history-compare-prob">' + first.prob.toFixed(0) + '%</div>' +
            '</div>' +
            '<div class="history-compare-arrow ' + arrowClass + '">' + (hasChanges ? 'â†’' : 'â€¢') + '</div>' +
            '<div class="history-compare-box current">' +
              '<div class="history-compare-label">ORA</div>' +
              '<div class="history-compare-time">ðŸ• ' + last.time + '</div>' +
              '<div class="history-compare-pick">' + last.pick + '</div>' +
              '<div class="history-compare-prob">' + last.prob.toFixed(0) + '%</div>' +
            '</div>' +
          '</div>' +
          '<div class="history-compare-verdict ' + verdictClass + '">' +
            verdictText +
            (hasChanges ? '<div class="history-compare-diff">Differenza: ' + diffText + '</div>' : '') +
          '</div>' +
        '</div>';
      }
      
      // Timeline dettagliata (solo se piÃ¹ di 1 registrazione)
      let historyHtml = '';
      if (history.length > 1) {
        historyHtml = '<div style="font-size:0.75rem;color:var(--text-dark);margin-bottom:10px;font-weight:600;">ðŸ“œ CRONOLOGIA COMPLETA</div>';
        history.forEach(function(item, index) {
          const isLast = index === history.length - 1;
          const isFirst = index === 0;
          const itemClass = isLast ? 'current' : (item.changeType === 'major' || item.changeType === 'significant' ? 'significant' : '');
          
          let changeLabel = '', changeClass = '';
          if (item.changeType === 'first') { changeLabel = '1Â° ANALISI'; changeClass = 'first'; }
          else if (item.changeType === 'minor') { changeLabel = 'â†• Â±3-9%'; changeClass = 'minor'; }
          else if (item.changeType === 'significant') { changeLabel = 'âš ï¸ Â±10%+'; changeClass = 'significant'; }
          else if (item.changeType === 'major') { changeLabel = 'ðŸ”„ CAMBIO!'; changeClass = 'major'; }
          
          historyHtml += '<div class="history-item ' + itemClass + '">' +
            '<span class="history-time">ðŸ• ' + item.time + '</span>' +
            '<div class="history-pick">' +
              '<span class="history-pick-value">' + item.pick + '</span>' +
              '<span class="history-pick-prob">' + item.prob.toFixed(0) + '%</span>' +
            '</div>' +
            '<span class="history-change ' + changeClass + '">' + changeLabel + '</span>' +
          '</div>';
        });
      }
      
      // Statistiche
      let statsHtml = '';
      if (stats && stats.totalChanges > 0) {
        statsHtml = '<div class="history-stats">' +
          '<div class="history-stat"><div class="history-stat-value">' + stats.totalChanges + '</div><div class="history-stat-label">Variazioni</div></div>' +
          '<div class="history-stat"><div class="history-stat-value">' + stats.majorChanges + '</div><div class="history-stat-label">Cambi Pick</div></div>' +
          '<div class="history-stat"><div class="history-stat-value">' + (stats.pickChanged ? 'âš ï¸' : 'âœ…') + '</div><div class="history-stat-label">' + (stats.pickChanged ? 'Cambiato' : 'Stabile') + '</div></div>' +
        '</div>';
      }
      
      return '<div class="history-section">' +
        '<div class="history-header">' +
          '<div class="history-icon">ðŸ“œ</div>' +
          '<div class="history-title"><h3>Storico Variazioni</h3><p>Monitora i cambiamenti del pronostico</p></div>' +
        '</div>' +
        compareHtml +
        (history.length > 1 ? '<div class="history-timeline">' + historyHtml + '</div>' : '') +
        statsHtml +
      '</div>';
    }

    // === UTILITIES ===
    const esc = t => String(t || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]));
    const clamp = (min, v, max) => Math.max(min, Math.min(max, v));
    const formatTime = d => d ? new Date(d).toLocaleTimeString('it-IT', {hour:'2-digit', minute:'2-digit'}) : '--:--';
    const formatDate = d => d ? new Date(d).toLocaleDateString('it-IT', {day:'2-digit', month:'2-digit'}) : '--/--';
    const formatDateFull = d => d ? new Date(d).toLocaleDateString('it-IT', {weekday:'short', day:'2-digit', month:'short'}) : '';
    const getInitials = n => n ? n.split(' ').map(w => w[0]).join('').slice(0,3).toUpperCase() : '??';
    
    function getDateString(offset = 0) {
      const d = new Date();
      d.setDate(d.getDate() + offset);
      return d.toISOString().split('T')[0];
    }
    
    function getDateLabel(offset) {
      if (offset === -1) return 'Ieri';
      if (offset === 0) return 'Oggi';
      if (offset === 1) return 'Domani';
      if (offset === 2) return 'Dopodomani';
      return '';
    }

    // Poisson
    const factorial = n => { let r = 1; for (let i = 2; i <= n; i++) r *= i; return r; };
    const poisson = (l, k) => l <= 0 ? (k === 0 ? 1 : 0) : (Math.pow(l, k) * Math.exp(-l)) / factorial(k);

    // === SMART FILTERS - Filtri intelligenti con prob combinata AI + Statistica ===
    function calculateSmartFilters(filterType) {
      if (state.matches.length === 0) return [];
      const results = [];

      state.matches.forEach(match => {
        if (['1H','2H','HT','ET','P','LIVE','FT','AET','PEN'].includes(match.status)) return;

        // xG variabili basati su campionato (stima)
        let homeXG = 1.50, awayXG = 1.15;
        
        // Boost per campionati offensivi noti
        const offensiveLeagues = [39, 140, 135, 78, 61, 88, 94]; // PL, LaLiga, SerieA, Bundesliga, L1, Eredivisie, Primeira
        if (offensiveLeagues.includes(match.league.id)) {
          homeXG = 1.60;
          awayXG = 1.25;
        }
        
        // FootyStats data
        const fsKeys = [
          `${match.home.name.toLowerCase()}${match.away.name.toLowerCase()}`,
          `${match.home.name.toLowerCase().replace(/\s/g, '')}${match.away.name.toLowerCase().replace(/\s/g, '')}`
        ];
        let fsMatch = null;
        for (const k of fsKeys) {
          if (state.fsData.has(k)) {
            fsMatch = state.fsData.get(k);
            break;
          }
        }

        if (fsMatch) {
          if (fsMatch.homexg) homeXG = fsMatch.homexg;
          else if (fsMatch.homeppg) homeXG = fsMatch.homeppg * 0.85;
          else if (fsMatch.avggoalshome) homeXG = fsMatch.avggoalshome;

          if (fsMatch.awayxg) awayXG = fsMatch.awayxg;
          else if (fsMatch.awayppg) awayXG = fsMatch.awayppg * 0.75;
          else if (fsMatch.avggoalsaway) awayXG = fsMatch.avggoalsaway;
        }

        // Home advantage
        homeXG *= 1.12;
        awayXG *= 0.92;
        homeXG = clamp(0.4, homeXG, 3.5);
        awayXG = clamp(0.25, awayXG, 3.0);

        const p1X2 = quickCalc1X2(homeXG, awayXG);
        const pGG = quickCalcBTTS(homeXG, awayXG);
        const pNG = 100 - pGG; // No Goal = 100% - GG
        const pOver15 = quickCalcOver(homeXG, awayXG, 1.5);
        const pOver25 = quickCalcOver(homeXG, awayXG, 2.5);
        const pUnder25 = 100 - pOver25; // Under = 100% - Over

        let prob = 0, pick = '';

        if (filterType === '1') {
          prob = p1X2.home;
          pick = '1';
        } else if (filterType === 'X') {
          prob = p1X2.draw;
          pick = 'X';
        } else if (filterType === '2') {
          prob = p1X2.away;
          pick = '2';
        } else if (filterType === 'GG') {
          prob = pGG;
          pick = 'GG';
        } else if (filterType === 'NG') {
          prob = pNG;
          pick = 'NG';
        } else if (filterType === 'Over 2.5') {
          prob = pOver25;
          pick = 'O 2.5';
        } else if (filterType === 'Under 2.5') {
          prob = pUnder25;
          pick = 'U 2.5';
        } else if (filterType === 'Over 1.5') {
          prob = pOver15;
          pick = 'O 1.5';
        }

        // Aggiungi TUTTE le partite (nessuna soglia)
        results.push({
          match,
          pick,
          prob: prob.toFixed(1),
          time: formatTime(match.date),
          league: `${match.league.country} - ${match.league.name}`
        });
      });

      // Ordina per probabilitÃ  decrescente e prendi le prime 40
      return results.sort((a, b) => parseFloat(b.prob) - parseFloat(a.prob)).slice(0, 40);
    }

    function setSmartFilter(type) {
      state.smartFilters.active = type;
      state.smartFilters.results = calculateSmartFilters(type);
      render();
    }
    
    // Seleziona una partita dal filtro e avvia l'analisi
    function selectMatch(matchId) {
      const match = state.matches.find(m => m.id === matchId);
      if (match) {
        analyzeMatch(match);
      } else {
        console.warn('Partita non trovata:', matchId);
      }
    }

    // === DAILY PICKS - Analisi rapida di tutte le partite ===
    
    // Campionati TOP con dati affidabili (IDs API-Football)
    const TOP_LEAGUES = [
      // Italia
      135, 136, // Serie A, Serie B
      // Inghilterra
      39, 40, 41, // Premier, Championship, League One
      // Spagna
      140, 141, // La Liga, Segunda
      // Germania
      78, 79, // Bundesliga, 2. Bundesliga
      // Francia
      61, 62, // Ligue 1, Ligue 2
      // Altri top
      88,  // Eredivisie (Olanda)
      94,  // Primeira Liga (Portogallo)
      144, // Jupiler Pro (Belgio)
      203, // Super Lig (Turchia)
      // Coppe europee
      2, 3, 848, // Champions, Europa League, Conference
    ];
    
    function calculateDailyPicks() {
      if (state.matches.length === 0) return;
      
      const picks = { raddoppi: [], gg: [], over25: [], pareggi: [], over1T: [], vittorieCasa: [], vittorieOspite: [] };
      const safeBets = []; // Per costruire i raddoppi
      
      // Raccogli i consigli AI per tutte le partite
      const allAdvices = [];
      
      state.matches.forEach(match => {
        // Skip partite giÃ  iniziate o finite
        if (['1H','2H','HT','ET','P','LIVE','FT','AET','PEN'].includes(match.status)) return;
        
        // Calcolo rapido basato su FootyStats se disponibile
        let fsMatch = null;
        const fsKeys = [
          `${match.home.name.toLowerCase()}_${match.away.name.toLowerCase()}`,
          match.home.name.toLowerCase().replace(/\s+/g, '') + '_' + match.away.name.toLowerCase().replace(/\s+/g, '')
        ];
        for (const k of fsKeys) {
          if (state.fsData.has(k)) { fsMatch = state.fsData.get(k); break; }
        }
        
        // Stima xG base
        let homeXG = 1.55, awayXG = 1.25;
        let homeFormMultiplier = 1.0, awayFormMultiplier = 1.0;
        let dataQuality = 'low'; // low, medium, high
        
        if (fsMatch) {
          if (fsMatch.home_xg) {
            homeXG = fsMatch.home_xg;
            dataQuality = 'high';
          } else if (fsMatch.home_ppg) {
            homeXG = fsMatch.home_ppg * 0.8;
            dataQuality = 'medium';
          } else if (fsMatch.avg_goals_home) {
            homeXG = fsMatch.avg_goals_home;
            dataQuality = 'medium';
          }
          
          if (fsMatch.away_xg) {
            awayXG = fsMatch.away_xg;
          } else if (fsMatch.away_ppg) {
            awayXG = fsMatch.away_ppg * 0.7;
          } else if (fsMatch.avg_goals_away) {
            awayXG = fsMatch.avg_goals_away;
          }
          
          // PATTERN CASA/TRASFERTA AVANZATO
          // Analizza performance specifica casa vs trasferta
          if (fsMatch.home_ppg && fsMatch.away_ppg) {
            // Se casa ha ppg alto in casa â†’ boost
            if (fsMatch.home_ppg >= 2.0) homeFormMultiplier = 1.12;
            else if (fsMatch.home_ppg >= 1.5) homeFormMultiplier = 1.06;
            else if (fsMatch.home_ppg <= 0.8) homeFormMultiplier = 0.90;
            
            // Se ospite ha ppg alto in trasferta â†’ boost
            if (fsMatch.away_ppg >= 1.8) awayFormMultiplier = 1.10;
            else if (fsMatch.away_ppg >= 1.2) awayFormMultiplier = 1.04;
            else if (fsMatch.away_ppg <= 0.6) awayFormMultiplier = 0.88;
          }
        }
        
        // Applica moltiplicatori forma
        homeXG *= homeFormMultiplier;
        awayXG *= awayFormMultiplier;
        
        // Home advantage (casa gioca meglio, trasferta peggio)
        homeXG *= 1.10;
        awayXG *= 0.93;
        
        homeXG = clamp(0.3, homeXG, 3.5);
        awayXG = clamp(0.2, awayXG, 3.0);
        
        const totXG = homeXG + awayXG;
        
        // Calcola probabilitÃ 
        const p1X2 = quickCalc1X2(homeXG, awayXG);
        const pOver15 = quickCalcOver(homeXG, awayXG, 1.5);
        const pOver25 = quickCalcOver(homeXG, awayXG, 2.5);
        const pOver35 = quickCalcOver(homeXG, awayXG, 3.5);
        const pUnder25 = 100 - pOver25;
        const pBTTS = quickCalcBTTS(homeXG, awayXG);
        
        const matchInfo = {
          match,
          matchName: `${match.home.name} vs ${match.away.name}`,
          shortName: `${match.home.name.substring(0,12)} - ${match.away.name.substring(0,12)}`,
          league: `${match.league.country} - ${match.league.name}`,
          time: formatTime(match.date),
          xgTotal: totXG.toFixed(2),
          totXG: totXG.toFixed(2),
          homeXG: homeXG.toFixed(2),
          awayXG: awayXG.toFixed(2)
        };
        
        // === GENERA CONSIGLIO AI RAPIDO (simile a generateAIAdvice) ===
        const homeStrong = homeXG > 1.8;
        const awayWeak = awayXG < 0.8;
        const awayStrong = awayXG > 1.5;
        const homeWeak = homeXG < 1.0;
        const highScoring = totXG >= 3.0;
        const veryHighScoring = totXG >= 3.8;
        const lowScoring = totXG < 2.2;
        const balanced = Math.abs(homeXG - awayXG) < 0.5;
        const ggLikely = pBTTS >= 55 && homeXG > 0.9 && awayXG > 0.9;
        
        // Multigoal per squadra (per calcolo X intelligente)
        const mgHome = quickCalcOver(homeXG, 0, 0.5); // Prob che casa segni almeno 1
        const mgAway = quickCalcOver(awayXG, 0, 0.5); // Prob che ospite segni almeno 1
        
        let aiPick = '';
        let aiProb = 0;
        let confidence = 'low';
        
        // Logica di selezione (come generateAIAdvice) con soglie piÃ¹ alte
        if (homeStrong && awayWeak && p1X2.home >= 68) {
          aiPick = '1 (Vittoria Casa)';
          aiProb = p1X2.home;
          confidence = p1X2.home >= 75 ? 'high' : 'medium';
        }
        else if (awayStrong && homeWeak && p1X2.away >= 63) {
          aiPick = '2 (Vittoria Ospite)';
          aiProb = p1X2.away;
          confidence = p1X2.away >= 70 ? 'high' : 'medium';
        }
        else if (veryHighScoring && pOver25 >= 72) {
          aiPick = 'Over 2.5';
          aiProb = pOver25;
          confidence = pOver25 >= 80 ? 'high' : 'medium';
        }
        else if (ggLikely && pBTTS >= 63) {
          aiPick = 'GG (Entrambe Segnano)';
          aiProb = pBTTS;
          confidence = pBTTS >= 72 ? 'high' : 'medium';
        }
        else if (pOver15 >= 82) {
          aiPick = 'Over 1.5';
          aiProb = pOver15;
          confidence = pOver15 >= 88 ? 'high' : 'medium';
        }
        else if ((p1X2.home + p1X2.draw) >= 82) {
          aiPick = '1X (Casa o Pareggio)';
          aiProb = p1X2.home + p1X2.draw;
          confidence = aiProb >= 88 ? 'high' : 'medium';
        }
        // CALCOLO INTELLIGENTE PER X
        // Se % X Ã¨ alta, MG squadre basse, Under alto â†’ potrebbe essere X
        else if (balanced && p1X2.draw >= 30 && mgHome < 68 && mgAway < 68 && pUnder25 >= 58) {
          aiPick = 'X (Pareggio)';
          aiProb = p1X2.draw;
          confidence = p1X2.draw >= 35 ? 'high' : 'medium';
        }
        else if (pOver15 >= 75) {
          aiPick = 'Over 1.5';
          aiProb = pOver15;
          confidence = 'low';
        }
        
        // CALCOLO CONFIDENCE FINALE basato su qualitÃ  dati + probabilitÃ 
        if (dataQuality === 'high' && aiProb >= 75) confidence = 'high';
        else if (dataQuality === 'high' && aiProb >= 65) {
          if (confidence === 'low') confidence = 'medium';
        }
        else if (dataQuality === 'low' && confidence === 'high') confidence = 'medium';
        
        // Skip pick se probabilitÃ  troppo bassa o confidence troppo bassa
        if (!aiPick || aiProb < 58 || confidence === 'low') return;
        
        // Salva il consiglio AI
        allAdvices.push({
          ...matchInfo,
          aiPick,
          aiProb,
          confidence,
          dataQuality,
          p1X2,
          pOver25,
          pBTTS
        });
        
        // === COSTRUISCI RADDOPPI (solo campionati top) ===
        const isTopLeague = TOP_LEAGUES.includes(match.league.id);
        if (isTopLeague) {
          const p1X = p1X2.home + p1X2.draw;
          const pX2 = p1X2.draw + p1X2.away;
          
          if (p1X >= 72) safeBets.push({ ...matchInfo, bet: '1X', prob: p1X, odds: (100 / p1X).toFixed(2) });
          if (pX2 >= 72) safeBets.push({ ...matchInfo, bet: 'X2', prob: pX2, odds: (100 / pX2).toFixed(2) });
          if (pOver15 >= 75) safeBets.push({ ...matchInfo, bet: 'Over 1.5', prob: pOver15, odds: (100 / pOver15).toFixed(2) });
          if (p1X2.home >= 65) safeBets.push({ ...matchInfo, bet: '1', prob: p1X2.home, odds: (100 / p1X2.home).toFixed(2) });
          if (p1X2.away >= 60) safeBets.push({ ...matchInfo, bet: '2', prob: p1X2.away, odds: (100 / p1X2.away).toFixed(2) });
        }
      });
      
      // === RAGGRUPPA TUTTE LE PROBABILITÃ€ (NON SOLO IL CONSIGLIO PRINCIPALE) ===
      // Questa logica prende TUTTE le probabilitÃ  dalla sezione "PRONOSTICI AI"
      // e le raggruppa per categoria (1, X, 2, GG, Over 2.5)
      allAdvices.forEach(advice => {
        const { p1X2, pOver25, pBTTS, matchInfo, match, confidence, dataQuality } = advice;
        
        // Aggiungi 1 (Vittoria Casa) se probabilitÃ  >= 50%
        if (p1X2.home >= 50) {
          picks.vittorieCasa.push({
            ...matchInfo,
            match,
            bet: '1',
            prob: p1X2.home,
            confidence: p1X2.home >= 70 ? 'high' : (p1X2.home >= 60 ? 'medium' : 'low'),
            dataQuality
          });
        }
        
        // === LOGICA AVANZATA PER X (PAREGGIO) ===
        // Condizioni per un buon pareggio:
        // 1. ProbabilitÃ  X alta (>= 25%)
        // 2. Partita equilibrata (differenza 1X2 bassa)
        // 3. Risultato esatto 0-0 o 1-1 probabile
        // 4. Under consigliato (xG totale basso)
        // 5. Multigol squadre bassi (entrambe faticano a segnare)
        
        const totXG = parseFloat(matchInfo.totXG || matchInfo.xgTotal || 0);
        const homeXG = parseFloat(matchInfo.homeXG || 0);
        const awayXG = parseFloat(matchInfo.awayXG || 0);
        
        // Calcola "equilibrio" - differenza tra le 3 probabilitÃ 
        const maxProb = Math.max(p1X2.home, p1X2.draw, p1X2.away);
        const minProb = Math.min(p1X2.home, p1X2.draw, p1X2.away);
        const isBalanced = (maxProb - minProb) < 15; // Partita molto equilibrata
        
        // Calcola probabilitÃ  0-0 e 1-1 (risultati esatti da pareggio)
        const p00 = poisson(homeXG, 0) * poisson(awayXG, 0) * 100;
        const p11 = poisson(homeXG, 1) * poisson(awayXG, 1) * 100;
        const pDrawScores = p00 + p11; // ProbabilitÃ  combinata 0-0 o 1-1
        
        // Calcola multigol squadre (prob di segnare 0 gol)
        const pHome0 = poisson(homeXG, 0) * 100;
        const pAway0 = poisson(awayXG, 0) * 100;
        const lowScoring = pHome0 > 25 || pAway0 > 25; // Almeno una squadra ha alta prob di 0 gol
        
        // Under 2.5 consigliato?
        const pUnder25 = 100 - pOver25;
        const underSuggested = pUnder25 > 50;
        
        // SCORE X: Somma ponderata dei fattori
        let xScore = 0;
        
        // Base: probabilitÃ  X
        xScore += p1X2.draw * 2; // Peso 2x
        
        // Equilibrio 1X2
        if (isBalanced) xScore += 15;
        else if ((maxProb - minProb) < 20) xScore += 10;
        
        // Risultati esatti pareggio (0-0, 1-1)
        if (pDrawScores >= 18) xScore += 20; // 0-0 o 1-1 molto probabili
        else if (pDrawScores >= 12) xScore += 12;
        else if (pDrawScores >= 8) xScore += 6;
        
        // Under consigliato
        if (underSuggested && totXG < 2.2) xScore += 15;
        else if (underSuggested) xScore += 8;
        
        // Basso xG totale
        if (totXG < 1.8) xScore += 12;
        else if (totXG < 2.2) xScore += 6;
        
        // Multigol bassi (squadre non segnano)
        if (lowScoring) xScore += 10;
        
        // DECISIONE: Aggiungi X solo se score >= 55 (soglia stringente per pareggi)
        if (xScore >= 55 && p1X2.draw >= 23) {
          picks.pareggi.push({
            ...matchInfo,
            match,
            bet: 'X',
            prob: p1X2.draw,
            confidence: xScore >= 75 ? 'high' : (xScore >= 65 ? 'medium' : 'low'),
            dataQuality,
            xScore: xScore.toFixed(0), // Score per debug
            pDrawScores: pDrawScores.toFixed(1), // Prob 0-0 + 1-1
            under: underSuggested
          });
        }
        
        // Aggiungi 2 (Vittoria Ospite) se probabilitÃ  >= 45% (in trasferta Ã¨ piÃ¹ difficile)
        if (p1X2.away >= 45) {
          picks.vittorieOspite.push({
            ...matchInfo,
            match,
            bet: '2',
            prob: p1X2.away,
            confidence: p1X2.away >= 65 ? 'high' : (p1X2.away >= 55 ? 'medium' : 'low'),
            dataQuality
          });
        }
        
        // Aggiungi GG se probabilitÃ  >= 52%
        if (pBTTS >= 52) {
          picks.gg.push({
            ...matchInfo,
            match,
            bet: 'GG',
            prob: pBTTS,
            confidence: pBTTS >= 70 ? 'high' : (pBTTS >= 60 ? 'medium' : 'low'),
            dataQuality
          });
        }
        
        // Aggiungi Over 2.5 se probabilitÃ  >= 50%
        if (pOver25 >= 50) {
          picks.over25.push({
            ...matchInfo,
            match,
            bet: 'Over 2.5',
            prob: pOver25,
            confidence: pOver25 >= 70 ? 'high' : (pOver25 >= 60 ? 'medium' : 'low'),
            dataQuality
          });
        }
      });
      
      // === ORDINA E PRENDI I TOP 20 PER OGNI CATEGORIA ===
      // Ordina per confidence (high > medium) e poi per probabilitÃ 
      const sortByConfidence = (a, b) => {
        const confScore = { high: 3, medium: 2, low: 1 };
        if (confScore[a.confidence] !== confScore[b.confidence]) {
          return confScore[b.confidence] - confScore[a.confidence];
        }
        return b.prob - a.prob;
      };
      
      picks.gg = picks.gg.sort(sortByConfidence).slice(0, 20);
      picks.over25 = picks.over25.sort(sortByConfidence).slice(0, 20);
      picks.vittorieCasa = picks.vittorieCasa.sort(sortByConfidence).slice(0, 20);
      picks.vittorieOspite = picks.vittorieOspite.sort(sortByConfidence).slice(0, 20);
      picks.pareggi = picks.pareggi.sort(sortByConfidence).slice(0, 20);
      
      // === COSTRUISCI RADDOPPI ===
      picks.raddoppi = buildRaddoppi(safeBets);
      
      state.dailyPicks = picks;
      console.log('ðŸŽ¯ Daily picks (AI):', Object.keys(picks).map(k => `${k}: ${picks[k].length}`).join(', '));
    }
    
    // Costruisce combinazioni per raddoppi (quota target ~2.00)
    function buildRaddoppi(safeBets) {
      if (safeBets.length < 2) return [];
      
      const raddoppi = [];
      const targetOdds = 2.0;
      const tolerance = 0.25; // quota tra 1.75 e 2.25
      
      // Ordina per probabilitÃ  decrescente
      safeBets.sort((a, b) => b.prob - a.prob);
      
      // Prova combinazioni di 2, 3, 4 partite
      for (let size = 2; size <= Math.min(4, safeBets.length); size++) {
        const combos = getCombinations(safeBets, size);
        
        for (const combo of combos) {
          // Verifica che non ci siano partite duplicate
          const matchIds = combo.map(c => c.match.id);
          if (new Set(matchIds).size !== matchIds.length) continue;
          
          // Calcola quota totale e probabilitÃ  combinata
          const totalOdds = combo.reduce((acc, c) => acc * parseFloat(c.odds), 1);
          const totalProb = combo.reduce((acc, c) => acc * (c.prob / 100), 1) * 100;
          
          // Se la quota Ã¨ vicina a 2.00
          if (totalOdds >= targetOdds - tolerance && totalOdds <= targetOdds + tolerance) {
            raddoppi.push({
              bets: combo,
              totalOdds: totalOdds.toFixed(2),
              totalProb: totalProb.toFixed(1),
              size: combo.length
            });
          }
        }
      }
      
      // Ordina per probabilitÃ  combinata e prendi i migliori 6
      return raddoppi
        .sort((a, b) => parseFloat(b.totalProb) - parseFloat(a.totalProb))
        .slice(0, 6);
    }
    
    // Genera combinazioni di k elementi da un array
    function getCombinations(arr, k) {
      if (k === 1) return arr.map(x => [x]);
      if (k === arr.length) return [arr];
      if (k > arr.length) return [];
      
      const result = [];
      const n = arr.length;
      
      // Limita per performance
      const maxCombos = 500;
      let count = 0;
      
      function combine(start, combo) {
        if (count >= maxCombos) return;
        if (combo.length === k) {
          result.push([...combo]);
          count++;
          return;
        }
        for (let i = start; i < n && count < maxCombos; i++) {
          combo.push(arr[i]);
          combine(i + 1, combo);
          combo.pop();
        }
      }
      
      combine(0, []);
      return result;
    }
    
    // Calcoli rapidi per picks (senza Dixon-Coles per velocitÃ )
    function quickCalc1X2(lH, lA) {
      let pH = 0, pD = 0, pA = 0;
      for (let i = 0; i <= 5; i++) {
        for (let j = 0; j <= 5; j++) {
          const p = poisson(lH, i) * poisson(lA, j);
          if (i > j) pH += p; else if (i === j) pD += p; else pA += p;
        }
      }
      const t = pH + pD + pA;
      return { home: (pH/t)*100, draw: (pD/t)*100, away: (pA/t)*100 };
    }
    
    function quickCalcOver(lH, lA, line) {
      let pUnder = 0;
      for (let i = 0; i <= 5; i++) {
        for (let j = 0; j <= 5; j++) {
          if (i + j <= Math.floor(line)) pUnder += poisson(lH, i) * poisson(lA, j);
        }
      }
      return clamp(10, (1 - pUnder) * 100, 90);
    }
    
    function quickCalcBTTS(lH, lA) {
      return clamp(15, (1 - poisson(lH, 0)) * (1 - poisson(lA, 0)) * 100, 85);
    }
    
    // === TRADER PICKS ===
    // Calcola i migliori picks per il trader con strategia
    function calculateTraderPicks() {
      if (state.matches.length === 0) return;
      
      const MIN_PROB_RADDOPPIO = 72;
      const MIN_PROB_SINGOLA = 60;
      
      const raddoppioPicks = [];
      const singolePicks = [];
      
      // Win rate storici dai tuoi dati (per warning)
      const HISTORICAL_WINRATES = {
        'Under': 100, 'GG': 100, '1': 91.7, '2': 88.9, '1X': 88.9, 'X': 88.9,
        'Over 1.5': 80, 'Over 2.5': 69
      };
      
      state.matches.forEach(match => {
        if (['1H','2H','HT','ET','P','LIVE','FT','AET','PEN'].includes(match.status)) return;
        
        // Stima xG - aumentati per generare picks
        let homeXG = 1.55, awayXG = 1.25;
        const fsKey = `${match.home.name.toLowerCase()}_${match.away.name.toLowerCase()}`.replace(/\s+/g, '');
        const fsMatch = state.fsData.get(fsKey);
        
        if (fsMatch) {
          if (fsMatch.home_xg > 0) homeXG = fsMatch.home_xg;
          else if (fsMatch.home_ppg > 0) homeXG = fsMatch.home_ppg * 0.85;
          if (fsMatch.away_xg > 0) awayXG = fsMatch.away_xg;
          else if (fsMatch.away_ppg > 0) awayXG = fsMatch.away_ppg * 0.75;
        }
        
        homeXG *= 1.10;
        awayXG *= 0.92;
        homeXG = clamp(0.4, homeXG, 3.2);
        awayXG = clamp(0.25, awayXG, 2.8);
        
        const p1X2 = quickCalc1X2(homeXG, awayXG);
        const pOver15 = quickCalcOver(homeXG, awayXG, 1.5);
        const pOver25 = quickCalcOver(homeXG, awayXG, 2.5);
        const pUnder25 = 100 - pOver25;
        const pBTTS = quickCalcBTTS(homeXG, awayXG);
        
        // Trova il miglior pronostico
        const bets = [
          { market: '1', value: '1 Casa', prob: p1X2.home, winRate: HISTORICAL_WINRATES['1'] },
          { market: '1X', value: '1X', prob: p1X2.home + p1X2.draw, winRate: HISTORICAL_WINRATES['1X'] },
          { market: 'X2', value: 'X2', prob: p1X2.draw + p1X2.away, winRate: HISTORICAL_WINRATES['X'] },
          { market: '2', value: '2 Ospite', prob: p1X2.away, winRate: HISTORICAL_WINRATES['2'] },
          { market: 'Over 1.5', value: 'Over 1.5', prob: pOver15, winRate: HISTORICAL_WINRATES['Over 1.5'] },
          { market: 'Under 2.5', value: 'Under 2.5', prob: pUnder25, winRate: HISTORICAL_WINRATES['Under'] },
          { market: 'GG', value: 'GG', prob: pBTTS, winRate: HISTORICAL_WINRATES['GG'] },
          { market: 'NG', value: 'No Gol', prob: 100 - pBTTS, winRate: 100 - HISTORICAL_WINRATES['GG'] }
        ];
        
        const bestBet = bets.reduce((best, b) => b.prob > best.prob ? b : best, bets[0]);
        
        const pick = {
          match,
          bet: bestBet,
          xG: { home: homeXG, away: awayXG, total: homeXG + awayXG },
          time: formatTime(match.date),
          league: `${match.league.country} - ${match.league.name}`
        };
        
        if (bestBet.prob >= MIN_PROB_RADDOPPIO) {
          raddoppioPicks.push(pick);
        } else if (bestBet.prob >= MIN_PROB_SINGOLA) {
          singolePicks.push(pick);
        }
      });
      
      // Ordina e seleziona i migliori
      state.traderPicks.raddoppio = raddoppioPicks.sort((a, b) => b.bet.prob - a.bet.prob).slice(0, 4);
      state.traderPicks.singole = singolePicks.sort((a, b) => b.bet.prob - a.bet.prob).slice(0, 6);
      
      console.log('ðŸ’° Trader picks:', 
        `Raddoppio: ${state.traderPicks.raddoppio.length}`,
        `Singole: ${state.traderPicks.singole.length}`);
    }

    // === MONEY MANAGEMENT ===
    // === MONEY MANAGEMENT - SISTEMA OBIETTIVO ===
    
    function saveMoney() {
      localStorage.setItem('bp2_bankroll', state.money.bankroll);
      localStorage.setItem('bp2_target', state.money.target);
      localStorage.setItem('bp2_totalbets', state.money.totalBets);
      localStorage.setItem('bp2_currentbet', state.money.currentBet);
      localStorage.setItem('bp2_odds', state.money.currentOdds);
      localStorage.setItem('bp2_history', JSON.stringify(state.money.history.slice(-30)));
    }
    
    // Calcola quanto puntare per raggiungere l'obiettivo
    function calculateStake() {
      const { bankroll, target, totalBets, currentBet, currentOdds } = state.money;
      const remainingBets = totalBets - currentBet + 1;
      
      if (remainingBets <= 0 || bankroll <= 0 || currentOdds <= 1) {
        return { stake: 0, error: 'Parametri non validi' };
      }
      
      if (bankroll >= target) {
        return { stake: 0, reached: true };
      }
      
      // Calcola il moltiplicatore necessario per giocata
      const totalMultiplier = target / bankroll;
      const perBetMultiplier = Math.pow(totalMultiplier, 1 / remainingBets);
      
      // Calcola la puntata necessaria
      // Se vinco: bankroll + stake Ã— (odds - 1) = bankroll Ã— perBetMultiplier
      const stake = bankroll * (perBetMultiplier - 1) / (currentOdds - 1);
      
      // Limiti di sicurezza
      if (stake > bankroll * 0.95) {
        return { stake: Math.round(bankroll * 0.95 * 100) / 100, warning: 'âš ï¸ Rischio MOLTO alto!' };
      }
      
      if (stake < 0.5) {
        return { stake: 0.5, warning: 'Puntata minima â‚¬0.50' };
      }
      
      return {
        stake: Math.round(stake * 100) / 100,
        perBetMultiplier: perBetMultiplier.toFixed(3),
        potentialWin: Math.round(stake * (currentOdds - 1) * 100) / 100,
        newBankroll: Math.round((bankroll + stake * (currentOdds - 1)) * 100) / 100
      };
    }
    
    function recordBetResult(won) {
      const calc = calculateStake();
      const stake = calc.stake || 0;
      
      state.money.history.push({
        bet: state.money.currentBet,
        date: new Date().toLocaleTimeString('it-IT', {hour:'2-digit', minute:'2-digit'}),
        odds: state.money.currentOdds,
        stake: stake,
        won: won,
        bankrollBefore: state.money.bankroll
      });
      
      if (won) {
        state.money.bankroll += stake * (state.money.currentOdds - 1);
      } else {
        state.money.bankroll -= stake;
      }
      
      state.money.bankroll = Math.max(0, Math.round(state.money.bankroll * 100) / 100);
      state.money.currentBet++;
      
      saveMoney();
      render();
    }
    
    function resetMoney() {
      state.money.currentBet = 1;
      state.money.history = [];
      saveMoney();
      render();
    }
    
    function getMoneyStats() {
      const { bankroll, target, totalBets, currentBet, currentOdds, history } = state.money;
      const calc = calculateStake();
      const wins = history.filter(h => h.won).length;
      const losses = history.filter(h => !h.won).length;
      const progress = Math.min(100, (bankroll / target) * 100);
      
      return {
        bankroll,
        target,
        totalBets,
        currentBet,
        currentOdds,
        remainingBets: Math.max(0, totalBets - currentBet + 1),
        progress,
        stake: calc.stake || 0,
        warning: calc.warning,
        error: calc.error,
        reached: calc.reached,
        potentialWin: calc.potentialWin || 0,
        newBankroll: calc.newBankroll || bankroll,
        perBetMultiplier: calc.perBetMultiplier || '-',
        wins,
        losses,
        winRate: (wins + losses) > 0 ? ((wins / (wins + losses)) * 100).toFixed(0) : '-'
      };
    }

    // === SCHEDINA (localStorage only) ===
    function loadSlipFromLocalStorage() {
      // Usa solo localStorage
      try {
        const saved = localStorage.getItem('bp2_slip');
        if (saved) {
          state.slip = JSON.parse(saved);
          console.log('ðŸ“‹ Schedina caricata:', state.slip.length, 'pronostici');
        }
      } catch (e) {
        console.warn('localStorage load error:', e);
      }
    }

    function saveSlipToLocalStorage() {
      // Usa solo localStorage
      try {
        localStorage.setItem('bp2_slip', JSON.stringify(state.slip));
      } catch (e) {
        console.warn('localStorage save error:', e);
      }
    }

    function addToSlip(match, market, value, prob) {
      const key = `${match.id}_${market}`;
      const exists = state.slip.find(s => s.key === key);
      if (exists) {
        state.slip = state.slip.filter(s => s.key !== key);
      } else {
        state.slip.push({
          key,
          matchId: match.id,
          matchName: `${match.home.name} vs ${match.away.name}`,
          matchDate: match.date,
          market,
          value,
          prob
        });
      }
      saveSlipToLocalStorage();
      render();
    }

    function removeFromSlip(key) {
      state.slip = state.slip.filter(s => s.key !== key);
      saveSlipToLocalStorage();
      render();
    }

    function clearSlip() {
      state.slip = [];
      saveSlipToLocalStorage();
      render();
    }

    function isInSlip(matchId, market) {
      return state.slip.some(s => s.key === `${matchId}_${market}`);
    }

    // === API STATUS CHECK ===
    async function checkAPIStatus() {
      console.log('ðŸ” Controllo stato API...');
      
      // Helper per fetch con timeout
      const fetchWithTimeout = async (url, options = {}, timeout = 3000) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        try {
          const res = await fetch(url, { ...options, signal: controller.signal });
          clearTimeout(timeoutId);
          return res;
        } catch (e) {
          clearTimeout(timeoutId);
          throw e;
        }
      };
      
      // Check API-Football
      try {
        const testUrl = `${CONFIG.API_FOOTBALL.baseURL}/status`;
        const res = await fetchWithTimeout(testUrl, {
          headers: {
            'x-rapidapi-key': CONFIG.API_FOOTBALL.key,
            'x-rapidapi-host': 'v3.football.api-sports.io'
          }
        }, 5000);
        
        if (res.ok) {
          state.api.football = 'online';
          localStorage.setItem('api_football_status', 'online');
          console.log('âœ… API-Football: ONLINE');
        } else {
          throw new Error('API-Football non disponibile');
        }
      } catch (e) {
        state.api.football = 'offline';
        localStorage.setItem('api_football_status', 'offline');
        console.warn('âŒ API-Football: OFFLINE', e.message);
      }
      
      // Check FootyStats (skip proxy test - troppo lento)
      state.api.footystats = 'offline';
      localStorage.setItem('api_footystats_status', 'offline');
      console.log('âš ï¸ FootyStats: SKIPPED (check on demand)');
    }

    // === CACHING SYSTEM ===
    const CACHE_DURATIONS = {
      fixtures: 6 * 60 * 60 * 1000,      // 6 ore
      statistics: 24 * 60 * 60 * 1000,   // 24 ore
      standings: 24 * 60 * 60 * 1000,    // 24 ore
      h2h: 30 * 24 * 60 * 60 * 1000,     // 30 giorni
      injuries: 12 * 60 * 60 * 1000,     // 12 ore
      footystats: 6 * 60 * 60 * 1000     // 6 ore
    };
    
    function getCacheKey(source, endpoint, params) {
      const sortedParams = Object.keys(params).sort().map(k => `${k}=${params[k]}`).join('&');
      return `cache_${source}_${endpoint}_${sortedParams}`;
    }
    
    function getFromCache(key, maxAge) {
      try {
        const cached = localStorage.getItem(key);
        if (!cached) return null;
        
        const { data, timestamp } = JSON.parse(cached);
        const age = Date.now() - timestamp;
        
        if (age < maxAge) {
          console.log(`âœ… Cache HIT: ${key.substring(0, 50)} (${Math.round(age / 60000)}min ago)`);
          return data;
        } else {
          localStorage.removeItem(key);
          return null;
        }
      } catch (e) {
        return null;
      }
    }
    
    function saveToCache(key, data) {
      try {
        localStorage.setItem(key, JSON.stringify({ data, timestamp: Date.now() }));
      } catch (e) {
        console.warn('Cache save failed');
      }
    }
    
    // === API CALLS ===
    async function callAPIFootball(endpoint, params = {}) {
      // Determina tipo di cache in base all'endpoint
      let cacheType = 'fixtures';
      if (endpoint.includes('statistics')) cacheType = 'statistics';
      else if (endpoint.includes('standings')) cacheType = 'standings';
      else if (endpoint.includes('h2h')) cacheType = 'h2h';
      else if (endpoint.includes('injuries')) cacheType = 'injuries';
      
      // Controlla cache
      const cacheKey = getCacheKey('api-football', endpoint, params);
      const cached = getFromCache(cacheKey, CACHE_DURATIONS[cacheType]);
      if (cached) return cached;
      
      const url = new URL(CONFIG.API_FOOTBALL.baseURL + endpoint);
      Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, v));
      
      // Helper per fetch con timeout
      const fetchWithTimeout = async (url, options = {}, timeout = 8000) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        try {
          const res = await fetch(url, { ...options, signal: controller.signal });
          clearTimeout(timeoutId);
          return res;
        } catch (e) {
          clearTimeout(timeoutId);
          throw e;
        }
      };
      
      try {
        const res = await fetchWithTimeout(url.toString(), {
          headers: {
            'x-rapidapi-key': CONFIG.API_FOOTBALL.key,
            'x-rapidapi-host': 'v3.football.api-sports.io'
          }
        }, 10000);
        
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        
        // Salva in cache
        saveToCache(cacheKey, data);
        
        // Aggiorna lo stato SOLO se era offline
        if (state.api.football !== 'online') {
          state.api.football = 'online';
          localStorage.setItem('api_football_status', 'online');
          render();
        }
        
        return data;
      } catch (e) {
        console.error('API Football error:', e);
        
        // Aggiorna lo stato SOLO se era online
        if (state.api.football !== 'offline') {
          state.api.football = 'offline';
          localStorage.setItem('api_football_status', 'offline');
          render();
        }
        
        return null;
      }
    }
    
    // === CLASSIFICA E POSIZIONE ===
    async function getStandings(leagueId, season) {
      const cacheKey = `${leagueId}_${season}`;
      if (state.standingsCache.has(cacheKey)) {
        return state.standingsCache.get(cacheKey);
      }
      
      try {
        const data = await callAPIFootball('/standings', { league: leagueId, season: season || 2024 });
        if (data?.response?.[0]?.league?.standings?.[0]) {
          const standings = data.response[0].league.standings[0];
          state.standingsCache.set(cacheKey, standings);
          return standings;
        }
      } catch (e) {
        console.warn('Standings error:', e);
      }
      return null;
    }
    
    function getTeamPosition(standings, teamId) {
      if (!standings) return null;
      const team = standings.find(s => s.team.id === teamId);
      if (!team) return null;
      
      const totalTeams = standings.length;
      const position = team.rank;
      
      // Calcola motivazione
      let motivation = 'normale';
      let motivationText = '';
      let motivationColor = 'gray';
      
      if (position <= 1) {
        motivation = 'alta';
        motivationText = 'ðŸ† Lotta Scudetto';
        motivationColor = 'gold';
      } else if (position <= 4) {
        motivation = 'alta';
        motivationText = 'â­ Zona Champions';
        motivationColor = 'cyan';
      } else if (position <= 6) {
        motivation = 'media-alta';
        motivationText = 'ðŸŒŸ Zona Europa';
        motivationColor = 'blue';
      } else if (position >= totalTeams - 2) {
        motivation = 'altissima';
        motivationText = 'ðŸ”¥ Zona Retrocessione';
        motivationColor = 'red';
      } else if (position >= totalTeams - 5) {
        motivation = 'alta';
        motivationText = 'âš ï¸ Rischio Retrocessione';
        motivationColor = 'orange';
      } else {
        motivation = 'normale';
        motivationText = 'âž– MetÃ  Classifica';
        motivationColor = 'gray';
      }
      
      return {
        position,
        totalTeams,
        points: team.points,
        form: team.form,
        played: team.all.played,
        won: team.all.win,
        draw: team.all.draw,
        lost: team.all.lose,
        goalsFor: team.all.goals.for,
        goalsAgainst: team.all.goals.against,
        goalDiff: team.goalsDiff,
        motivation,
        motivationText,
        motivationColor
      };
    }
    
    // === INFORTUNATI ===
    async function getInjuries(teamId, season) {
      const cacheKey = `injuries_${teamId}_${season}`;
      if (state.injuriesCache.has(cacheKey)) {
        return state.injuriesCache.get(cacheKey);
      }
      
      try {
        const data = await callAPIFootball('/injuries', { team: teamId, season: season || 2024 });
        if (data?.response) {
          // Filtra solo infortuni attivi (ultimi 30 giorni)
          const now = new Date();
          const thirtyDaysAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);
          
          const injuries = data.response.filter(inj => {
            const injDate = new Date(inj.fixture.date);
            return injDate >= thirtyDaysAgo;
          }).map(inj => ({
            player: inj.player.name,
            type: inj.player.type || 'Infortunio',
            reason: inj.player.reason || 'Non specificato'
          }));
          
          // Rimuovi duplicati
          const uniqueInjuries = injuries.filter((inj, idx, arr) => 
            arr.findIndex(i => i.player === inj.player) === idx
          );
          
          state.injuriesCache.set(cacheKey, uniqueInjuries);
          return uniqueInjuries;
        }
      } catch (e) {
        console.warn('Injuries error:', e);
      }
      return [];
    }
    
    // Calcola impatto infortunati sull'attacco/difesa
    function calculateInjuryImpact(injuries) {
      if (!injuries || injuries.length === 0) return { attack: 1.0, defense: 1.0, text: '' };
      
      let attackImpact = 1.0;
      let defenseImpact = 1.0;
      const keyPlayers = [];
      
      injuries.forEach(inj => {
        // Stima impatto base: -3% per ogni infortunato
        attackImpact *= 0.97;
        defenseImpact *= 0.98;
        keyPlayers.push(inj.player);
      });
      
      // Limita l'impatto massimo
      attackImpact = Math.max(0.75, attackImpact);
      defenseImpact = Math.max(0.80, defenseImpact);
      
      const text = injuries.length > 0 
        ? `${injuries.length} assenti: ${keyPlayers.slice(0, 3).join(', ')}${injuries.length > 3 ? '...' : ''}`
        : '';
      
      return { attack: attackImpact, defense: defenseImpact, text };
    }
    
    // === SALVA IMPOSTAZIONI ===
    function saveSettings() {
      localStorage.setItem('bp2_settings', JSON.stringify(state.settings));
    }
    
    function updateThreshold(type, value) {
      state.settings.thresholds[type] = parseInt(value);
      saveSettings();
      setSmartFilter(state.smartFilters.active);
      render();
    }
    
    function toggleSettingsPanel() {
      state.settingsOpen = !state.settingsOpen;
      render();
    }

    async function callFootyStats(endpoint, params = {}) {
      // Controlla cache
      const cacheKey = getCacheKey('footystats', endpoint, params);
      const cached = getFromCache(cacheKey, CACHE_DURATIONS.footystats);
      if (cached) return cached;
      
      const url = new URL(CONFIG.FOOTYSTATS.baseURL + endpoint);
      url.searchParams.append('key', CONFIG.FOOTYSTATS.key);
      Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, v));
      
      // Helper per fetch con timeout
      const fetchWithTimeout = async (url, timeout = 3000) => {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        try {
          const res = await fetch(url, { signal: controller.signal });
          clearTimeout(timeoutId);
          return res;
        } catch (e) {
          clearTimeout(timeoutId);
          throw e;
        }
      };
      
      try {
        // Prova prima senza proxy (potrebbe funzionare)
        try {
          const directRes = await fetchWithTimeout(url.toString(), 3000);
          if (directRes.ok) {
            const data = await directRes.json();
            
            // Salva in cache
            saveToCache(cacheKey, data);
            
            if (state.api.footystats !== 'online') {
              state.api.footystats = 'online';
              localStorage.setItem('api_footystats_status', 'online');
              render();
            }
            
            return data;
          }
        } catch (e) {
          // Ignora errori CORS, proviamo con i proxy
        }
        
        // Lista di proxy CORS alternativi (ridotta per velocitÃ )
        const proxies = [
          'https://api.allorigins.win/raw?url=',
          'https://corsproxy.io/?'
        ];
        
        // Prova ogni proxy in sequenza (timeout ridotto)
        for (const proxy of proxies) {
          try {
            const proxyUrl = proxy + encodeURIComponent(url.toString());
            const res = await fetchWithTimeout(proxyUrl, 5000);
            if (res.ok) {
              const data = await res.json();
              
              // Salva in cache
              saveToCache(cacheKey, data);
              
              if (state.api.footystats !== 'online') {
                state.api.footystats = 'online';
                localStorage.setItem('api_footystats_status', 'online');
                render();
              }
              
              console.log(`âœ… FootyStats funziona con proxy: ${proxy}`);
              return data;
            }
          } catch (e) {
            continue;
          }
        }
        
        throw new Error('Tutti i proxy CORS hanno fallito');
      } catch (e) {
        console.error('FootyStats error:', e);
        
        if (state.api.footystats !== 'offline') {
          state.api.footystats = 'offline';
          localStorage.setItem('api_footystats_status', 'offline');
          render();
        }
        
        return null;
      }
    }

    // === DATA LOADING ===
    async function loadMatches(dateOffset = 0) {
      state.loading = true;
      state.selectedDate = dateOffset;
      render();
      
      const dateStr = getDateString(dateOffset);
      console.log('ðŸ“… Loading matches for:', dateStr);
      
      try {
        const data = await callAPIFootball('/fixtures', { date: dateStr, timezone: 'Europe/Rome' });
        
        if (data?.response) {
          const leagueMap = new Map();
          data.response.forEach(f => {
            const key = f.league.id;
            if (!leagueMap.has(key)) {
              leagueMap.set(key, {
                id: f.league.id,
                name: f.league.name,
                country: f.league.country,
                logo: f.league.logo,
                season: f.league.season,
                matchCount: 0
              });
            }
            leagueMap.get(key).matchCount++;
          });
          
          state.leagues = Array.from(leagueMap.values())
            .sort((a, b) => `${a.country} ${a.name}`.localeCompare(`${b.country} ${b.name}`));
          
          state.matches = data.response.map(f => ({
            id: f.fixture.id,
            date: f.fixture.date,
            timestamp: f.fixture.timestamp,
            status: f.fixture.status.short,
            elapsed: f.fixture.status.elapsed,
            league: f.league,
            home: { id: f.teams.home.id, name: f.teams.home.name, logo: f.teams.home.logo },
            away: { id: f.teams.away.id, name: f.teams.away.name, logo: f.teams.away.logo },
            goals: f.goals
          }));
          
          console.log(`âœ… Loaded ${state.leagues.length} leagues, ${state.matches.length} matches`);
        } else {
          console.warn('âš ï¸ No match data received');
          state.matches = [];
          state.leagues = [];
        }
        
        // Load FootyStats (non bloccante)
        callFootyStats('/todays-matches', {}).then(fsData => {
          if (fsData?.data) {
            fsData.data.forEach(m => {
              if (m.home_name && m.away_name) {
                const keys = [
                  `${m.home_name.toLowerCase()}_${m.away_name.toLowerCase()}`,
                  m.home_name.toLowerCase().replace(/\s+/g, '') + '_' + m.away_name.toLowerCase().replace(/\s+/g, '')
                ];
                keys.forEach(k => state.fsData.set(k, m));
              }
            });
          }
        }).catch(e => console.warn('FootyStats load failed:', e));
        
        // Calcola i picks del giorno
        calculateDailyPicks();
        calculateTraderPicks();
        
      } catch (e) {
        console.error('Load matches error:', e);
        state.matches = [];
        state.leagues = [];
      } finally {
        state.loading = false;
        render();
      }
    }

    // === CORNER & CARDS CALCULATIONS ===
    function calcCorners(homeData, awayData, fsMatch) {
      // Base: medie tipiche per corner (varia per campionato)
      let h = 5.2, a = 4.3;
      
      // Usa dati FootyStats piÃ¹ precisi
      if (fsMatch) {
        if (fsMatch.home_corners && fsMatch.home_corners > 0) h = fsMatch.home_corners;
        else if (fsMatch.team_a_corners_avg && fsMatch.team_a_corners_avg > 0) h = fsMatch.team_a_corners_avg;
        
        if (fsMatch.away_corners && fsMatch.away_corners > 0) a = fsMatch.away_corners;
        else if (fsMatch.team_b_corners_avg && fsMatch.team_b_corners_avg > 0) a = fsMatch.team_b_corners_avg;
        
        // Se disponibile media totale
        if (fsMatch.corners_avg && fsMatch.corners_avg > 0) {
          const fsTotal = fsMatch.corners_avg;
          const ratio = h / (h + a);
          h = fsTotal * ratio;
          a = fsTotal * (1 - ratio);
        }
      }
      
      // MIGLIORAMENTO AVANZATO: 10+ fattori che influenzano i corner
      
      // 1. Stile di gioco offensivo â†’ PiÃ¹ attacchi â†’ PiÃ¹ corner (graduale)
      if (homeData.goalsFor >= 2.5) h *= 1.16;
      else if (homeData.goalsFor >= 2.0) h *= 1.12;
      else if (homeData.goalsFor >= 1.8) h *= 1.08;
      else if (homeData.goalsFor >= 1.5) h *= 1.04;
      
      if (awayData.goalsFor >= 2.2) a *= 1.14;
      else if (awayData.goalsFor >= 1.8) a *= 1.10;
      else if (awayData.goalsFor >= 1.5) a *= 1.06;
      else if (awayData.goalsFor >= 1.2) a *= 1.03;
      
      // 2. Difese deboli â†’ PiÃ¹ pressione â†’ PiÃ¹ corner subiti
      if (homeData.goalsAgainst >= 2.2) a *= 1.12;
      else if (homeData.goalsAgainst >= 1.8) a *= 1.08;
      if (awayData.goalsAgainst >= 2.5) h *= 1.14;
      else if (awayData.goalsAgainst >= 2.0) h *= 1.10;
      
      // 3. Squadre difensive chiuse generano meno corner (bloccano prima)
      if (homeData.goalsFor <= 0.9 && homeData.goalsAgainst <= 1.0) h *= 0.86;
      else if (homeData.goalsFor <= 1.2 && homeData.goalsAgainst <= 1.2) h *= 0.92;
      if (awayData.goalsFor <= 0.8 && awayData.goalsAgainst <= 0.9) a *= 0.83;
      else if (awayData.goalsFor <= 1.0 && awayData.goalsAgainst <= 1.1) a *= 0.90;
      
      // 4. Possesso palla â†’ PiÃ¹ possesso â†’ PiÃ¹ corner
      if (fsMatch) {
        if (fsMatch.team_a_possession && fsMatch.team_a_possession >= 62) h *= 1.10;
        else if (fsMatch.team_a_possession && fsMatch.team_a_possession >= 58) h *= 1.06;
        if (fsMatch.team_b_possession && fsMatch.team_b_possession >= 58) a *= 1.08;
        else if (fsMatch.team_b_possession && fsMatch.team_b_possession >= 55) a *= 1.05;
      }
      
      // 5. Forma recente (rapporto gol fatti/subiti)
      const homeForm = (homeData.goalsFor / Math.max(homeData.goalsAgainst, 0.5));
      const awayForm = (awayData.goalsFor / Math.max(awayData.goalsAgainst, 0.5));
      
      if (homeForm >= 2.2) h *= 1.08;
      else if (homeForm >= 1.8) h *= 1.05;
      else if (homeForm <= 0.6) h *= 0.92;
      
      if (awayForm >= 2.0) a *= 1.07;
      else if (awayForm >= 1.6) a *= 1.04;
      else if (awayForm <= 0.5) a *= 0.90;
      
      // 6. Win Rate alto â†’ Squadre dominanti fanno piÃ¹ corner
      if (homeData.winRate && homeData.winRate >= 65) h *= 1.06;
      else if (homeData.winRate && homeData.winRate >= 55) h *= 1.03;
      if (awayData.winRate && awayData.winRate >= 60) a *= 1.05;
      else if (awayData.winRate && awayData.winRate >= 50) a *= 1.02;
      
      // 7. Partite aperte e ad alto punteggio â†’ PiÃ¹ attacchi â†’ PiÃ¹ corner
      const homeTotalGoals = homeData.goalsFor + homeData.goalsAgainst;
      const awayTotalGoals = awayData.goalsFor + awayData.goalsAgainst;
      if (homeTotalGoals >= 3.5) h *= 1.05;
      if (awayTotalGoals >= 3.2) a *= 1.04;
      
      // 8. Fattore casa: squadre casalinghe attaccano di piÃ¹
      h *= 1.08;
      
      // 9. Squadre che segnano poco ma hanno alta media gol contro = subiscono pressione
      if (homeData.goalsFor <= 1.2 && homeData.goalsAgainst >= 1.5) a *= 1.07;
      if (awayData.goalsFor <= 1.0 && awayData.goalsAgainst >= 1.8) h *= 1.09;
      
      // 10. Bilanciamento finale: squadre molto forti vs molto deboli = dominio = piÃ¹ corner
      const strengthDiff = Math.abs(homeData.goalsFor - awayData.goalsFor);
      if (strengthDiff >= 0.8) {
        if (homeData.goalsFor > awayData.goalsFor) h *= 1.06;
        else a *= 1.06;
      }
      
      h = clamp(2.0, h, 10.0);
      a = clamp(1.5, a, 9.0);
      const total = h + a;
      
      const probs = {};
      
      // MIGLIORAMENTO: Distribuzione Poisson (piÃ¹ accurata per eventi discreti)
      [8.5, 9.5, 10.5, 11.5].forEach(line => {
        let pOver = 0;
        // Calcola probabilitÃ  con Poisson
        for (let i = 0; i <= 20; i++) {
          const pCorners = (Math.pow(total, i) * Math.exp(-total)) / factorial(i);
          if (i > line) pOver += pCorners;
        }
        pOver *= 100;
        
        probs[line] = { 
          over: clamp(15, pOver, 85), 
          under: clamp(15, 100 - pOver, 85) 
        };
      });
      
      return { home: h, away: a, total, probs };
    }
    
    function calcCards(homeData, awayData, fsMatch) {
      // Base: media cartellini per squadra
      let h = homeData.cards || 2.1;
      let a = awayData.cards || 1.9;
      
      // Usa dati FootyStats se disponibili
      if (fsMatch) {
        if (fsMatch.home_cards) h = fsMatch.home_cards;
        if (fsMatch.away_cards) a = fsMatch.away_cards;
      }
      
      // MIGLIORAMENTO AVANZATO: 12+ fattori che influenzano i cartellini
      
      // 1. Squadre sotto pressione (subiscono gol) â†’ PiÃ¹ falli disperati â†’ PiÃ¹ cartellini (graduale)
      if (homeData.goalsAgainst >= 2.5) h *= 1.18;
      else if (homeData.goalsAgainst >= 2.0) h *= 1.14;
      else if (homeData.goalsAgainst >= 1.5) h *= 1.10;
      else if (homeData.goalsAgainst >= 1.2) h *= 1.05;
      
      if (awayData.goalsAgainst >= 2.8) a *= 1.22; // Ospite subisce molto (in trasferta Ã¨ peggio)
      else if (awayData.goalsAgainst >= 2.2) a *= 1.16;
      else if (awayData.goalsAgainst >= 1.8) a *= 1.12;
      else if (awayData.goalsAgainst >= 1.4) a *= 1.07;
      
      // 2. Squadre offensive aggressive (molti gol + molti subiti = partite intense = piÃ¹ falli)
      if (homeData.goalsFor >= 2.5 && homeData.goalsAgainst >= 1.8) h *= 1.12;
      else if (homeData.goalsFor >= 2.0 && homeData.goalsAgainst >= 1.3) h *= 1.08;
      if (awayData.goalsFor >= 2.2 && awayData.goalsAgainst >= 2.0) a *= 1.14;
      else if (awayData.goalsFor >= 1.8 && awayData.goalsAgainst >= 1.5) a *= 1.10;
      
      // 3. Squadre difensive disciplinate (pochi gol, pochi subiti = gioco controllato = meno falli)
      if (homeData.goalsFor <= 0.8 && homeData.goalsAgainst <= 0.8) h *= 0.82;
      else if (homeData.goalsFor <= 1.0 && homeData.goalsAgainst <= 1.0) h *= 0.88;
      if (awayData.goalsFor <= 0.7 && awayData.goalsAgainst <= 0.7) a *= 0.80;
      else if (awayData.goalsFor <= 0.8 && awayData.goalsAgainst <= 0.8) a *= 0.85;
      
      // 4. Ritmo di gioco alto â†’ PiÃ¹ cartellini (graduale)
      const homeIntensity = homeData.goalsFor + homeData.goalsAgainst;
      const awayIntensity = awayData.goalsFor + awayData.goalsAgainst;
      
      if (homeIntensity >= 4.0) h *= 1.10;
      else if (homeIntensity >= 3.5) h *= 1.06;
      if (awayIntensity >= 3.8) a *= 1.09;
      else if (awayIntensity >= 3.2) a *= 1.05;
      
      // 5. Partite equilibrate (differenza xG bassa) â†’ PiÃ¹ tensione â†’ PiÃ¹ cartellini
      const balanceDiff = Math.abs(homeData.goalsFor - awayData.goalsFor);
      if (balanceDiff <= 0.2) {
        h *= 1.12; // Partita molto equilibrata = massima tensione
        a *= 1.12;
      } else if (balanceDiff <= 0.3) {
        h *= 1.08;
        a *= 1.08;
      } else if (balanceDiff <= 0.5) {
        h *= 1.04;
        a *= 1.04;
      }
      
      // 6. Fattore trasferta: squadre ospiti tendono a fare piÃ¹ falli
      a *= 1.08;
      
      // 7. Derby / RivalitÃ  (se entrambe hanno alti cartellini medi)
      if (h >= 2.5 && a >= 2.3) {
        h *= 1.14; // Partita molto tesa
        a *= 1.14;
      } else if (h >= 2.3 && a >= 2.1) {
        h *= 1.10;
        a *= 1.10;
      }
      
      // 8. Importanza della partita (squadre forti = partite importanti = piÃ¹ tensione)
      if (homeData.goalsFor >= 2.0 && awayData.goalsFor >= 1.8) {
        h *= 1.06;
        a *= 1.06;
      } else if (homeData.goalsFor >= 1.8 && awayData.goalsFor >= 1.5) {
        h *= 1.04;
        a *= 1.04;
      }
      
      // 9. Forma recente negativa â†’ PiÃ¹ frustrazione â†’ PiÃ¹ falli
      const homeForm = (homeData.goalsFor / Math.max(homeData.goalsAgainst, 0.5));
      const awayForm = (awayData.goalsFor / Math.max(awayData.goalsAgainst, 0.5));
      
      if (homeForm <= 0.5) h *= 1.08; // Casa in crisi
      else if (homeForm <= 0.7) h *= 1.04;
      if (awayForm <= 0.4) a *= 1.10; // Ospite in crisi
      else if (awayForm <= 0.6) a *= 1.05;
      
      // 10. Win rate basso â†’ Squadre perdenti fanno piÃ¹ falli per disperazione
      if (homeData.winRate && homeData.winRate <= 25) h *= 1.08;
      else if (homeData.winRate && homeData.winRate <= 35) h *= 1.04;
      if (awayData.winRate && awayData.winRate <= 20) a *= 1.10;
      else if (awayData.winRate && awayData.winRate <= 30) a *= 1.05;
      
      // 11. Squadre veloci (molti gol) vs squadre lente (pochi gol) = piÃ¹ falli per fermare contropiede
      if (homeData.goalsFor >= 2.0 && awayData.goalsFor <= 1.0) a *= 1.06;
      if (awayData.goalsFor >= 1.8 && homeData.goalsFor <= 1.0) h *= 1.05;
      
      // 12. Clean sheet basso = difese che subiscono pressione = piÃ¹ falli
      if (homeData.cleanSheetPct && homeData.cleanSheetPct <= 20) h *= 1.05;
      if (awayData.cleanSheetPct && awayData.cleanSheetPct <= 15) a *= 1.06;
      
      h = clamp(1.0, h, 5.5);
      a = clamp(0.8, a, 5.0);
      const total = h + a;
      
      const probs = {};
      
      // MIGLIORAMENTO: Distribuzione Poisson
      [2.5, 3.5, 4.5, 5.5].forEach(line => {
        let pOver = 0;
        // Calcola probabilitÃ  con Poisson
        for (let i = 0; i <= 12; i++) {
          const pCards = (Math.pow(total, i) * Math.exp(-total)) / factorial(i);
          if (i > line) pOver += pCards;
        }
        pOver *= 100;
        
        probs[line] = { 
          over: clamp(18, pOver, 82), 
          under: clamp(18, 100 - pOver, 82) 
        };
      });
      
      return { home: h, away: a, total, probs };
    }

    // === ANALYSIS ENGINE ===
    async function analyzeMatch(match) {
      state.selectedMatch = match;
      state.view = 'analysis';
      state.loading = true;
      state.analysis = null;
      render();
      
      let homeStats = null, awayStats = null, h2h = [], apiPred = null;
      let homeLastMatches = [], awayLastMatches = [];
      let standings = null, homeInjuries = [], awayInjuries = [];
      
      try {
        const [hs, as] = await Promise.all([
          callAPIFootball('/teams/statistics', { team: match.home.id, league: match.league.id, season: match.league.season || 2024 }),
          callAPIFootball('/teams/statistics', { team: match.away.id, league: match.league.id, season: match.league.season || 2024 })
        ]);
        homeStats = hs?.response;
        awayStats = as?.response;
      } catch (e) {}
      
      // Ottieni ultime 5 partite per calcolare form REALE
      try {
        const [homeLastRes, awayLastRes] = await Promise.all([
          callAPIFootball('/fixtures', { team: match.home.id, last: 5 }),
          callAPIFootball('/fixtures', { team: match.away.id, last: 5 })
        ]);
        homeLastMatches = homeLastRes?.response || [];
        awayLastMatches = awayLastRes?.response || [];
      } catch (e) {}
      
      try {
        const h2hRes = await callAPIFootball('/fixtures/headtohead', { h2h: `${match.home.id}-${match.away.id}`, last: 10 });
        h2h = h2hRes?.response || [];
      } catch (e) {}
      
      try {
        const predRes = await callAPIFootball('/predictions', { fixture: match.id });
        apiPred = predRes?.response?.[0];
      } catch (e) {}
      
      // NUOVO: Ottieni classifica
      if (state.settings.showStandings) {
        try {
          standings = await getStandings(match.league.id, match.league.season || 2024);
        } catch (e) {}
      }
      
      // NUOVO: Ottieni infortunati
      if (state.settings.showInjuries) {
        try {
          const [homeInj, awayInj] = await Promise.all([
            getInjuries(match.home.id, match.league.season || 2024),
            getInjuries(match.away.id, match.league.season || 2024)
          ]);
          homeInjuries = homeInj || [];
          awayInjuries = awayInj || [];
        } catch (e) {}
      }
      
      let fsMatch = null;
      const fsKeys = [
        `${match.home.name.toLowerCase()}_${match.away.name.toLowerCase()}`,
        match.home.name.toLowerCase().replace(/\s+/g, '') + '_' + match.away.name.toLowerCase().replace(/\s+/g, '')
      ];
      for (const k of fsKeys) {
        if (state.fsData.has(k)) {
          fsMatch = state.fsData.get(k);
          break;
        }
      }
      
      // Calcola form reale dalle ultime partite
      const homeForm = calculateRealForm(homeLastMatches, match.home.id);
      const awayForm = calculateRealForm(awayLastMatches, match.away.id);
      
      // NUOVO: Calcola posizione e motivazione
      const homePosition = getTeamPosition(standings, match.home.id);
      const awayPosition = getTeamPosition(standings, match.away.id);
      
      // NUOVO: Calcola impatto infortunati
      const homeInjuryImpact = calculateInjuryImpact(homeInjuries);
      const awayInjuryImpact = calculateInjuryImpact(awayInjuries);
      
      state.analysis = buildAnalysis(match, homeStats, awayStats, h2h, apiPred, fsMatch, homeForm, awayForm, {
        homePosition, awayPosition, homeInjuries, awayInjuries, homeInjuryImpact, awayInjuryImpact
      });
      
      // SALVA NELLO STORICO VARIAZIONI
      if (state.analysis) {
        const ai = generateAIAdvice(match, state.analysis);
        const matchName = match.home.name + ' vs ' + match.away.name;
        savePredictionToHistory(match.id, matchName, {
          pick: ai.pick,
          prob: ai.prob
        });
      }
      
      state.loading = false;
      render();
    }
    
    // Calcola form reale dalle ultime partite
    function calculateRealForm(matches, teamId) {
      if (!matches || matches.length === 0) return 'DDDDD';
      
      let form = '';
      matches.forEach(m => {
        const homeGoals = m.goals?.home ?? 0;
        const awayGoals = m.goals?.away ?? 0;
        const isHome = m.teams?.home?.id === teamId;
        
        if (isHome) {
          if (homeGoals > awayGoals) form += 'W';
          else if (homeGoals < awayGoals) form += 'L';
          else form += 'D';
        } else {
          if (awayGoals > homeGoals) form += 'W';
          else if (awayGoals < homeGoals) form += 'L';
          else form += 'D';
        }
      });
      
      return form || 'DDDDD';
    }

    // === ALGORITMO AVANZATO ===
    function buildAnalysis(match, homeStats, awayStats, h2h, apiPred, fsMatch, homeForm, awayForm, extraData = {}) {
      // Extract real data
      const homeData = extractTeamData(homeStats, 'home');
      const awayData = extractTeamData(awayStats, 'away');
      
      // Estrai dati extra
      const { homePosition, awayPosition, homeInjuries, awayInjuries, homeInjuryImpact, awayInjuryImpact } = extraData;
      
      // Calculate xG
      let homeXG = calculateXG(homeData, awayData, 'home', apiPred, fsMatch);
      let awayXG = calculateXG(awayData, homeData, 'away', apiPred, fsMatch);
      
      // H2H adjustment
      if (h2h.length >= 3) {
        const adj = analyzeH2H(h2h, match.home.id);
        homeXG *= adj.homeMultiplier;
        awayXG *= adj.awayMultiplier;
      }
      
      // Form adjustment (ultime 5 partite)
      if (homeForm && awayForm) {
        const homeWins = (homeForm.match(/W/g) || []).length;
        const homeLosses = (homeForm.match(/L/g) || []).length;
        const awayWins = (awayForm.match(/W/g) || []).length;
        const awayLosses = (awayForm.match(/L/g) || []).length;
        
        // Aggiusta xG in base al form recente
        if (homeWins >= 4) homeXG *= 1.08; // Ottima forma casa
        else if (homeWins >= 3) homeXG *= 1.04;
        else if (homeLosses >= 3) homeXG *= 0.92; // Pessima forma casa
        
        if (awayWins >= 4) awayXG *= 1.08; // Ottima forma ospite
        else if (awayWins >= 3) awayXG *= 1.04;
        else if (awayLosses >= 3) awayXG *= 0.92; // Pessima forma ospite
      }
      
      // NOTA: Classifica e Infortuni sono mostrati come INFO ma NON modificano i calcoli
      // per mantenere coerenza con i pronostici storici
      
      // Home advantage (casa gioca meglio, trasferta peggio)
      homeXG *= 1.10;  // +10% vantaggio casa
      awayXG *= 0.93;  // -7% svantaggio trasferta
      
      // Clamp ai valori realistici
      homeXG = clamp(0.25, homeXG, 3.8);
      awayXG = clamp(0.15, awayXG, 3.2);
      
      const totXG = homeXG + awayXG;
      
      // Probabilities
      const p1X2 = calc1X2(homeXG, awayXG);
      const pOU = calcOU(homeXG, awayXG);
      
      // BTTS avanzato: usa Poisson + dati storici clean sheet
      let pBTTS = calcBTTS(homeXG, awayXG);
      
      // Aggiusta BTTS con dati clean sheet e failed to score
      const homeWillScore = 100 - homeData.failedToScorePct; // % che la casa segna
      const awayWillScore = 100 - awayData.failedToScorePct; // % che l'ospite segna
      const historicalBTTS = (homeWillScore * awayWillScore) / 100;
      
      // Media ponderata: 60% Poisson, 40% storico
      pBTTS = (pBTTS * 0.60) + (historicalBTTS * 0.40);
      pBTTS = clamp(15, pBTTS, 85);
      
      const exactScores = calcExactScores(homeXG, awayXG);
      
      // Corners & Cards
      const corners = calcCorners(homeData, awayData, fsMatch);
      const cards = calcCards(homeData, awayData, fsMatch);
      
      // Build predictions
      const predictions = buildPredictions(match, homeXG, awayXG, p1X2, pOU, pBTTS, exactScores, corners, cards);
      
      // Build combos
      const combos = buildCombos(p1X2, pOU, pBTTS);
      
      // H2H info
      const h2hInfo = summarizeH2H(h2h, match.home.id);
      
      // Multigoal analysis (tutti i range)
      const multigoal = calcAllMultigol(homeXG, awayXG);
      
      // Distribuzione temporale gol
      const temporalDistribution = calcTemporalDistribution(homeXG, awayXG);
      
      // Multigoal squadra
      const multigoalHome = [
        { range: '1+', prob: calcTeamMultigol(homeXG, 1, 6) },
        { range: '2+', prob: calcTeamMultigol(homeXG, 2, 6) },
        { range: '1-2', prob: calcTeamMultigol(homeXG, 1, 2) },
        { range: '1-3', prob: calcTeamMultigol(homeXG, 1, 3) }
      ];
      const multigoalAway = [
        { range: '1+', prob: calcTeamMultigol(awayXG, 1, 6) },
        { range: '2+', prob: calcTeamMultigol(awayXG, 2, 6) },
        { range: '1-2', prob: calcTeamMultigol(awayXG, 1, 2) },
        { range: '1-3', prob: calcTeamMultigol(awayXG, 1, 3) }
      ];
      
      return {
        match,
        xG: { home: homeXG, away: awayXG, total: totXG },
        p1X2, pOU, pBTTS,
        exactScores: exactScores.slice(0, 12),
        corners, cards,
        h2h: h2hInfo,
        predictions,
        combos,
        multigoal,
        temporalDistribution,
        multigoalHome,
        multigoalAway,
        homeForm: homeForm || 'N/A',
        awayForm: awayForm || 'N/A',
        // NUOVO: Classifica e Infortunati
        homePosition,
        awayPosition,
        homeInjuries: homeInjuries || [],
        awayInjuries: awayInjuries || [],
        quality: (homeStats || awayStats) ? 'enhanced' : 'base'
      };
    }

    function extractTeamData(stats, side) {
      if (!stats) return { 
        goalsFor: 1.3, goalsAgainst: 1.2, form: 'DDDDD', corners: 5.0, cards: 1.8,
        cleanSheetPct: 25, failedToScorePct: 25, played: 10, wins: 4, draws: 3, losses: 3
      };
      
      const goals = stats.goals || {};
      const fixtures = stats.fixtures || {};
      const played = (side === 'home' ? fixtures.played?.home : fixtures.played?.away) || fixtures.played?.total || 10;
      const wins = (side === 'home' ? fixtures.wins?.home : fixtures.wins?.away) || fixtures.wins?.total || 4;
      const draws = (side === 'home' ? fixtures.draws?.home : fixtures.draws?.away) || fixtures.draws?.total || 3;
      const losses = (side === 'home' ? fixtures.loses?.home : fixtures.loses?.away) || fixtures.loses?.total || 3;
      
      const forAvg = side === 'home' 
        ? (goals.for?.average?.home || goals.for?.average?.total || 1.3)
        : (goals.for?.average?.away || goals.for?.average?.total || 1.1);
      const againstAvg = side === 'home'
        ? (goals.against?.average?.home || goals.against?.average?.total || 1.2)
        : (goals.against?.average?.away || goals.against?.average?.total || 1.3);
      
      // Clean sheet e failed to score percentuali
      const cleanSheetPct = stats.clean_sheet ? 
        ((side === 'home' ? stats.clean_sheet.home : stats.clean_sheet.away) || stats.clean_sheet.total || 0) / played * 100 : 25;
      const failedToScorePct = stats.failed_to_score ?
        ((side === 'home' ? stats.failed_to_score.home : stats.failed_to_score.away) || stats.failed_to_score.total || 0) / played * 100 : 25;
      
      return {
        goalsFor: parseFloat(forAvg) || 1.3,
        goalsAgainst: parseFloat(againstAvg) || 1.2,
        form: stats.form || 'DDDDD',
        corners: 5.0,
        cards: parseFloat(stats.cards?.yellow?.total) / (played || 1) || 1.8,
        cleanSheetPct: cleanSheetPct || 25,
        failedToScorePct: failedToScorePct || 25,
        played, wins, draws, losses,
        winRate: played > 0 ? (wins / played) * 100 : 40
      };
    }

    function calculateXG(teamData, oppData, side, apiPred, fsMatch) {
      // Base: attacco squadra vs difesa avversaria (ponderato)
      const attackStrength = teamData.goalsFor / 1.25; // Normalizzato su media campionato ~1.25
      const defenseWeakness = oppData.goalsAgainst / 1.25;
      
      let xg = 1.25 * attackStrength * defenseWeakness; // Expected goals base
      
      // Fattore forma recente (peso 20%)
      const formMultiplier = calculateFormMultiplier(teamData.form);
      xg = xg * 0.80 + xg * formMultiplier * 0.20;
      
      // Fattore win rate (squadre che vincono spesso segnano di piÃ¹)
      if (teamData.winRate > 60) xg *= 1.08;
      else if (teamData.winRate < 30) xg *= 0.90;
      
      // Fattore clean sheet avversario (se l'avversario fa molti clean sheet, segnerai meno)
      if (oppData.cleanSheetPct > 40) xg *= 0.88;
      else if (oppData.cleanSheetPct < 20) xg *= 1.10;
      
      // Fattore failed to score (se la squadra spesso non segna)
      if (teamData.failedToScorePct > 35) xg *= 0.85;
      else if (teamData.failedToScorePct < 15) xg *= 1.08;
      
      // API Predictions (peso 35% se disponibili - sono dati molto accurati)
      if (apiPred?.predictions?.goals) {
        const apiGoal = side === 'home' ? parseFloat(apiPred.predictions.goals.home) : parseFloat(apiPred.predictions.goals.away);
        if (apiGoal > 0) xg = (xg * 0.65) + (apiGoal * 0.35);
      }
      
      // FootyStats xG reali (peso 40% se disponibili - sono i piÃ¹ accurati)
      if (fsMatch) {
        const fsXg = side === 'home' ? fsMatch.home_xg : fsMatch.away_xg;
        const fsPpg = side === 'home' ? fsMatch.home_ppg : fsMatch.away_ppg;
        const fsAvgGoals = side === 'home' ? fsMatch.avg_goals_home : fsMatch.avg_goals_away;
        
        if (fsXg && fsXg > 0) {
          xg = (xg * 0.60) + (fsXg * 0.40);
        } else if (fsAvgGoals && fsAvgGoals > 0) {
          xg = (xg * 0.65) + (fsAvgGoals * 0.35);
        } else if (fsPpg && fsPpg > 0) {
          xg = (xg * 0.75) + (fsPpg * 0.6 * 0.25); // PPG convertito in gol attesi
        }
      }
      
      return xg;
    }

    function calculateFormMultiplier(form) {
      if (!form || form.length === 0) return 1.0;
      
      const recent = form.slice(0, 5).split('');
      let score = 0;
      let totalWeight = 0;
      
      recent.forEach((r, i) => {
        // Peso decrescente: partita piÃ¹ recente conta di piÃ¹
        const weight = Math.pow(0.8, i); // 1, 0.8, 0.64, 0.51, 0.41
        totalWeight += weight;
        
        if (r === 'W') score += 1.0 * weight;      // Vittoria = 1.0
        else if (r === 'D') score += 0.35 * weight; // Pareggio = 0.35
        else if (r === 'L') score += 0.0 * weight;  // Sconfitta = 0
      });
      
      const avgScore = totalWeight > 0 ? score / totalWeight : 0.5;
      
      // Converti in moltiplicatore: range 0.80 - 1.20
      // Score 0 (tutte sconfitte) -> 0.80
      // Score 0.5 (medio) -> 1.00
      // Score 1 (tutte vittorie) -> 1.20
      return 0.80 + (avgScore * 0.40);
    }

    function analyzeH2H(h2h, homeId) {
      if (!h2h || h2h.length === 0) return { homeMultiplier: 1.0, awayMultiplier: 1.0 };
      
      let hg = 0, ag = 0, totalWeight = 0;
      
      h2h.forEach((m, index) => {
        // Peso decrescente per partite piÃ¹ vecchie
        const weight = Math.pow(0.85, index); // Partite recenti contano di piÃ¹
        totalWeight += weight;
        
        const homeGoals = m.goals?.home || 0;
        const awayGoals = m.goals?.away || 0;
        
        if (m.teams?.home?.id === homeId) {
          hg += homeGoals * weight;
          ag += awayGoals * weight;
        } else {
          hg += awayGoals * weight;
          ag += homeGoals * weight;
        }
      });
      
      // Normalizza per il peso totale
      const avgHome = totalWeight > 0 ? hg / totalWeight : 1.2;
      const avgAway = totalWeight > 0 ? ag / totalWeight : 1.0;
      const avgTotal = (avgHome + avgAway) / 2;
      
      // Calcola moltiplicatori con range piÃ¹ ampio per H2H significativi
      const homeMultiplier = avgTotal > 0.1 ? clamp(0.85, avgHome / avgTotal, 1.15) : 1.0;
      const awayMultiplier = avgTotal > 0.1 ? clamp(0.85, avgAway / avgTotal, 1.15) : 1.0;
      
      return { homeMultiplier, awayMultiplier };
    }

    function summarizeH2H(h2h, homeId) {
      const info = { matches: h2h.length, homeWins: 0, draws: 0, awayWins: 0, totalGoals: 0 };
      h2h.forEach(m => {
        const hg = m.goals?.home || 0, ag = m.goals?.away || 0;
        info.totalGoals += hg + ag;
        if (m.teams?.home?.id === homeId) {
          if (hg > ag) info.homeWins++; else if (hg < ag) info.awayWins++; else info.draws++;
        } else {
          if (ag > hg) info.homeWins++; else if (ag < hg) info.awayWins++; else info.draws++;
        }
      });
      info.avgGoals = info.matches ? (info.totalGoals / info.matches).toFixed(1) : '2.5';
      return info;
    }

    function calc1X2(lH, lA) {
      let pH = 0, pD = 0, pA = 0;
      for (let i = 0; i <= 6; i++) {
        for (let j = 0; j <= 6; j++) {
          const p = poisson(lH, i) * poisson(lA, j);
          if (i > j) pH += p; else if (i === j) pD += p; else pA += p;
        }
      }
      const t = pH + pD + pA;
      return { home: (pH/t)*100, draw: (pD/t)*100, away: (pA/t)*100 };
    }

    function calcBTTS(lH, lA) {
      return clamp(15, (1 - poisson(lH, 0)) * (1 - poisson(lA, 0)) * 100, 85);
    }

    function calcOU(lH, lA) {
      const result = {};
      [1.5, 2.5, 3.5, 4.5].forEach(line => {
        let pU = 0;
        for (let i = 0; i <= 6; i++) {
          for (let j = 0; j <= 6; j++) {
            if (i + j <= Math.floor(line)) pU += poisson(lH, i) * poisson(lA, j);
          }
        }
        result[line] = { over: clamp(5, (1 - pU) * 100, 95), under: clamp(5, pU * 100, 95) };
      });
      return result;
    }

    function calcExactScores(lH, lA) {
      const scores = [];
      
      // Dixon-Coles correction factor per risultati a basso punteggio
      // Questo corregge la tendenza del Poisson a sottostimare 0-0, 1-0, 0-1, 1-1
      const rho = 0.13; // Fattore di correlazione (valori tipici: 0.10-0.15)
      
      for (let i = 0; i <= 5; i++) {
        for (let j = 0; j <= 5; j++) {
          let p = poisson(lH, i) * poisson(lA, j);
          
          // Applica Dixon-Coles correction per risultati bassi
          if (i === 0 && j === 0) {
            p *= (1 + lH * lA * rho); // 0-0 leggermente piÃ¹ probabile
          } else if (i === 0 && j === 1) {
            p *= (1 + lH * rho); // 0-1 
          } else if (i === 1 && j === 0) {
            p *= (1 + lA * rho); // 1-0
          } else if (i === 1 && j === 1) {
            p *= (1 - rho); // 1-1 leggermente meno probabile (giÃ  frequente)
          }
          
          scores.push({ h: i, a: j, p: p * 100 });
        }
      }
      
      // Normalizza le probabilitÃ 
      const total = scores.reduce((sum, s) => sum + s.p, 0);
      scores.forEach(s => s.p = (s.p / total) * 100);
      
      return scores.sort((a, b) => b.p - a.p);
    }

    function calcMultigol(lH, lA, min, max) {
      let prob = 0;
      for (let i = 0; i <= 6; i++) {
        for (let j = 0; j <= 6; j++) {
          const t = i + j;
          if (t >= min && t <= max) prob += poisson(lH, i) * poisson(lA, j);
        }
      }
      return prob * 100;
    }
    
    // Calcola TUTTI i range multigoal
    function calcAllMultigol(homeXG, awayXG) {
      const ranges = [
        { name: '0-2', min: 0, max: 2 },
        { name: '0-3', min: 0, max: 3 },
        { name: '1-3', min: 1, max: 3 },
        { name: '1-4', min: 1, max: 4 },
        { name: '2-4', min: 2, max: 4 },
        { name: '2-5', min: 2, max: 5 },
        { name: '3-5', min: 3, max: 5 },
        { name: '3-6', min: 3, max: 6 }
      ];
      
      return ranges.map(r => ({
        range: r.name,
        prob: calcMultigol(homeXG, awayXG, r.min, r.max),
        quota: (100 / calcMultigol(homeXG, awayXG, r.min, r.max)).toFixed(2)
      })).sort((a, b) => b.prob - a.prob);
    }
    
    // Calcola distribuzione gol per tempo
    function calcTemporalDistribution(homeXG, awayXG) {
      // Statisticamente: ~42% gol nel 1T, ~58% nel 2T
      const homeXG_1T = homeXG * 0.42;
      const homeXG_2T = homeXG * 0.58;
      const awayXG_1T = awayXG * 0.42;
      const awayXG_2T = awayXG * 0.58;
      
      const totXG_1T = homeXG_1T + awayXG_1T;
      const totXG_2T = homeXG_2T + awayXG_2T;
      
      // Calcola over/under per tempo
      const over05_1T = calcMultigol(homeXG_1T, awayXG_1T, 1, 6);
      const over15_1T = calcMultigol(homeXG_1T, awayXG_1T, 2, 6);
      const over05_2T = calcMultigol(homeXG_2T, awayXG_2T, 1, 6);
      const over15_2T = calcMultigol(homeXG_2T, awayXG_2T, 2, 6);
      
      // Tempo con piÃ¹ gol
      const piuGol1T = totXG_1T > totXG_2T;
      const probPiuGol = piuGol1T ? 
        (totXG_1T / (totXG_1T + totXG_2T)) * 100 :
        (totXG_2T / (totXG_1T + totXG_2T)) * 100;
      
      return {
        primoTempo: {
          xG: totXG_1T,
          over05: over05_1T,
          over15: over15_1T
        },
        secondoTempo: {
          xG: totXG_2T,
          over05: over05_2T,
          over15: over15_2T
        },
        tempoConPiuGol: piuGol1T ? '1Â° Tempo' : '2Â° Tempo',
        probTempoConPiuGol: probPiuGol
      };
    }

    function calcTeamMultigol(l, min, max) {
      let prob = 0;
      for (let i = min; i <= max; i++) prob += poisson(l, i);
      return prob * 100;
    }

    function buildPredictions(match, homeXG, awayXG, p1X2, pOU, pBTTS, exactScores, corners, cards) {
      const preds = [];
      const totXG = homeXG + awayXG;
      
      // xG Primo Tempo (circa 45% dei gol nel 1T)
      const homeXG_1T = homeXG * 0.45;
      const awayXG_1T = awayXG * 0.45;
      
      // 1X2
      const max1X2 = Math.max(p1X2.home, p1X2.draw, p1X2.away);
      let esito = p1X2.home === max1X2 ? '1' : (p1X2.away === max1X2 ? '2' : 'X');
      preds.push({ market: 'Esito 1X2', value: esito, prob: max1X2 });
      
      // GG/NG
      preds.push({ market: 'GG/NG', value: pBTTS >= 50 ? 'GG' : 'NG', prob: pBTTS >= 50 ? pBTTS : 100-pBTTS });
      
      // Over/Under 2.5
      preds.push({ market: 'O/U 2.5', value: pOU[2.5].over >= 50 ? 'Over 2.5' : 'Under 2.5', prob: Math.max(pOU[2.5].over, pOU[2.5].under) });
      
      // Over/Under 1.5
      preds.push({ market: 'O/U 1.5', value: pOU[1.5].over >= 50 ? 'Over 1.5' : 'Under 1.5', prob: Math.max(pOU[1.5].over, pOU[1.5].under) });
      
      // === OVER PRIMO TEMPO ===
      const pOver05_1T = calcOver1T(homeXG_1T, awayXG_1T, 0.5);
      const pOver15_1T = calcOver1T(homeXG_1T, awayXG_1T, 1.5);
      
      // Over 0.5 1T
      preds.push({ market: 'O/U 0.5 1T', value: pOver05_1T >= 50 ? 'Over 0.5 1T' : 'Under 0.5 1T', prob: Math.max(pOver05_1T, 100 - pOver05_1T) });
      
      // Over 1.5 1T (solo se xG Ã¨ alto)
      if (totXG >= 2.5) {
        preds.push({ market: 'O/U 1.5 1T', value: pOver15_1T >= 50 ? 'Over 1.5 1T' : 'Under 1.5 1T', prob: Math.max(pOver15_1T, 100 - pOver15_1T) });
      }
      
      // Multigol
      const mg13 = calcMultigol(homeXG, awayXG, 1, 3);
      const mg24 = calcMultigol(homeXG, awayXG, 2, 4);
      preds.push({ market: 'Multigol', value: totXG < 2.8 ? '1-3' : '2-4', prob: totXG < 2.8 ? mg13 : mg24 });
      
      // MG Casa 1-3
      const mgH = calcTeamMultigol(homeXG, 1, 3);
      preds.push({ market: 'MG Casa', value: '1-3', prob: mgH });
      
      // MG Ospite 1-3
      const mgA = calcTeamMultigol(awayXG, 1, 3);
      preds.push({ market: 'MG Ospite', value: '1-3', prob: mgA });
      
      // Corner
      const cProb = corners.probs[9.5];
      preds.push({ market: 'Corner', value: cProb.over >= 50 ? 'Over 9.5' : 'Under 9.5', prob: Math.max(cProb.over, cProb.under) });
      
      // Cartellini
      const cardLine = cards.total > 4 ? 4.5 : 3.5;
      const cardProb = cards.probs[cardLine];
      preds.push({ market: 'Cartellini', value: cardProb.over >= 50 ? `Over ${cardLine}` : `Under ${cardLine}`, prob: Math.max(cardProb.over, cardProb.under) });
      
      // Risultato Esatto
      preds.push({ market: 'Ris. Esatto', value: `${exactScores[0].h}-${exactScores[0].a}`, prob: exactScores[0].p });
      
      return preds.sort((a, b) => b.prob - a.prob);
    }
    
    // Calcola Over Primo Tempo
    function calcOver1T(homeXG_1T, awayXG_1T, line) {
      let pUnder = 0;
      for (let i = 0; i <= 4; i++) {
        for (let j = 0; j <= 4; j++) {
          if (i + j <= Math.floor(line)) {
            pUnder += poisson(homeXG_1T, i) * poisson(awayXG_1T, j);
          }
        }
      }
      return clamp(10, (1 - pUnder) * 100, 90);
    }

    function buildCombos(p1X2, pOU, pBTTS) {
      const combos = [];
      
      // 1X + Over 1.5
      const p1X = p1X2.home + p1X2.draw;
      const o15 = pOU[1.5].over;
      combos.push({ value: '1X + Over 1.5', prob: (p1X * o15) / 100, odds: (100 / ((p1X * o15) / 100)).toFixed(2) });
      
      // 1 + Over 1.5
      combos.push({ value: '1 + Over 1.5', prob: (p1X2.home * o15) / 100, odds: (100 / ((p1X2.home * o15) / 100)).toFixed(2) });
      
      // GG + Under 3.5
      const u35 = pOU[3.5].under;
      combos.push({ value: 'GG + Under 3.5', prob: (pBTTS * u35) / 100, odds: (100 / ((pBTTS * u35) / 100)).toFixed(2) });
      
      // GG + Over 2.5
      const o25 = pOU[2.5].over;
      combos.push({ value: 'GG + Over 2.5', prob: (pBTTS * o25) / 100, odds: (100 / ((pBTTS * o25) / 100)).toFixed(2) });
      
      return combos.sort((a, b) => b.prob - a.prob);
    }
    
    // === STATISTICAL ADVICE - Pronostico basato SOLO sulla probabilitÃ  piÃ¹ alta ===
    function generateStatisticalAdvice(match, analysis) {
      const { predictions } = analysis;
      const bestPrediction = predictions.reduce((best, current) => {
        return current.prob > best.prob ? current : best;
      }, predictions[0]);
      let confidence = 'medium';
      if (bestPrediction.prob >= 70) confidence = 'high';
      else if (bestPrediction.prob < 55) confidence = 'low';
      const alternatives = predictions
        .filter(p => p.market !== bestPrediction.market)
        .sort((a, b) => b.prob - a.prob)
        .slice(0, 3)
        .map(p => ({ pick: p.value, prob: p.prob.toFixed(0) }));
      return {
        pick: bestPrediction.value,
        market: bestPrediction.market,
        prob: bestPrediction.prob,
        confidence,
        alternatives
      };
    }

    // === AI ADVICE - Genera il consiglio intelligente ===
    function generateAIAdvice(match, analysis) {
      const { xG, p1X2, pOU, pBTTS, exactScores } = analysis;
      const homeXG = xG.home;
      const awayXG = xG.away;
      const totXG = xG.total;
      
      const advice = {
        pick: '',
        prob: 0,
        confidence: 'medium',
        reasons: [],
        alternatives: []
      };
      
      // Analisi della partita
      const homeStrong = homeXG > 1.8;
      const awayWeak = awayXG < 0.8;
      const awayStrong = awayXG > 1.5;
      const homeWeak = homeXG < 1.0;
      const highScoring = totXG >= 3.0;
      const veryHighScoring = totXG >= 3.8;
      const lowScoring = totXG < 2.2;
      const balanced = Math.abs(homeXG - awayXG) < 0.5;
      const ggLikely = pBTTS >= 55 && homeXG > 0.9 && awayXG > 0.9;
      
      // === LOGICA DI SELEZIONE ===
      
      // CASO 1: Casa dominante (xG casa alto, ospite basso)
      if (homeStrong && awayWeak && p1X2.home >= 65) {
        advice.pick = '1 (Vittoria Casa)';
        advice.prob = p1X2.home;
        advice.confidence = p1X2.home >= 75 ? 'high' : 'medium';
        advice.reasons.push({ text: `xG Casa ${homeXG.toFixed(2)} molto superiore`, type: 'positive' });
        advice.reasons.push({ text: `xG Ospite solo ${awayXG.toFixed(2)}`, type: 'positive' });
        advice.reasons.push({ text: `ProbabilitÃ  ${p1X2.home.toFixed(0)}% favorevole`, type: 'positive' });
        
        if (highScoring) {
          advice.alternatives.push({ pick: '1 + Over 1.5', prob: ((p1X2.home * pOU[1.5].over) / 100).toFixed(0) });
        }
        advice.alternatives.push({ pick: '1X', prob: (p1X2.home + p1X2.draw).toFixed(0) });
      }
      // CASO 2: Trasferta dominante
      else if (awayStrong && homeWeak && p1X2.away >= 60) {
        advice.pick = '2 (Vittoria Ospite)';
        advice.prob = p1X2.away;
        advice.confidence = p1X2.away >= 70 ? 'high' : 'medium';
        advice.reasons.push({ text: `xG Ospite ${awayXG.toFixed(2)} superiore`, type: 'positive' });
        advice.reasons.push({ text: `xG Casa debole ${homeXG.toFixed(2)}`, type: 'positive' });
        
        advice.alternatives.push({ pick: 'X2', prob: (p1X2.away + p1X2.draw).toFixed(0) });
      }
      // CASO 3: Partita da GOL (xG totale alto)
      else if (veryHighScoring && pOU[2.5].over >= 70) {
        advice.pick = 'Over 2.5';
        advice.prob = pOU[2.5].over;
        advice.confidence = pOU[2.5].over >= 80 ? 'high' : 'medium';
        advice.reasons.push({ text: `xG Totale ${totXG.toFixed(2)} molto alto`, type: 'positive' });
        advice.reasons.push({ text: `Entrambe le squadre segnano regolarmente`, type: 'positive' });
        
        advice.alternatives.push({ pick: 'Over 1.5 1T', prob: '60+' });
        advice.alternatives.push({ pick: 'Over 3.5', prob: pOU[3.5].over.toFixed(0) });
        if (ggLikely) advice.alternatives.push({ pick: 'GG', prob: pBTTS.toFixed(0) });
      }
      // CASO 4: GG probabile (entrambe segnano)
      else if (ggLikely && pBTTS >= 60) {
        advice.pick = 'GG (Entrambe Segnano)';
        advice.prob = pBTTS;
        advice.confidence = pBTTS >= 70 ? 'high' : 'medium';
        advice.reasons.push({ text: `xG Casa ${homeXG.toFixed(2)} - segnerÃ `, type: 'positive' });
        advice.reasons.push({ text: `xG Ospite ${awayXG.toFixed(2)} - segnerÃ `, type: 'positive' });
        
        if (highScoring) advice.alternatives.push({ pick: 'GG + Over 2.5', prob: ((pBTTS * pOU[2.5].over) / 100).toFixed(0) });
        advice.alternatives.push({ pick: 'Over 2.5', prob: pOU[2.5].over.toFixed(0) });
      }
      // CASO 5: Over 1.5 sicuro
      else if (pOU[1.5].over >= 80) {
        advice.pick = 'Over 1.5';
        advice.prob = pOU[1.5].over;
        advice.confidence = 'high';
        advice.reasons.push({ text: `ProbabilitÃ  ${pOU[1.5].over.toFixed(0)}% molto alta`, type: 'positive' });
        advice.reasons.push({ text: `xG Totale ${totXG.toFixed(2)} supporta gol`, type: 'positive' });
        
        advice.alternatives.push({ pick: '1X + Over 1.5', prob: (((p1X2.home + p1X2.draw) * pOU[1.5].over) / 100).toFixed(0) });
      }
      // CASO 6: 1X sicuro (casa non perde)
      else if ((p1X2.home + p1X2.draw) >= 80) {
        advice.pick = '1X (Casa o Pareggio)';
        advice.prob = p1X2.home + p1X2.draw;
        advice.confidence = 'high';
        advice.reasons.push({ text: `Casa forte con xG ${homeXG.toFixed(2)}`, type: 'positive' });
        advice.reasons.push({ text: `Vittoria ospite improbabile (${p1X2.away.toFixed(0)}%)`, type: 'positive' });
        
        advice.alternatives.push({ pick: '1', prob: p1X2.home.toFixed(0) });
        if (highScoring) advice.alternatives.push({ pick: '1X + Over 1.5', prob: (((p1X2.home + p1X2.draw) * pOU[1.5].over) / 100).toFixed(0) });
      }
      // CASO 7: Partita equilibrata
      else if (balanced && p1X2.draw >= 28) {
        advice.pick = 'Under 3.5';
        advice.prob = pOU[3.5].under;
        advice.confidence = lowScoring ? 'medium' : 'low';
        advice.reasons.push({ text: `Partita equilibrata (xG simili)`, type: 'neutral' });
        advice.reasons.push({ text: `Possibile pareggio (${p1X2.draw.toFixed(0)}%)`, type: 'neutral' });
        
        advice.alternatives.push({ pick: 'X', prob: p1X2.draw.toFixed(0) });
        advice.alternatives.push({ pick: 'Under 2.5', prob: pOU[2.5].under.toFixed(0) });
      }
      // CASO 8: Default - Over 1.5 (quasi sempre valido)
      else {
        advice.pick = 'Over 1.5';
        advice.prob = pOU[1.5].over;
        advice.confidence = pOU[1.5].over >= 70 ? 'medium' : 'low';
        advice.reasons.push({ text: `Pronostico piÃ¹ sicuro per questa partita`, type: 'neutral' });
        advice.reasons.push({ text: `xG Totale ${totXG.toFixed(2)}`, type: 'neutral' });
        
        if (p1X2.home >= 55) advice.alternatives.push({ pick: '1X', prob: (p1X2.home + p1X2.draw).toFixed(0) });
      }
      
      // Aggiungi warning se i dati non sono affidabili
      if (analysis.quality === 'base') {
        advice.reasons.push({ text: 'Dati statistici limitati', type: 'negative' });
        if (advice.confidence === 'high') advice.confidence = 'medium';
      }
      
      return advice;
    }

    function getProbClass(prob) {
      if (prob >= 65) return 'high';
      if (prob >= 50) return 'mid';
      return 'low';
    }

    // Funzione per generare il verdetto del trader
    function renderTraderVerdict(ai, stat, d) {
      const bestProb = Math.max(ai.prob, stat.prob);
      const bestPick = ai.prob >= stat.prob ? ai.pick : stat.pick;
      const bestMarket = ai.prob >= stat.prob ? 'AI' : 'Statistico';
      
      const HISTORICAL = {
        'Under': { rate: 100, note: 'Storico perfetto!' },
        'GG': { rate: 100, note: 'Mai sbagliato!' },
        '1': { rate: 91.7, note: 'Ottimo storico' },
        '1 Casa': { rate: 91.7, note: 'Ottimo storico' },
        '2': { rate: 88.9, note: 'Buon storico' },
        '2 Ospite': { rate: 88.9, note: 'Buon storico' },
        '1X': { rate: 88.9, note: 'Buon storico' },
        'X2': { rate: 88.9, note: 'Buon storico' },
        'X': { rate: 88.9, note: 'Equilibrato' },
        'Over 1.5': { rate: 80, note: 'Discreto' },
        'Over 2.5': { rate: 69, note: 'âš ï¸ Attenzione!' },
        'Over 3.5': { rate: 65, note: 'âš ï¸ Rischioso' }
      };
      
      let histMatch = null;
      for (const [key, val] of Object.entries(HISTORICAL)) {
        if (bestPick.includes(key) || bestPick === key) {
          histMatch = { market: key, ...val };
          break;
        }
      }
      if (!histMatch) histMatch = { market: bestPick, rate: 75, note: 'Dati limitati' };
      
      let verdict, verdictClass, verdictIcon;
      if (bestProb >= 80 && histMatch.rate >= 85) {
        verdict = 'âœ… GIOCABILE';
        verdictClass = 'play';
        verdictIcon = 'ðŸŽ¯';
      } else if (bestProb >= 70 && histMatch.rate >= 70) {
        verdict = 'âš ï¸ CAUTELA';
        verdictClass = 'caution';
        verdictIcon = 'âš¡';
      } else {
        verdict = 'âŒ EVITARE';
        verdictClass = 'avoid';
        verdictIcon = 'ðŸ›‘';
      }
      
      let suggestion = '';
      if (bestProb >= 82) {
        suggestion = 'Ideale per <strong>RADDOPPIO</strong> con altra partita â‰¥82%';
      } else if (bestProb >= 70) {
        suggestion = 'Consigliata come <strong>SINGOLA</strong> (max 5% bankroll)';
      } else {
        suggestion = 'Non consigliata per betting. Solo per studio.';
      }
      
      const stars = Math.min(5, Math.floor(bestProb / 18));
      
      let warningHtml = '';
      if (histMatch.rate < 75) {
        warningHtml = '<div class="verdict-warning"><span class="verdict-warning-icon">âš ï¸</span><span class="verdict-warning-text"><strong>Attenzione:</strong> Questo mercato ha uno storico sotto il 75%. Evita di usarlo nei raddoppi.</span></div>';
      }
      
      return '<div class="trader-verdict">' +
        '<div class="verdict-header">' +
          '<div class="verdict-icon">' + verdictIcon + '</div>' +
          '<div class="verdict-title"><h3>Consiglio del Trader</h3><p>Analisi strategica basata su probabilitÃ  e storico</p></div>' +
          '<div class="verdict-badge ' + verdictClass + '">' + verdict + '</div>' +
        '</div>' +
        '<div class="verdict-content">' +
          '<div class="verdict-box">' +
            '<div class="verdict-box-title">ðŸŽ¯ Pick Consigliato</div>' +
            '<div class="verdict-main-pick">' +
              '<div class="verdict-main-pick-label">Pronostico ' + bestMarket + '</div>' +
              '<div class="verdict-main-pick-value">' + bestPick + '</div>' +
              '<div class="verdict-main-pick-prob">' + bestProb.toFixed(0) + '%</div>' +
              '<div class="verdict-stars">' + 'â˜…'.repeat(stars) + 'â˜†'.repeat(5-stars) + '</div>' +
            '</div>' +
            '<div class="verdict-suggestion"><span class="verdict-suggestion-icon">ðŸ’¡</span><span class="verdict-suggestion-text">' + suggestion + '</span></div>' +
          '</div>' +
          '<div class="verdict-box">' +
            '<div class="verdict-box-title">ðŸ“Š Win Rate Storico</div>' +
            '<div class="verdict-suggestion"><span class="verdict-suggestion-icon">ðŸ“ˆ</span><span class="verdict-suggestion-text">Mercato <strong>' + histMatch.market + '</strong>: <strong>' + histMatch.rate + '%</strong> win rate</span></div>' +
            '<div class="verdict-suggestion"><span class="verdict-suggestion-icon">ðŸ“</span><span class="verdict-suggestion-text">' + histMatch.note + '</span></div>' +
            warningHtml +
          '</div>' +
        '</div>' +
      '</div>';
    }

    // === LIVE BETTING SYSTEM ===
    
    async function loadLiveMatches() {
      state.liveLoading = true;
      render();
      
      try {
        // Usa la stessa API giÃ  configurata
        const data = await callAPIFootball('/fixtures', { live: 'all' });
        
        if (data && data.response) {
          state.liveMatches = data.response.map(f => ({
            id: f.fixture.id,
            status: f.fixture.status.short,
            elapsed: f.fixture.status.elapsed || 0,
            league: {
              id: f.league.id,
              name: f.league.name,
              country: f.league.country,
              logo: f.league.logo
            },
            home: { id: f.teams.home.id, name: f.teams.home.name, logo: f.teams.home.logo },
            away: { id: f.teams.away.id, name: f.teams.away.name, logo: f.teams.away.logo },
            goals: { home: f.goals.home || 0, away: f.goals.away || 0 },
            stats: f.statistics || []
          }));
          
          // Calcola gli alert
          calculateLiveAlerts();
        }
      } catch (e) {
        console.error('Live load error:', e);
      }
      
      state.liveLoading = false;
      render();
    }
    
    function calculateLiveAlerts() {
      const alerts = [];
      
      // ============================================
      // === CONFIGURAZIONE CAMPIONATI AD ALTA MEDIA GOL ===
      // ============================================
      const HIGH_SCORING_LEAGUES = {
        // Top 5 Europei
        88: { name: 'Eredivisie', avgGoals: 3.2, boost: 12 },
        78: { name: 'Bundesliga', avgGoals: 3.1, boost: 10 },
        144: { name: 'Jupiler Pro', avgGoals: 3.0, boost: 10 },
        218: { name: 'Bundesliga Austria', avgGoals: 3.0, boost: 10 },
        179: { name: 'Premiership Scozia', avgGoals: 2.9, boost: 8 },
        // Serie A e altri
        135: { name: 'Serie A', avgGoals: 2.8, boost: 6 },
        39: { name: 'Premier League', avgGoals: 2.8, boost: 6 },
        140: { name: 'La Liga', avgGoals: 2.6, boost: 4 },
        61: { name: 'Ligue 1', avgGoals: 2.7, boost: 5 },
        // Leghe minori ad alto punteggio
        203: { name: 'Super Lig Turchia', avgGoals: 2.9, boost: 8 },
        94: { name: 'Primeira Liga Portogallo', avgGoals: 2.7, boost: 5 },
        // Sudamerica (tanti gol)
        71: { name: 'Serie A Brasile', avgGoals: 2.6, boost: 5 },
        128: { name: 'Liga Argentina', avgGoals: 2.5, boost: 4 }
      };
      
      // ============================================
      // === MOMENTI CALDI (statisticamente piÃ¹ gol) ===
      // ============================================
      const getHotMomentBoost = (elapsed, isFirstHalf) => {
        if (isFirstHalf) {
          if (elapsed >= 43 && elapsed <= 45) return 15; // Fine 1T - squadre spingono
          if (elapsed >= 40 && elapsed <= 42) return 8;  // Pre-fine 1T
          if (elapsed >= 35 && elapsed <= 39) return 5;  // Fase calda 1T
        } else {
          if (elapsed >= 85) return 18;                  // Ultimi minuti - disperazione
          if (elapsed >= 80 && elapsed <= 84) return 14; // Forcing finale
          if (elapsed >= 75 && elapsed <= 79) return 10; // Ultimi 15 min
          if (elapsed >= 55 && elapsed <= 60) return 8;  // Inizio 2T - cambi tattici
        }
        return 0;
      };
      
      // ============================================
      // === FATTORE SVANTAGGIO (squadra sotto attacca) ===
      // ============================================
      const getDisadvantageBoost = (homeGoals, awayGoals, elapsed) => {
        const diff = Math.abs(homeGoals - awayGoals);
        if (diff === 0) return 0; // Pareggio
        
        // Squadra sotto di 1 gol
        if (diff === 1) {
          if (elapsed >= 75) return 18; // Ultimi 15 min, spinta massima
          if (elapsed >= 65) return 12;
          if (elapsed >= 55) return 8;
          return 4;
        }
        
        // Squadra sotto di 2 gol
        if (diff === 2) {
          if (elapsed >= 70) return 10; // Ancora possibile rimonta
          if (elapsed >= 60) return 5;
          return 0; // Troppo presto o partita chiusa
        }
        
        return 0; // 3+ gol di differenza = partita chiusa
      };
      
      // ============================================
      // === ANALISI PARTITE ===
      // ============================================
      
      state.liveMatches.forEach(match => {
        const elapsed = match.elapsed || 0;
        const homeGoals = match.goals?.home || 0;
        const awayGoals = match.goals?.away || 0;
        const totalGoals = homeGoals + awayGoals;
        const isFirstHalf = match.status === '1H';
        const isSecondHalf = match.status === '2H';
        const isHalfTime = match.status === 'HT';
        
        // Estrai ID campionato
        const leagueId = match.league?.id || 0;
        const leagueInfo = HIGH_SCORING_LEAGUES[leagueId];
        const leagueBoost = leagueInfo ? leagueInfo.boost : 0;
        
        // Calcola boost dinamici
        const hotMomentBoost = getHotMomentBoost(elapsed, isFirstHalf);
        const disadvantageBoost = getDisadvantageBoost(homeGoals, awayGoals, elapsed);
        
        // Estrai statistiche
        let stats = { 
          shotsHome: 0, shotsAway: 0, shots: 0,
          shotsOnHome: 0, shotsOnAway: 0, shotsOn: 0,
          cornersHome: 0, cornersAway: 0, corners: 0,
          possessionHome: 50, possessionAway: 50,
          hasStats: false
        };
        
        if (match.stats && match.stats.length >= 2) {
          const homeStats = match.stats[0]?.statistics || [];
          const awayStats = match.stats[1]?.statistics || [];
          
          const getStat = (arr, type) => {
            const s = arr.find(s => s.type === type);
            return s ? (parseInt(s.value) || 0) : 0;
          };
          
          stats.shotsHome = getStat(homeStats, 'Total Shots');
          stats.shotsAway = getStat(awayStats, 'Total Shots');
          stats.shotsOnHome = getStat(homeStats, 'Shots on Goal');
          stats.shotsOnAway = getStat(awayStats, 'Shots on Goal');
          stats.cornersHome = getStat(homeStats, 'Corner Kicks');
          stats.cornersAway = getStat(awayStats, 'Corner Kicks');
          stats.possessionHome = getStat(homeStats, 'Ball Possession') || 50;
          stats.possessionAway = getStat(awayStats, 'Ball Possession') || 50;
          
          stats.shots = stats.shotsHome + stats.shotsAway;
          stats.shotsOn = stats.shotsOnHome + stats.shotsOnAway;
          stats.corners = stats.cornersHome + stats.cornersAway;
          stats.hasStats = (stats.shots >= 1) || (stats.corners >= 1);
        }
        
        // === CALCOLO PRESSIONE OFFENSIVA ===
        // PiÃ¹ alto = piÃ¹ probabilitÃ  di gol
        const pressure = stats.hasStats 
          ? (stats.shotsOn * 3) + (stats.shots * 1) + (stats.corners * 1.5)
          : 0;
        const pressureBoost = Math.min(20, pressure * 0.8);
        
        // ============================================
        // === ðŸ”¥ ALERT SECONDO TEMPO ðŸ”¥ ===
        // ============================================
        
        // ðŸŽ¯ OVER 0.5 - Partita 0-0 (dal 50')
        if (isSecondHalf && totalGoals === 0 && elapsed >= 50) {
          let prob = 45;
          
          // Base: tempo trascorso
          prob += (elapsed - 45) * 0.8;
          
          // Boost dinamici
          prob += hotMomentBoost;
          prob += leagueBoost;
          prob += pressureBoost;
          
          // 0-0 tardi = alta pressione
          if (elapsed >= 70) prob += 12;
          if (elapsed >= 80) prob += 10;
          
          prob = Math.min(94, prob);
          
          if (prob >= 58) {
            const leagueTag = leagueInfo ? ` [${leagueInfo.name}]` : '';
            alerts.push({
              match, type: 'over05',
              level: prob >= 78 ? 'high' : prob >= 65 ? 'medium' : 'low',
              pick: 'âš½ Over 0.5',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `0-0 al ${elapsed}'${leagueTag}${stats.hasStats ? ` | ${stats.shotsOn} tiri in porta` : ''}`,
              stats, leagueBoost, hotMomentBoost
            });
          }
        }
        
        // ðŸŽ¯ OVER 1.5 - Partita con 0-1 gol (dal 50')
        if (isSecondHalf && totalGoals <= 1 && elapsed >= 50 && elapsed <= 85) {
          let prob = 35;
          
          prob += (elapsed - 45) * 0.6;
          prob += hotMomentBoost;
          prob += leagueBoost;
          prob += disadvantageBoost;
          prob += pressureBoost * 0.8;
          
          if (totalGoals === 1) prob += 15;
          if (elapsed >= 65) prob += 6;
          if (elapsed >= 75) prob += 6;
          
          // 1-1 apertissima
          if (homeGoals === 1 && awayGoals === 0 && elapsed >= 70) prob += 8;
          if (homeGoals === 0 && awayGoals === 1 && elapsed >= 70) prob += 8;
          
          prob = Math.min(88, prob);
          
          if (prob >= 52) {
            alerts.push({
              match, type: 'over15',
              level: prob >= 72 ? 'high' : prob >= 60 ? 'medium' : 'low',
              pick: 'âš½âš½ Over 1.5',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `${homeGoals}-${awayGoals} al ${elapsed}'${disadvantageBoost > 0 ? ' | Squadra sotto spinge!' : ''}`,
              stats, leagueBoost, hotMomentBoost, disadvantageBoost
            });
          }
        }
        
        // ðŸŽ¯ OVER 2.5 - Partita con gol (dal 48')
        if (isSecondHalf && totalGoals >= 1 && totalGoals <= 2 && elapsed >= 48 && elapsed <= 83) {
          let prob = 30;
          
          prob += totalGoals * 10;
          prob += hotMomentBoost;
          prob += leagueBoost;
          prob += disadvantageBoost;
          prob += pressureBoost * 0.7;
          
          // Situazioni specifiche
          if (homeGoals === 1 && awayGoals === 1) prob += 18; // 1-1 = APERTA
          if (homeGoals === 2 && awayGoals === 0) prob += 10; // 2-0 = ospite spingerÃ 
          if (homeGoals === 0 && awayGoals === 2) prob += 10; // 0-2 = casa spingerÃ 
          if (homeGoals === 2 && awayGoals === 1) prob += 12; // 2-1 vivace
          if (homeGoals === 1 && awayGoals === 2) prob += 12; // 1-2 vivace
          
          if (elapsed >= 60) prob += 5;
          if (elapsed >= 70) prob += 5;
          
          prob = Math.min(85, prob);
          
          if (prob >= 50) {
            const situation = (homeGoals === 1 && awayGoals === 1) ? 'ðŸ”¥ Partita APERTA!' : 
                             (Math.abs(homeGoals - awayGoals) >= 1) ? 'âš¡ Squadra sotto attacca!' : '';
            alerts.push({
              match, type: 'over25',
              level: prob >= 70 ? 'high' : prob >= 58 ? 'medium' : 'low',
              pick: 'âš½âš½âš½ Over 2.5',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `${homeGoals}-${awayGoals} al ${elapsed}' ${situation}`,
              stats, leagueBoost, hotMomentBoost, disadvantageBoost
            });
          }
        }
        
        // ðŸŽ¯ OVER 3.5 - Partita ricca di gol (dal 50')
        if (isSecondHalf && totalGoals >= 2 && totalGoals <= 3 && elapsed >= 50 && elapsed <= 82) {
          let prob = 28;
          
          prob += totalGoals * 10;
          prob += hotMomentBoost;
          prob += leagueBoost;
          prob += pressureBoost * 0.6;
          
          if ((homeGoals === 2 && awayGoals === 1) || (homeGoals === 1 && awayGoals === 2)) prob += 15;
          if (homeGoals === 2 && awayGoals === 2) prob += 12;
          if (totalGoals === 3 && elapsed >= 60) prob += 8;
          
          prob = Math.min(80, prob);
          
          if (prob >= 50) {
            alerts.push({
              match, type: 'over35',
              level: prob >= 68 ? 'high' : prob >= 55 ? 'medium' : 'low',
              pick: 'âš½âš½âš½âš½ Over 3.5',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `ðŸ”¥ GiÃ  ${totalGoals} gol! ${homeGoals}-${awayGoals} al ${elapsed}'`,
              stats, leagueBoost, hotMomentBoost
            });
          }
        }
        
        // ðŸŽ¯ GOL 2Â° TEMPO (all'intervallo)
        if (isHalfTime) {
          let prob = 52;
          
          prob += leagueBoost;
          prob += pressureBoost;
          
          if (totalGoals === 0) prob += 18; // 0-0 = pressione massima
          if (totalGoals === 1) prob += 12;
          if (stats.hasStats && stats.shotsOn >= 3) prob += 10;
          if (stats.hasStats && stats.shotsOn >= 5) prob += 8;
          if (stats.hasStats && stats.corners >= 5) prob += 5;
          
          prob = Math.min(90, prob);
          
          if (prob >= 58) {
            alerts.push({
              match, type: 'goal2T',
              level: prob >= 78 ? 'high' : prob >= 65 ? 'medium' : 'low',
              pick: totalGoals === 0 ? 'âš½ Gol 2Â°T' : 'âš½ Altro Gol',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `${homeGoals}-${awayGoals} HT${stats.hasStats ? ` | ${stats.shotsOn} tiri, ${stats.corners} corner` : ''}`,
              stats, leagueBoost
            });
          }
        }
        
        // ============================================
        // === ðŸ”¥ ALERT PRIMO TEMPO ðŸ”¥ ===
        // ============================================
        
        // ðŸŽ¯ OVER 0.5 1Â°T (dal 25')
        if (isFirstHalf && totalGoals === 0 && elapsed >= 25 && elapsed <= 45) {
          let prob = 38;
          
          prob += (elapsed - 20) * 1.5;
          prob += hotMomentBoost;
          prob += leagueBoost;
          prob += pressureBoost;
          
          // Fine primo tempo = boost extra
          if (elapsed >= 40) prob += 8;
          if (elapsed >= 43) prob += 10;
          
          prob = Math.min(88, prob);
          
          if (prob >= 55) {
            alerts.push({
              match, type: 'over05_1T',
              level: prob >= 72 ? 'high' : prob >= 60 ? 'medium' : 'low',
              pick: 'âš½ Over 0.5 1Â°T',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `0-0 al ${elapsed}'${elapsed >= 40 ? ' â° Fine 1T vicina!' : ''}${stats.hasStats ? ` | ${stats.shotsOn} tiri` : ''}`,
              stats, leagueBoost, hotMomentBoost
            });
          }
        }
        
        // ðŸŽ¯ OVER 1.5 1Â°T - Se giÃ  1 gol (dal 20')
        if (isFirstHalf && totalGoals === 1 && elapsed >= 20 && elapsed <= 45) {
          let prob = 35;
          
          prob += (elapsed - 15) * 1.2;
          prob += hotMomentBoost;
          prob += leagueBoost;
          prob += pressureBoost * 0.8;
          prob += disadvantageBoost;
          
          if (elapsed >= 35) prob += 8;
          if (elapsed >= 42) prob += 10;
          
          prob = Math.min(82, prob);
          
          if (prob >= 50) {
            alerts.push({
              match, type: 'over15_1T',
              level: prob >= 68 ? 'high' : prob >= 55 ? 'medium' : 'low',
              pick: 'âš½âš½ Over 1.5 1Â°T',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `${homeGoals}-${awayGoals} al ${elapsed}'${elapsed >= 40 ? ' â° Fine 1T!' : ''}`,
              stats, leagueBoost, hotMomentBoost, disadvantageBoost
            });
          }
        }
        
        // ============================================
        // === ðŸ âœˆï¸ SQUADRA SEGNA (con stats) ===
        // ============================================
        
        if (stats.hasStats && elapsed >= 20) {
          // ðŸ  Casa domina
          if (stats.shotsOnHome >= 3 && stats.shotsOnHome > stats.shotsOnAway * 1.5 && homeGoals === 0) {
            let prob = 45;
            prob += stats.shotsOnHome * 5;
            prob += leagueBoost;
            prob += hotMomentBoost;
            if (elapsed >= 50) prob += 10;
            if (elapsed >= 70) prob += 10;
            if (stats.cornersHome >= 4) prob += 5;
            prob = Math.min(88, prob);
            
            if (prob >= 58) {
              alerts.push({
                match, type: 'homeScores',
                level: prob >= 75 ? 'high' : prob >= 62 ? 'medium' : 'low',
                pick: `ðŸ  ${match.home.name.substring(0,12)} Segna`,
                prob: prob.toFixed(0),
                quota: (100 / prob).toFixed(2),
                reason: `Dominio: ${stats.shotsOnHome} tiri in porta vs ${stats.shotsOnAway}`,
                stats, leagueBoost, hotMomentBoost
              });
            }
          }
          
          // âœˆï¸ Ospite domina
          if (stats.shotsOnAway >= 3 && stats.shotsOnAway > stats.shotsOnHome * 1.5 && awayGoals === 0) {
            let prob = 42;
            prob += stats.shotsOnAway * 5;
            prob += leagueBoost;
            prob += hotMomentBoost;
            if (elapsed >= 50) prob += 10;
            if (elapsed >= 70) prob += 10;
            if (stats.cornersAway >= 4) prob += 5;
            prob = Math.min(85, prob);
            
            if (prob >= 55) {
              alerts.push({
                match, type: 'awayScores',
                level: prob >= 72 ? 'high' : prob >= 60 ? 'medium' : 'low',
                pick: `âœˆï¸ ${match.away.name.substring(0,12)} Segna`,
                prob: prob.toFixed(0),
                quota: (100 / prob).toFixed(2),
                reason: `Dominio: ${stats.shotsOnAway} tiri in porta vs ${stats.shotsOnHome}`,
                stats, leagueBoost, hotMomentBoost
              });
            }
          }
        }
      });
      
      // ============================================
      // === ORDINAMENTO E FILTRO FINALE ===
      // ============================================
      
      // Ordina: HIGH prima, poi per probabilitÃ 
      alerts.sort((a, b) => {
        const levelOrder = { high: 0, medium: 1, low: 2 };
        if (levelOrder[a.level] !== levelOrder[b.level]) {
          return levelOrder[a.level] - levelOrder[b.level];
        }
        return parseFloat(b.prob) - parseFloat(a.prob);
      });
      
      // Max 2 alert per partita (i migliori)
      const alertsFiltered = [];
      const matchAlertCount = {};
      alerts.forEach(alert => {
        const matchId = alert.match.id;
        matchAlertCount[matchId] = (matchAlertCount[matchId] || 0);
        if (matchAlertCount[matchId] < 2) {
          alertsFiltered.push(alert);
          matchAlertCount[matchId]++;
        }
      });
      
      state.liveAlerts = alertsFiltered;
    }
    
    // === LIVE BACKGROUND MONITORING ===
    function startLiveBackgroundMonitoring() {
      // Carica subito i dati LIVE
      loadLiveMatchesBackground();
      
      // Poi ogni 90 secondi in background
      state.liveBackgroundInterval = setInterval(() => {
        loadLiveMatchesBackground();
      }, 90000); // 90 secondi in background
    }
    
    async function loadLiveMatchesBackground() {
      try {
        const data = await callAPIFootball('/fixtures', { live: 'all' });
        
        if (data && data.response) {
          state.liveMatches = data.response.map(f => ({
            id: f.fixture.id,
            status: f.fixture.status.short,
            elapsed: f.fixture.status.elapsed || 0,
            league: {
              id: f.league.id,
              name: f.league.name,
              country: f.league.country,
              logo: f.league.logo
            },
            home: { id: f.teams.home.id, name: f.teams.home.name, logo: f.teams.home.logo },
            away: { id: f.teams.away.id, name: f.teams.away.name, logo: f.teams.away.logo },
            goals: { home: f.goals.home || 0, away: f.goals.away || 0 },
            stats: f.statistics || []
          }));
          
          // Calcola gli alert
          calculateLiveAlerts();
          
          // Aggiorna solo il badge senza re-renderizzare tutto
          updateLiveBadge();
        }
      } catch (e) {
        console.warn('Live background load error:', e);
      }
    }
    
    function updateLiveBadge() {
      const badge = document.querySelector('#liveTab');
      if (badge) {
        const alertCount = state.liveAlerts.length;
        const dot = '<span class="live-dot"></span>';
        const countBadge = alertCount > 0 ? `<span class="live-badge-count">${alertCount}</span>` : '';
        badge.innerHTML = `${dot} LIVE ${countBadge}`;
      }
    }
    
    function startLiveAutoRefresh() {
      if (state.liveInterval) return;
      
      // Countdown visivo
      state.liveCountdown = 60;
      state.countdownInterval = setInterval(() => {
        state.liveCountdown--;
        const countdownEl = document.querySelector('.live-countdown');
        if (countdownEl) {
          countdownEl.textContent = state.liveCountdown + 's';
        }
        if (state.liveCountdown <= 0) {
          state.liveCountdown = 60;
        }
      }, 1000);
      
      // Refresh dati ogni 60 secondi quando nella sezione LIVE
      state.liveInterval = setInterval(() => {
        if (state.liveMode) {
          loadLiveMatches();
          state.liveCountdown = 60;
        }
      }, 60000);
    }
    
    function stopLiveAutoRefresh() {
      if (state.liveInterval) {
        clearInterval(state.liveInterval);
        state.liveInterval = null;
      }
      if (state.countdownInterval) {
        clearInterval(state.countdownInterval);
        state.countdownInterval = null;
      }
    }
    
    function toggleConsigliMode() {
      state.consigliMode = !state.consigliMode;
      state.liveMode = false; // Disattiva live mode
      render();
    }
    
    function toggleLiveMode() {
      state.liveMode = !state.liveMode;
      if (state.liveMode) {
        loadLiveMatches();
        startLiveAutoRefresh();
      } else {
        stopLiveAutoRefresh();
      }
      render();
    }
    
    // === TRACKING PRONOSTICI ===
    
    function trackBet(type, matchId, matchName, pick, prob, odds, isLive = false) {
      // Evita duplicati
      if (state.trackedBets.some(b => b.matchId === matchId && b.pick === pick)) {
        console.log('Pronostico giÃ  tracciato');
        return null;
      }
      
      const bet = {
        id: Date.now(),
        type, // 'prematch' o 'live'
        matchId,
        matchName,
        pick,
        prob: parseFloat(prob),
        odds: parseFloat(odds) || 0,
        isLive,
        timestamp: new Date().toISOString(),
        status: 'pending', // pending, won, lost
        result: null
      };
      
      state.trackedBets.push(bet);
      saveTrackedBets();
      
      render();
      return bet;
    }
    
    // Funzione per tracciare pronostici pre-match
    function trackPrematchBet(matchId, matchName, pick, prob, event) {
      if (event) event.stopPropagation();
      
      // Stima quota basata sulla probabilitÃ 
      const odds = (100 / prob).toFixed(2);
      
      const bet = trackBet('prematch', matchId, matchName, pick, prob, odds, false);
      if (bet) {
        alert(`âœ… Pronostico tracciato!\n\n${matchName}\n${pick} @ ${odds}\n\nVerrÃ  verificato automaticamente a fine partita.`);
      } else {
        alert('âš ï¸ Questo pronostico Ã¨ giÃ  stato tracciato.');
      }
    }
    
    // Funzione per tracciare pronostici LIVE
    function trackLiveBet(matchId, matchName, pick, prob, odds, event) {
      if (event) event.stopPropagation();
      
      const bet = trackBet('live', matchId, matchName, pick, prob, odds, true);
      if (bet) {
        alert(`âœ… Pronostico LIVE tracciato!\n\n${matchName}\n${pick} @ ${odds}\n\nVerrÃ  verificato automaticamente a fine partita.`);
      } else {
        alert('âš ï¸ Questo pronostico LIVE Ã¨ giÃ  stato tracciato.');
      }
    }
    
    function updateBetResult(betId, status, result) {
      const bet = state.trackedBets.find(b => b.id === betId);
      if (bet) {
        bet.status = status;
        bet.result = result;
        saveTrackedBets();
      }
    }
    
    function saveTrackedBets() {
      localStorage.setItem('bp2_tracked', JSON.stringify(state.trackedBets));
    }
    
    function loadTrackingFromLocalStorage() {
      // Usa solo localStorage
      try {
        const saved = localStorage.getItem('bp2_tracked');
        if (saved) {
          state.trackedBets = JSON.parse(saved);
        }
      } catch (e) {
        console.warn('localStorage tracking load error:', e);
      }
    }
    
    async function checkPendingResults() {
      const pending = state.trackedBets.filter(b => b.status === 'pending');
      
      for (const bet of pending) {
        try {
          const data = await callAPIFootball('/fixtures', { id: bet.matchId });
          if (data && data.response && data.response[0]) {
            const fixture = data.response[0];
            const status = fixture.fixture.status.short;
            
            // Solo se la partita Ã¨ finita
            if (['FT', 'AET', 'PEN'].includes(status)) {
              const homeGoals = fixture.goals.home;
              const awayGoals = fixture.goals.away;
              const totalGoals = homeGoals + awayGoals;
              const result = `${homeGoals}-${awayGoals}`;
              
              // Verifica se ha vinto
              let won = false;
              const pick = bet.pick.toLowerCase();
              
              // Over/Under
              if (pick.includes('over 0.5') && totalGoals >= 1) won = true;
              else if (pick.includes('over 1.5') && totalGoals >= 2) won = true;
              else if (pick.includes('over 2.5') && totalGoals >= 3) won = true;
              else if (pick.includes('over 3.5') && totalGoals >= 4) won = true;
              else if (pick.includes('under 2.5') && totalGoals < 3) won = true;
              else if (pick.includes('under 3.5') && totalGoals < 4) won = true;
              // GG/NG
              else if ((pick.includes('gg') || pick.includes('entrambe segnano')) && homeGoals > 0 && awayGoals > 0) won = true;
              else if (pick.includes('ng') && (homeGoals === 0 || awayGoals === 0)) won = true;
              // 1X2 - con supporto per formato esteso "(Vittoria Casa)" ecc.
              else if ((pick === '1' || pick.startsWith('1 (') || pick.startsWith('1 ')) && homeGoals > awayGoals) won = true;
              else if ((pick === 'x' || pick.startsWith('x (') || pick === 'pareggio') && homeGoals === awayGoals) won = true;
              else if ((pick === '2' || pick.startsWith('2 (') || pick.startsWith('2 ')) && homeGoals < awayGoals) won = true;
              // Doppie chance
              else if ((pick === '1x' || pick.startsWith('1x (') || pick.startsWith('1x ')) && homeGoals >= awayGoals) won = true;
              else if ((pick === 'x2' || pick.startsWith('x2 (') || pick.startsWith('x2 ')) && homeGoals <= awayGoals) won = true;
              // Segna
              else if (pick.includes('segna') && totalGoals > 0) won = true;
              else if (pick.includes('gol 2Â°') && totalGoals > 0) won = true;
              
              updateBetResult(bet.id, won ? 'won' : 'lost', result);
            }
          }
        } catch (e) {
          console.warn('Check result error:', e);
        }
      }
      
      render();
    }
    
    function getTrackingStats() {
      const stats = {
        total: state.trackedBets.length,
        pending: state.trackedBets.filter(b => b.status === 'pending').length,
        won: state.trackedBets.filter(b => b.status === 'won').length,
        lost: state.trackedBets.filter(b => b.status === 'lost').length,
        byType: {},
        byPick: {}
      };
      
      // Win rate
      const completed = stats.won + stats.lost;
      stats.winRate = completed > 0 ? ((stats.won / completed) * 100).toFixed(1) : 0;
      
      // Per tipo (prematch vs live)
      ['prematch', 'live'].forEach(type => {
        const bets = state.trackedBets.filter(b => b.type === type);
        const won = bets.filter(b => b.status === 'won').length;
        const lost = bets.filter(b => b.status === 'lost').length;
        const total = won + lost;
        stats.byType[type] = {
          total: bets.length,
          won,
          lost,
          winRate: total > 0 ? ((won / total) * 100).toFixed(1) : 0
        };
      });
      
      // Per tipo di pick
      const pickTypes = [
        { key: 'over 0.5', label: 'Over 0.5' },
        { key: 'over 1.5', label: 'Over 1.5' },
        { key: 'over 2.5', label: 'Over 2.5' },
        { key: 'over 3.5', label: 'Over 3.5' },
        { key: 'under', label: 'Under' },
        { key: 'gg', label: 'GG' },
        { key: 'entrambe segnano', label: 'GG' },
        { key: '1 (', label: '1 (Vittoria Casa)' },
        { key: '2 (', label: '2 (Vittoria Ospite)' },
        { key: '1x', label: '1X' },
        { key: 'x2', label: 'X2' },
        { key: 'pareggio', label: 'X (Pareggio)' }
      ];
      pickTypes.forEach(pickType => {
        const bets = state.trackedBets.filter(b => b.pick.toLowerCase().includes(pickType.key));
        const won = bets.filter(b => b.status === 'won').length;
        const lost = bets.filter(b => b.status === 'lost').length;
        const total = won + lost;
        if (bets.length > 0) {
          stats.byPick[pickType.label] = {
            total: bets.length,
            won,
            lost,
            winRate: total > 0 ? ((won / total) * 100).toFixed(1) : 0
          };
        }
      });
      
      return stats;
    }
    
    function clearOldTrackedBets() {
      // Rimuove bet completati piÃ¹ vecchi di 30 giorni
      const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
      state.trackedBets = state.trackedBets.filter(b => {
        if (b.status === 'pending') return true;
        return new Date(b.timestamp).getTime() > thirtyDaysAgo;
      });
      saveTrackedBets();
    }
    
    // === VERIFICA AUTOMATICA RISULTATI ===
    async function autoVerifyPendingBets() {
      const pending = state.trackedBets.filter(b => b.status === 'pending');
      if (pending.length === 0) return;
      
      console.log(`ðŸ” Verifica automatica di ${pending.length} pronostici pendenti...`);
      
      for (const bet of pending) {
        try {
          // Controlla se la partita Ã¨ finita (almeno 2 ore fa)
          const betDate = new Date(bet.timestamp);
          const now = new Date();
          const hoursSince = (now - betDate) / (1000 * 60 * 60);
          
          // Verifica solo partite che sono iniziate almeno 2 ore fa
          if (hoursSince < 2) continue;
          
          // Ottieni risultato dalla API
          const data = await apiFootball(`/fixtures?id=${bet.matchId}`);
          if (!data.response || data.response.length === 0) continue;
          
          const fixture = data.response[0];
          const status = fixture.fixture.status.short;
          
          // Partita finita?
          if (status !== 'FT' && status !== 'AET' && status !== 'PEN') continue;
          
          const homeGoals = fixture.goals.home;
          const awayGoals = fixture.goals.away;
          const totalGoals = homeGoals + awayGoals;
          
          // Verifica risultato basandosi sul tipo di pronostico
          let isWon = false;
          const pickLower = bet.pick.toLowerCase();
          
          if (pickLower.includes('over 2.5')) {
            isWon = totalGoals > 2.5;
          } else if (pickLower.includes('under 2.5')) {
            isWon = totalGoals < 2.5;
          } else if (pickLower.includes('over 1.5')) {
            isWon = totalGoals > 1.5;
          } else if (pickLower.includes('gg') || pickLower.includes('entrambe segnano')) {
            isWon = homeGoals > 0 && awayGoals > 0;
          } else if (pickLower.includes('1 (') || pickLower.includes('vittoria casa')) {
            isWon = homeGoals > awayGoals;
          } else if (pickLower.includes('2 (') || pickLower.includes('vittoria ospite')) {
            isWon = awayGoals > homeGoals;
          } else if (pickLower.includes('pareggio') || pickLower === 'x') {
            isWon = homeGoals === awayGoals;
          }
          
          // Aggiorna stato
          bet.status = isWon ? 'won' : 'lost';
          bet.result = `${homeGoals}-${awayGoals}`;
          bet.verified = new Date().toISOString();
          
          console.log(`${isWon ? 'âœ…' : 'âŒ'} ${bet.matchName}: ${bet.pick} - ${homeGoals}-${awayGoals}`);
          
          // Aggiorna ML thresholds
          updateMLThresholds(bet.pick, isWon, bet.prob);
          
        } catch (e) {
          console.warn(`Errore verifica bet ${bet.id}:`, e);
        }
      }
      
      saveTrackedBets();
      saveMLThresholds();
      updatePerformanceHistory();
      
      console.log('âœ… Verifica automatica completata');
    }
    
    // === MACHINE LEARNING: CALIBRAZIONE SOGLIE ===
    function updateMLThresholds(pick, isWon, prob) {
      // Normalizza il pick per trovare la categoria giusta
      const pickLower = pick.toLowerCase();
      let market = null;
      
      if (pickLower.includes('1 (') || pickLower.includes('vittoria casa')) market = '1';
      else if (pickLower.includes('2 (') || pickLower.includes('vittoria ospite')) market = '2';
      else if (pickLower.includes('pareggio') || pickLower === 'x') market = 'X';
      else if (pickLower.includes('gg') || pickLower.includes('entrambe segnano')) market = 'GG';
      else if (pickLower.includes('over 2.5')) market = 'Over 2.5';
      
      if (!market || !state.mlThresholds[market]) return;
      
      const ml = state.mlThresholds[market];
      ml.totalPredictions++;
      if (isWon) ml.correctPredictions++;
      
      ml.accuracy = ml.totalPredictions > 0 
        ? ((ml.correctPredictions / ml.totalPredictions) * 100).toFixed(1) 
        : 0;
      
      // Calibra soglia automaticamente
      // Se accuracy < 50%, aumenta soglia (sii piÃ¹ selettivo)
      // Se accuracy > 70%, diminuisci soglia (puoi essere meno selettivo)
      if (ml.totalPredictions >= 20) {
        const currentAccuracy = parseFloat(ml.accuracy);
        
        if (currentAccuracy < 50) {
          ml.threshold = Math.min(ml.threshold + 2, 75); // Max 75%
        } else if (currentAccuracy > 70 && ml.totalPredictions >= 30) {
          ml.threshold = Math.max(ml.threshold - 1, 40); // Min 40%
        }
      }
    }
    
    function saveMLThresholds() {
      localStorage.setItem('bp2_ml_thresholds', JSON.stringify(state.mlThresholds));
    }
    
    function getMLInsights() {
      const insights = [];
      
      Object.entries(state.mlThresholds).forEach(([market, data]) => {
        if (data.totalPredictions < 10) {
          insights.push({
            market,
            status: 'learning',
            message: `${market}: Raccogliendo dati (${data.totalPredictions}/20 predizioni)`,
            accuracy: data.accuracy,
            threshold: data.threshold
          });
        } else {
          const acc = parseFloat(data.accuracy);
          let status = 'stable';
          let message = '';
          
          if (acc < 50) {
            status = 'declining';
            message = `${market}: Performance bassa (${acc}%). Soglia aumentata a ${data.threshold}% per essere piÃ¹ selettivi.`;
          } else if (acc >= 70) {
            status = 'improving';
            message = `${market}: Ottima performance (${acc}%)! Soglia calibrata a ${data.threshold}%.`;
          } else {
            message = `${market}: Performance stabile (${acc}%). Soglia: ${data.threshold}%.`;
          }
          
          insights.push({
            market,
            status,
            message,
            accuracy: acc,
            threshold: data.threshold,
            total: data.totalPredictions,
            correct: data.correctPredictions
          });
        }
      });
      
      return insights.sort((a, b) => b.total - a.total);
    }
    
    // === PERFORMANCE HISTORY ===
    function updatePerformanceHistory() {
      const today = new Date().toISOString().split('T')[0];
      const stats = getTrackingStats();
      
      // Rimuovi entry di oggi se esiste
      state.performanceHistory = state.performanceHistory.filter(h => h.date !== today);
      
      // Aggiungi nuova entry
      state.performanceHistory.push({
        date: today,
        totalBets: stats.total,
        won: stats.won,
        lost: stats.lost,
        pending: stats.pending,
        winRate: parseFloat(stats.winRate),
        byMarket: stats.byPick
      });
      
      // Mantieni solo ultimi 60 giorni
      if (state.performanceHistory.length > 60) {
        state.performanceHistory = state.performanceHistory.slice(-60);
      }
      
      localStorage.setItem('bp2_performance_history', JSON.stringify(state.performanceHistory));
    }
    
    // === RENDER ===
    function render() {
      document.getElementById('app').innerHTML = `
        ${renderHeader()}
        <main class="main">
          ${state.loading ? renderLoading() :
            state.view === 'leagues' ? renderLeagues() :
            state.view === 'matches' ? renderMatches() :
            state.view === 'performance' ? renderPerformance() :
            renderAnalysis()}
        </main>
        ${renderSlipFloating()}
        ${state.slipModal ? renderSlipModal() : ''}
      `;
      attachEvents();
      
      // Inizializza grafici se siamo nella view performance
      if (state.view === 'performance') {
        setTimeout(() => initializeCharts(), 100);
      }
    }

    function renderHeader() {
      return `
        <header class="header">
          <div class="header-inner">
            <div class="brand">
              <div class="brand-icon">âš½</div>
              <span class="brand-name">BettingPro</span>
            </div>
            <div class="header-right">
              <div class="status-bar">
                <div class="status-item">
                  <span class="status-dot ${state.api.football}"></span>
                  <span>API</span>
                </div>
                <div class="status-item">
                  <span class="status-dot ${state.api.footystats}"></span>
                  <span>Stats</span>
                </div>
              </div>
              <button class="settings-btn" onclick="showPerformance()" title="Performance & Analytics">
                ðŸ“Š
              </button>
              <button class="settings-btn" onclick="toggleSettingsPanel()" title="Impostazioni">
                âš™ï¸
              </button>
              <div class="slip-badge" id="openSlip">
                ðŸŽ« ${state.slip.length} pronostici
              </div>
            </div>
          </div>
        </header>
        ${renderSettingsPanel()}
      `;
    }
    
    function renderSettingsPanel() {
      const s = state.settings;
      const stats = getTrackingStats();
      return `
        <div class="settings-overlay ${state.settingsOpen ? 'open' : ''}" onclick="toggleSettingsPanel()"></div>
        <div class="settings-panel ${state.settingsOpen ? 'open' : ''}">
          <div class="settings-header">
            <span class="settings-title">âš™ï¸ Impostazioni</span>
            <button class="settings-close" onclick="toggleSettingsPanel()">Ã—</button>
          </div>
          
          <div class="settings-section">
            <div class="settings-section-title">ðŸ“Š Win Rate per Segno</div>
            ${renderWinRateByPick(stats)}
          </div>
          
          <div class="settings-section">
            <div class="settings-section-title">ðŸ”§ FunzionalitÃ </div>
            <div class="settings-row">
              <span class="settings-label">Mostra Classifica</span>
              <div class="settings-toggle ${s.showStandings ? 'active' : ''}" 
                onclick="toggleSetting('showStandings')"></div>
            </div>
            <div class="settings-row">
              <span class="settings-label">Mostra Infortunati</span>
              <div class="settings-toggle ${s.showInjuries ? 'active' : ''}" 
                onclick="toggleSetting('showInjuries')"></div>
            </div>
            <div class="settings-row">
              <span class="settings-label">Auto-refresh LIVE</span>
              <div class="settings-toggle ${s.autoRefresh ? 'active' : ''}" 
                onclick="toggleSetting('autoRefresh')"></div>
            </div>
          </div>
          
          <div class="settings-section">
            <div class="settings-section-title">ðŸ“ˆ Storico Ultimi Pronostici</div>
            ${renderHistoryChart()}
          </div>
          
          <div class="settings-section">
            <button class="btn btn-secondary" style="width:100%" onclick="resetAllData()">
              ðŸ—‘ï¸ Reset tutti i dati
            </button>
          </div>
        </div>
      `;
    }
    
    function renderWinRateByPick(stats) {
      const picks = Object.entries(stats.byPick);
      if (picks.length === 0) {
        return '<div style="text-align:center; color:var(--text-dark); padding:20px;">Nessun pronostico tracciato</div>';
      }
      
      // Ordina per numero di giocate
      picks.sort((a, b) => b[1].total - a[1].total);
      
      return `
        <div class="winrate-grid">
          ${picks.map(([label, data]) => `
            <div class="winrate-item">
              <div class="winrate-label">${label}</div>
              <div class="winrate-stats">
                <span class="winrate-played">${data.total} giocate</span>
                <span class="winrate-won">âœ… ${data.won}</span>
                <span class="winrate-lost">âŒ ${data.lost}</span>
              </div>
              <div class="winrate-bar">
                <div class="winrate-bar-fill ${parseFloat(data.winRate) >= 50 ? 'good' : 'bad'}" 
                  style="width: ${data.winRate}%"></div>
              </div>
              <div class="winrate-percent">${data.winRate}%</div>
            </div>
          `).join('')}
        </div>
        
        <div class="winrate-summary">
          <div class="winrate-summary-item">
            <span>Totale</span>
            <strong>${stats.total}</strong>
          </div>
          <div class="winrate-summary-item">
            <span>Vinte</span>
            <strong style="color: var(--accent-green)">${stats.won}</strong>
          </div>
          <div class="winrate-summary-item">
            <span>Perse</span>
            <strong style="color: var(--accent-red)">${stats.lost}</strong>
          </div>
          <div class="winrate-summary-item">
            <span>Win Rate</span>
            <strong style="color: var(--accent-cyan)">${stats.winRate}%</strong>
          </div>
        </div>
      `;
    }
    
    function renderHistoryChart() {
      const bets = state.trackedBets.filter(b => b.status !== 'pending').slice(-20);
      if (bets.length === 0) {
        return '<div style="text-align:center; color:var(--text-dark); padding:20px;">Nessun pronostico verificato</div>';
      }
      
      const maxHeight = 60;
      return `
        <div class="history-chart">
          <div class="history-bars">
            ${bets.map(b => `
              <div class="history-bar ${b.status}" style="height: ${maxHeight}px" title="${b.match}: ${b.pick} - ${b.status === 'won' ? 'VINTO' : 'PERSO'}"></div>
            `).join('')}
          </div>
          <div class="history-labels">
            <span>Ultimi ${bets.length} pronostici</span>
            <span style="color: var(--accent-green)">${bets.filter(b => b.status === 'won').length}V</span>
            <span style="color: var(--accent-red)">${bets.filter(b => b.status === 'lost').length}P</span>
          </div>
        </div>
      `;
    }
    
    function toggleSetting(key) {
      state.settings[key] = !state.settings[key];
      saveSettings();
      render();
    }
    
    function resetAllData() {
      if (confirm('Sei sicuro di voler cancellare TUTTI i dati? (pronostici, impostazioni, statistiche)')) {
        localStorage.removeItem('bp2_tracked');
        localStorage.removeItem('bp2_settings');
        localStorage.removeItem('bp2_history');
        localStorage.removeItem('bp2_bankroll');
        localStorage.removeItem('bp2_slip');
        state.trackedBets = [];
        state.slip = [];
        state.settings = {
          thresholds: { '1': 50, 'X': 28, '2': 50, 'GG': 55, 'Over 2.5': 50, 'Over 1.5': 65 },
          showInjuries: true, showStandings: true, autoRefresh: true
        };
        render();
        alert('âœ… Tutti i dati sono stati cancellati');
      }
    }
    
    // Filtra campionati e squadre
    function renderLoading() {
      return `<div class="loading"><div class="spinner"></div><div class="loading-text">Caricamento...</div></div>`;
    }

    // === RENDER PERFORMANCE VIEW ===
    function renderPerformance() {
      const stats = getTrackingStats();
      const mlInsights = getMLInsights();
      const history = state.performanceHistory.slice(-30); // Ultimi 30 giorni
      
      return `
        <div class="panel">
          <div class="panel-title">ðŸ“Š Performance & Analytics</div>
          
          <!-- STATS OVERVIEW -->
          <div class="stats-overview" style="grid-template-columns: repeat(4, 1fr); margin-bottom: 24px;">
            <div class="stats-card">
              <div class="stats-card-value ${stats.winRate >= 60 ? 'green' : stats.winRate >= 50 ? 'yellow' : 'red'}">
                ${stats.winRate}%
              </div>
              <div class="stats-card-label">Win Rate Totale</div>
            </div>
            <div class="stats-card">
              <div class="stats-card-value green">${stats.won}</div>
              <div class="stats-card-label">Pronostici Vinti</div>
            </div>
            <div class="stats-card">
              <div class="stats-card-value red">${stats.lost}</div>
              <div class="stats-card-label">Pronostici Persi</div>
            </div>
            <div class="stats-card">
              <div class="stats-card-value">${stats.total}</div>
              <div class="stats-card-label">Totale Pronostici</div>
            </div>
          </div>
          
          <!-- MACHINE LEARNING INSIGHTS -->
          ${mlInsights.length > 0 ? `
          <div class="ml-insights">
            <div class="ml-insights-header">
              <div class="ml-insights-icon">ðŸ¤–</div>
              <div>
                <div class="ml-insights-title">Machine Learning Insights</div>
                <div style="font-size: 0.75rem; color: var(--text-gray); margin-top: 4px;">
                  Calibrazione automatica delle soglie basata sui risultati storici
                </div>
              </div>
            </div>
            
            ${mlInsights.map(insight => `
              <div class="ml-suggestion-card">
                <div class="ml-suggestion-header">
                  <span class="ml-suggestion-market">${insight.market}</span>
                  <span class="ml-suggestion-status ${insight.status}">${
                    insight.status === 'improving' ? 'ðŸ“ˆ In miglioramento' :
                    insight.status === 'declining' ? 'ðŸ“‰ In calo' :
                    insight.status === 'learning' ? 'ðŸŽ“ Apprendimento' : 'âž¡ï¸ Stabile'
                  }</span>
                </div>
                <div class="ml-suggestion-body">
                  ${insight.message}
                  ${insight.total >= 10 ? `<br><small>${insight.correct}/${insight.total} predizioni corrette</small>` : ''}
                </div>
              </div>
            `).join('')}
          </div>
          ` : ''}
          
          <!-- GRAFICI -->
          <div class="performance-grid">
            <!-- Win Rate nel Tempo -->
            <div class="chart-container" style="grid-column: span 2;">
              <div class="chart-header">
                <div class="chart-title">ðŸ“ˆ Win Rate nel Tempo (Ultimi 30 giorni)</div>
              </div>
              <div class="chart-canvas-wrapper">
                <canvas id="winRateChart"></canvas>
              </div>
            </div>
            
            <!-- Performance per Mercato -->
            <div class="chart-container">
              <div class="chart-header">
                <div class="chart-title">ðŸŽ¯ Performance per Mercato</div>
              </div>
              <div class="chart-canvas-wrapper">
                <canvas id="marketPerformanceChart"></canvas>
              </div>
            </div>
            
            <!-- Distribuzione Risultati -->
            <div class="chart-container">
              <div class="chart-header">
                <div class="chart-title">ðŸ“Š Distribuzione Risultati</div>
              </div>
              <div class="chart-canvas-wrapper">
                <canvas id="resultsDistributionChart"></canvas>
              </div>
            </div>
          </div>
          
          <!-- BOTTONE VERIFICA AUTOMATICA -->
          <div style="text-align: center; margin-top: 24px;">
            <button class="btn btn-primary" onclick="manualVerifyBets()" style="padding: 12px 32px; font-size: 1rem;">
              ðŸ” Verifica Risultati Pendenti
            </button>
            <div style="font-size: 0.75rem; color: var(--text-dark); margin-top: 8px;">
              Verifica automaticamente i risultati delle partite terminate
            </div>
          </div>
          
          <!-- BACK BUTTON -->
          <div style="text-align: center; margin-top: 16px;">
            <button class="btn btn-secondary" onclick="backToLeagues()">
              â† Torna ai Campionati
            </button>
          </div>
        </div>
      `;
    }
    
    // === INITIALIZE CHARTS ===
    function initializeCharts() {
      if (!window.Chart) {
        console.warn('Chart.js non caricato');
        return;
      }
      
      const history = state.performanceHistory.slice(-30);
      const stats = getTrackingStats();
      
      // Chart.js default colors
      Chart.defaults.color = '#94a3b8';
      Chart.defaults.borderColor = 'rgba(255,255,255,0.08)';
      
      // 1. WIN RATE NEL TEMPO
      const winRateCtx = document.getElementById('winRateChart');
      if (winRateCtx && history.length > 0) {
        new Chart(winRateCtx, {
          type: 'line',
          data: {
            labels: history.map(h => new Date(h.date).toLocaleDateString('it-IT', { month: 'short', day: 'numeric' })),
            datasets: [{
              label: 'Win Rate %',
              data: history.map(h => h.winRate),
              borderColor: '#3b82f6',
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              fill: true,
              tension: 0.4,
              pointRadius: 4,
              pointHoverRadius: 6
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                backgroundColor: '#22253a',
                titleColor: '#f1f5f9',
                bodyColor: '#94a3b8',
                borderColor: 'rgba(255,255,255,0.1)',
                borderWidth: 1
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                max: 100,
                grid: { color: 'rgba(255,255,255,0.05)' }
              },
              x: {
                grid: { display: false }
              }
            }
          }
        });
      }
      
      // 2. PERFORMANCE PER MERCATO
      const marketCtx = document.getElementById('marketPerformanceChart');
      if (marketCtx && Object.keys(stats.byPick).length > 0) {
        const marketData = Object.entries(stats.byPick).sort((a, b) => b[1].total - a[1].total).slice(0, 5);
        
        new Chart(marketCtx, {
          type: 'bar',
          data: {
            labels: marketData.map(m => m[0]),
            datasets: [{
              label: 'Win Rate %',
              data: marketData.map(m => parseFloat(m[1].winRate)),
              backgroundColor: marketData.map(m => {
                const wr = parseFloat(m[1].winRate);
                return wr >= 60 ? 'rgba(16, 185, 129, 0.8)' :
                       wr >= 50 ? 'rgba(251, 191, 36, 0.8)' :
                       'rgba(239, 68, 68, 0.8)';
              }),
              borderRadius: 8,
              borderSkipped: false
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false }
            },
            scales: {
              y: {
                beginAtZero: true,
                max: 100,
                grid: { color: 'rgba(255,255,255,0.05)' }
              },
              x: {
                grid: { display: false }
              }
            }
          }
        });
      }
      
      // 3. DISTRIBUZIONE RISULTATI
      const resultsCtx = document.getElementById('resultsDistributionChart');
      if (resultsCtx) {
        new Chart(resultsCtx, {
          type: 'doughnut',
          data: {
            labels: ['Vinti', 'Persi', 'Pendenti'],
            datasets: [{
              data: [stats.won, stats.lost, stats.pending],
              backgroundColor: [
                'rgba(16, 185, 129, 0.8)',
                'rgba(239, 68, 68, 0.8)',
                'rgba(251, 191, 36, 0.8)'
              ],
              borderWidth: 0
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
                labels: {
                  padding: 15,
                  font: { size: 12 }
                }
              }
            }
          }
        });
      }
    }
    
    function manualVerifyBets() {
      if (confirm('Vuoi verificare automaticamente i risultati delle partite terminate?\n\nQuesto potrebbe richiedere alcuni minuti.')) {
        state.loading = true;
        render();
        
        autoVerifyPendingBets().then(() => {
          state.loading = false;
          alert('âœ… Verifica completata!\n\nI risultati sono stati aggiornati.');
          render();
        }).catch(e => {
          state.loading = false;
          alert('âŒ Errore durante la verifica:\n\n' + e.message);
          render();
        });
      }
    }
    
    function backToLeagues() {
      state.view = 'leagues';
      render();
    }
    
    function showPerformance() {
      state.view = 'performance';
      render();
    }
    
    function renderLeagues() {
      const picks = state.dailyPicks;
      const money = getMoneyStats();
      
      return `
        <div class="date-tabs">
          <div class="date-tab consigli-tab ${state.consigliMode ? 'active' : ''}" id="consigliTab">
            <span style="color: var(--accent-gold);">ðŸ’¡</span> CONSIGLI ${(picks.gg.length + picks.vittorieCasa.length + picks.vittorieOspite.length + picks.pareggi.length) > 0 ? `<span class="live-badge-count">${picks.gg.length + picks.vittorieCasa.length + picks.vittorieOspite.length + picks.pareggi.length}</span>` : ''}
          </div>
          ${[-1, 0, 1, 2].map(d => `
            <div class="date-tab ${!state.consigliMode && state.selectedDate === d ? 'active' : ''}" data-date="${d}">
              ${getDateLabel(d)} ${d !== 0 ? `(${formatDate(getDateString(d))})` : ''}
            </div>
          `).join('')}
        </div>
        
        ${state.consigliMode ? renderConsigliSection() : `
        <!-- SELEZIONA CAMPIONATO - SPOSTATO IN ALTO -->
        <div class="panel" style="margin-bottom: 16px;">
          <div class="panel-title">ðŸ“‹ Seleziona Campionato (${state.matches.length} partite)</div>
          ${state.leagues.length === 0 ? `<div class="empty"><div class="empty-icon">ðŸ“­</div>Nessuna partita</div>` : `
            <select class="select-field" id="leagueSelect">
              <option value="">-- Scegli un campionato --</option>
              ${state.leagues.map(l => `<option value="${l.id}">${esc(l.country)} - ${esc(l.name)} (${l.matchCount})</option>`).join('')}
            </select>
          `}
        </div>
        
        <!-- HOME SECTIONS - PICKS DEL GIORNO (RIMOSSI TOP 20) -->
        </div>
      `}
      `;
    }
    
    // === SEZIONE CONSIGLI DEL GIORNO ===
    function renderConsigliSection() {
      const picks = state.dailyPicks;
      const totalPicks = picks.gg.length + picks.vittorieCasa.length + picks.vittorieOspite.length + picks.pareggi.length + picks.over25.length;
      
      return `
        <div class="consigli-section">
          <div class="consigli-header">
            <div class="consigli-title"><span style="color: var(--accent-gold);">ðŸ’¡</span> Consigli del Giorno IA</div>
            <div class="consigli-badge">${totalPicks} pronostici selezionati</div>
          </div>
          
          ${totalPicks === 0 ? `
            <div class="live-empty">
              <div class="live-empty-icon">ðŸ“Š</div>
              <div>Nessun consiglio disponibile</div>
              <div style="font-size: 0.8rem; margin-top: 8px; color: var(--text-dark);">
                Carica le partite di oggi per vedere i consigli IA
              </div>
            </div>
          ` : `
            <!-- TOP 20 GG DEL GIORNO -->
            ${picks.gg.length > 0 ? `
            <div class="consigli-category">
              <div class="consigli-category-header">
                <span class="consigli-category-icon">âš½</span>
                <span class="consigli-category-title">Top 20 GG del Giorno</span>
                <span class="consigli-category-count">${picks.gg.length} picks</span>
              </div>
              <div class="consigli-grid">
                ${picks.gg.slice(0, 20).map((p, idx) => `
                  <div class="consiglio-card" onclick="selectMatch(${p.match.id})">
                    <div class="consiglio-rank">${idx + 1}</div>
                    <div class="consiglio-info">
                      <div class="consiglio-match">${esc(p.match.home.name)} vs ${esc(p.match.away.name)}</div>
                      <div class="consiglio-league">${p.time} â€¢ xG: ${p.xgTotal || 'N/A'}</div>
                    </div>
                    <div class="consiglio-bet">
                      <span class="consiglio-value">GG</span>
                      <span class="consiglio-prob">${p.prob.toFixed(0)}%</span>
                    </div>
                  </div>
                `).join('')}
              </div>
            </div>
            ` : ''}
            
            <!-- TOP 20 OVER 2.5 DEL GIORNO -->
            ${picks.over25.length > 0 ? `
            <div class="consigli-category">
              <div class="consigli-category-header">
                <span class="consigli-category-icon">ðŸ”¥</span>
                <span class="consigli-category-title">Top 20 Over 2.5</span>
                <span class="consigli-category-count">${picks.over25.length} picks</span>
              </div>
              <div class="consigli-grid">
                ${picks.over25.slice(0, 20).map((p, idx) => `
                  <div class="consiglio-card" onclick="selectMatch(${p.match.id})">
                    <div class="consiglio-rank">${idx + 1}</div>
                    <div class="consiglio-info">
                      <div class="consiglio-match">${esc(p.match.home.name)} vs ${esc(p.match.away.name)}</div>
                      <div class="consiglio-league">${p.time} â€¢ xG: ${p.xgTotal}</div>
                    </div>
                    <div class="consiglio-bet">
                      <span class="consiglio-value">O 2.5</span>
                      <span class="consiglio-prob">${p.prob.toFixed(0)}%</span>
                    </div>
                  </div>
                `).join('')}
              </div>
            </div>
            ` : ''}
            
            <!-- TOP 20 VITTORIE CASA -->
            ${picks.vittorieCasa.length > 0 ? `
            <div class="consigli-category">
              <div class="consigli-category-header">
                <span class="consigli-category-icon">ðŸ </span>
                <span class="consigli-category-title">Top 20 Vittorie Casa (1)</span>
                <span class="consigli-category-count">${picks.vittorieCasa.length} picks</span>
              </div>
              <div class="consigli-grid">
                ${picks.vittorieCasa.slice(0, 20).map((p, idx) => `
                  <div class="consiglio-card" onclick="selectMatch(${p.match.id})">
                    <div class="consiglio-rank">${idx + 1}</div>
                    <div class="consiglio-info">
                      <div class="consiglio-match">${esc(p.match.home.name)} vs ${esc(p.match.away.name)}</div>
                      <div class="consiglio-league">${p.time} â€¢ xG: ${p.homeXG || 'N/A'}</div>
                    </div>
                    <div class="consiglio-bet">
                      <span class="consiglio-value">1</span>
                      <span class="consiglio-prob">${p.prob.toFixed(0)}%</span>
                    </div>
                  </div>
                `).join('')}
              </div>
            </div>
            ` : ''}
            
            <!-- TOP 20 VITTORIE OSPITE -->
            ${picks.vittorieOspite.length > 0 ? `
            <div class="consigli-category">
              <div class="consigli-category-header">
                <span class="consigli-category-icon">âœˆï¸</span>
                <span class="consigli-category-title">Top 20 Vittorie Ospite (2)</span>
                <span class="consigli-category-count">${picks.vittorieOspite.length} picks</span>
              </div>
              <div class="consigli-grid">
                ${picks.vittorieOspite.slice(0, 20).map((p, idx) => `
                  <div class="consiglio-card" onclick="selectMatch(${p.match.id})">
                    <div class="consiglio-rank">${idx + 1}</div>
                    <div class="consiglio-info">
                      <div class="consiglio-match">${esc(p.match.home.name)} vs ${esc(p.match.away.name)}</div>
                      <div class="consiglio-league">${p.time} â€¢ xG: ${p.awayXG || 'N/A'}</div>
                    </div>
                    <div class="consiglio-bet">
                      <span class="consiglio-value">2</span>
                      <span class="consiglio-prob">${p.prob.toFixed(0)}%</span>
                    </div>
                  </div>
                `).join('')}
              </div>
            </div>
            ` : ''}
            
            <!-- TOP 20 PAREGGI (X) DEL GIORNO -->
            ${picks.pareggi.length > 0 ? `
            <div class="consigli-category">
              <div class="consigli-category-header">
                <span class="consigli-category-icon">ðŸŽ²</span>
                <span class="consigli-category-title">Top 20 Pareggi (X) del Giorno</span>
                <span class="consigli-category-count">${picks.pareggi.length} picks</span>
              </div>
              <div class="consigli-grid">
                ${picks.pareggi.slice(0, 20).map((p, idx) => `
                  <div class="consiglio-card" onclick="selectMatch(${p.match.id})">
                    <div class="consiglio-rank">${idx + 1}</div>
                    <div class="consiglio-info">
                      <div class="consiglio-match">${esc(p.match.home.name)} vs ${esc(p.match.away.name)}</div>
                      <div class="consiglio-league">${p.time} â€¢ ${esc(p.league)}</div>
                    </div>
                    <div class="consiglio-bet">
                      <span class="consiglio-value">X</span>
                      <span class="consiglio-prob">${p.prob.toFixed(0)}%</span>
                    </div>
                  </div>
                `).join('')}
              </div>
            </div>
            ` : ''}
          `}
        </div>
      `;
    }
    
    function renderLiveSection() {
      if (state.liveLoading) {
        return `
          <div class="live-section">
            <div class="live-header">
              <div class="live-title"><span class="live-dot"></span> LIVE Alerts</div>
            </div>
            <div class="loading"><div class="spinner"></div><div class="loading-text">Caricamento partite live...</div></div>
          </div>
        `;
      }
      
      const alerts = state.liveAlerts;
      
      return `
        <div class="live-section">
          <div class="live-header">
            <div class="live-title"><span class="live-dot"></span> LIVE Alerts</div>
            <div style="display: flex; align-items: center; gap: 12px;">
              <div class="live-auto-refresh">ðŸ”„ Auto-refresh <span class="live-countdown">${state.liveCountdown}s</span></div>
              <button class="live-refresh-btn" id="refreshLive">âŸ³ Aggiorna</button>
            </div>
          </div>
          
          ${alerts.length === 0 ? `
            <div class="live-empty">
              <div class="live-empty-icon">ðŸ“¡</div>
              <div>Nessun alert al momento</div>
              <div style="font-size: 0.8rem; margin-top: 8px; color: var(--text-dark);">
                ${state.liveMatches.length} partite live monitorate
              </div>
            </div>
          ` : `
            <div class="live-alerts-grid">
              ${alerts.map(alert => `
                <div class="live-alert-card ${alert.level}">
                  <div class="live-alert-header">
                    <div class="live-alert-level">${alert.level === 'high' ? 'ðŸš¨ ALERT ALTO' : alert.level === 'medium' ? 'âš ï¸ ALERT MEDIO' : 'ðŸ”µ INFO'}</div>
                    <div class="live-alert-time"><span class="live-dot"></span> ${alert.match.elapsed}'</div>
                  </div>
                  <div class="live-alert-body">
                    <div class="live-alert-match">
                      <div class="live-alert-teams">${esc(alert.match.home.name)} vs ${esc(alert.match.away.name)}</div>
                      <div class="live-alert-score">${alert.match.goals.home} - ${alert.match.goals.away}</div>
                    </div>
                    <div class="live-alert-stats">
                      <div class="live-stat">ðŸŽ¯ Tiri in porta: <strong>${alert.stats.shotsOnHome || 0}-${alert.stats.shotsOnAway || 0}</strong></div>
                      <div class="live-stat">âš½ Tiri totali: <strong>${alert.stats.shotsHome || 0}-${alert.stats.shotsAway || 0}</strong></div>
                      <div class="live-stat">ðŸš© Corner: <strong>${alert.stats.cornersHome || 0}-${alert.stats.cornersAway || 0}</strong></div>
                      <div class="live-stat">ðŸ“Š Possesso: <strong>${alert.stats.possessionHome || 50}%-${alert.stats.possessionAway || 50}%</strong></div>
                    </div>
                    <div class="live-alert-pick">
                      <div class="live-pick-label">CONSIGLIO LIVE</div>
                      <div class="live-pick-value">${alert.pick}</div>
                      <div class="live-pick-details">
                        <span class="live-pick-prob">ðŸ“ˆ ${alert.prob}% prob</span>
                        <span style="color: var(--accent-yellow);">ðŸ’° ~@${alert.quota}</span>
                      </div>
                      <div class="live-pick-reason">ðŸ’¡ ${alert.reason}</div>
                      <button class="live-track-btn ${state.trackedBets.some(b => b.matchId === alert.match.id && b.isLive) ? 'tracked' : ''}"
                              onclick="trackLiveBet(${alert.match.id}, '${esc(alert.match.home.name)} vs ${esc(alert.match.away.name)}', '${esc(alert.pick)}', ${alert.prob}, ${alert.quota}, event)"
                              ${state.trackedBets.some(b => b.matchId === alert.match.id && b.isLive) ? 'disabled' : ''}>
                        ${state.trackedBets.some(b => b.matchId === alert.match.id && b.isLive) ? 'âœ… Tracciato' : 'ðŸŽ¯ GIOCATO'}
                      </button>
                    </div>
                  </div>
                </div>
              `).join('')}
            </div>
          `}
          
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
            <div style="font-size: 0.8rem; color: var(--text-dark); margin-bottom: 8px;">ðŸ“Š Statistiche Monitorate</div>
            <div style="display: flex; gap: 16px; flex-wrap: wrap; font-size: 0.85rem; color: var(--text-gray);">
              <span>ðŸ”´ Partite LIVE: <strong style="color: var(--text-white);">${state.liveMatches.length}</strong></span>
              <span>ðŸš¨ Alert Alti: <strong style="color: var(--accent-red);">${alerts.filter(a => a.level === 'high').length}</strong></span>
              <span>âš ï¸ Alert Medi: <strong style="color: var(--accent-yellow);">${alerts.filter(a => a.level === 'medium').length}</strong></span>
            </div>
          </div>
        </div>
      `;
    }

    function renderMatches() {
      const matches = state.matches.filter(m => m.league.id === state.selectedLeague.id).sort((a, b) => a.timestamp - b.timestamp);
      
      return `
        <div class="back-btn" id="backToLeagues">â† Campionati</div>
        <div class="panel">
          <div class="panel-title">âš½ ${esc(state.selectedLeague.country)} - ${esc(state.selectedLeague.name)}</div>
          <div class="matches-list">
            ${matches.map(m => {
              const isLive = ['1H','2H','HT','ET','P','LIVE'].includes(m.status);
              return `
                <div class="match-item" data-id="${m.id}">
                  <div class="match-item-left">
                    <div class="match-item-time">${isLive ? m.elapsed+"'" : formatTime(m.date)}</div>
                    <div class="match-item-teams">${esc(m.home.name)} vs ${esc(m.away.name)}</div>
                  </div>
                  <div class="match-item-badge ${isLive ? 'live' : ''}">${isLive ? 'LIVE' : formatDate(m.date)}</div>
                </div>
              `;
            }).join('')}
          </div>
        </div>
      `;
    }

    function renderAnalysis() {
      const m = state.selectedMatch;
      const d = state.analysis;
      if (!d) return `<div class="back-btn" id="backToMatches">â† Partite</div><div class="empty">Errore analisi</div>`;
      
      // Genera consiglio AI
      const ai = generateAIAdvice(m, d);
      const stat = generateStatisticalAdvice(m, d);

      return `
        <div class="back-btn" id="backToMatches">â† Partite</div>
        
        <div class="analysis-hero">
          <div class="hero-league">${esc(m.league.country)} â€¢ ${esc(m.league.name)} â€¢ ${formatDateFull(m.date)} ${formatTime(m.date)}</div>
          <div class="hero-match">
            <div class="hero-team">
              ${m.home.logo ? `<img src="${m.home.logo}" class="hero-team-logo" onerror="this.style.display='none'">` : `<div class="hero-team-logo-fallback">${getInitials(m.home.name)}</div>`}
              <div class="hero-team-name">${esc(m.home.name)}</div>
            </div>
            <div class="hero-prediction">
              <div class="hero-score-box">${d.exactScores[0].h}</div>
              <div class="hero-vs">VS</div>
              <div class="hero-score-box">${d.exactScores[0].a}</div>
            </div>
            <div class="hero-team">
              ${m.away.logo ? `<img src="${m.away.logo}" class="hero-team-logo" onerror="this.style.display='none'">` : `<div class="hero-team-logo-fallback">${getInitials(m.away.name)}</div>`}
              <div class="hero-team-name">${esc(m.away.name)}</div>
            </div>
          </div>
          
          <!-- MG CASA / MG OSPITE sotto risultato esatto previsto -->
          <div class="hero-mg-section">
            <div class="hero-mg-box">
              <div class="hero-mg-label">ðŸ  MG ${m.home.name.split(' ')[0]}</div>
              <div class="hero-mg-value">${d.multigoalHome ? d.multigoalHome.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).range : 'N/A'}</div>
              <div class="hero-mg-prob">${d.multigoalHome ? d.multigoalHome.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).prob.toFixed(0) : 0}%</div>
            </div>
            <div class="hero-mg-box">
              <div class="hero-mg-label">âœˆï¸ MG ${m.away.name.split(' ')[0]}</div>
              <div class="hero-mg-value">${d.multigoalAway ? d.multigoalAway.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).range : 'N/A'}</div>
              <div class="hero-mg-prob">${d.multigoalAway ? d.multigoalAway.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).prob.toFixed(0) : 0}%</div>
            </div>
          </div>
        </div>
        
        <!-- DUAL ADVICE: AI + STATISTICAL -->
        <div class="dual-advice-container">

          <!-- AI CONSIGLIO -->
          <div class="ai-advice">
          <div class="ai-header">
            <div class="ai-icon">ðŸ¤–</div>
            <div class="ai-title-group">
              <div class="ai-title">Consiglio AI</div>
              <div class="ai-subtitle">Analisi basata su xG, statistiche e probabilitÃ </div>
            </div>
            <div class="ai-confidence ${ai.confidence}">${ai.confidence === 'high' ? 'ðŸŽ¯ Alta' : ai.confidence === 'medium' ? 'âœ“ Media' : 'âš ï¸ Bassa'}</div>
          </div>
          
          <div class="ai-pick">
            <div class="ai-pick-label">Pronostico Consigliato</div>
            <div class="ai-pick-value">${ai.pick}</div>
            <div class="ai-pick-prob">${ai.prob.toFixed(0)}% probabilitÃ </div>
          </div>
          
          <div class="ai-reasoning">
            <div class="ai-reasoning-title">ðŸ’¡ PerchÃ© questo pronostico</div>
            <div class="ai-reasoning-list">
              ${ai.reasons.map(r => `
                <div class="ai-reason ${r.type}">
                  <span class="ai-reason-icon">${r.type === 'positive' ? 'âœ…' : r.type === 'negative' ? 'âš ï¸' : 'ðŸ“Š'}</span>
                  <span>${r.text}</span>
                </div>
              `).join('')}
            </div>
          </div>
          
          ${ai.alternatives.length > 0 ? `
            <div class="ai-alternatives">
              <div class="ai-alt-title">Alternative valide:</div>
              <div class="ai-alt-grid">
                ${ai.alternatives.map(a => `
                  <div class="ai-alt-chip">${a.pick}<span>${a.prob}%</span></div>
                `).join('')}
              </div>
            </div>
          ` : ''}
          
          <button class="track-btn ${state.trackedBets.some(b => b.matchId === m.id && b.type === 'prematch') ? 'tracked' : ''}" 
                  onclick="trackPrematchBet(${m.id}, '${esc(m.home.name)} vs ${esc(m.away.name)}', '${esc(ai.pick)}', ${ai.prob.toFixed(0)}, event)"
                  ${state.trackedBets.some(b => b.matchId === m.id && b.type === 'prematch') ? 'disabled' : ''}>
            ${state.trackedBets.some(b => b.matchId === m.id && b.type === 'prematch') ? 'âœ… Pronostico Tracciato' : 'ðŸŽ¯ GIOCATO - Traccia questo pronostico'}
          </button>
        </div>

        <!-- PRONOSTICO STATISTICO -->
        <div class="statistical-advice">
          <div class="ai-header">
            <div class="ai-icon">ðŸ“Š</div>
            <div class="ai-title-group">
              <div class="ai-title" style="background: linear-gradient(135deg, var(--accent-cyan), var(--accent-green)); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Pronostico Statistico</div>
              <div class="ai-subtitle">Basato solo sulla probabilitÃ  piÃ¹ alta</div>
            </div>
            <div class="ai-confidence ${stat.confidence}">${stat.confidence === 'high' ? 'ðŸŽ¯ Alta' : stat.confidence === 'medium' ? 'âœ“ Media' : 'âš ï¸ Bassa'}</div>
          </div>

          <div class="ai-pick">
            <div class="ai-pick-label">Pronostico con Prob. Massima</div>
            <div class="ai-pick-value">${stat.pick}</div>
            <div class="ai-pick-prob">${stat.prob.toFixed(0)}% probabilitÃ </div>
          </div>

          <div class="ai-reasoning">
            <div class="ai-reasoning-title">ðŸ“ˆ Dettagli Statistici</div>
            <div class="ai-reasoning-list">
              <div class="ai-reason positive">
                <span class="ai-reason-icon">âœ…</span>
                <span>Mercato: ${stat.market}</span>
              </div>
              <div class="ai-reason positive">
                <span class="ai-reason-icon">ðŸ“Š</span>
                <span>ProbabilitÃ  piÃ¹ alta tra tutti i pronostici</span>
              </div>
              <div class="ai-reason neutral">
                <span class="ai-reason-icon">ðŸ”¢</span>
                <span>Basato su calcoli Poisson e xG</span>
              </div>
            </div>
          </div>

          ${stat.alternatives.length > 0 ? `
            <div class="ai-alternatives">
              <div class="ai-alt-title">Top 3 alternative:</div>
              <div class="ai-alt-grid">
                ${stat.alternatives.map(a => `
                  <div class="ai-alt-chip">${a.pick}<span>${a.prob}%</span></div>
                `).join('')}
              </div>
            </div>
          ` : ''}
        </div>

      </div>
      
      <!-- TRADER VERDICT -->
      ${renderTraderVerdict(ai, stat, d)}
      
      <!-- STORICO VARIAZIONI -->
      ${renderHistorySection(m.id)}
      
        <div class="combo-panel">
          <div class="combo-title">ðŸ”¥ Combo Suggerite</div>
          <div class="combo-grid">
            ${d.combos.map(c => `
              <div class="combo-card ${isInSlip(m.id, 'combo_'+c.value) ? 'selected' : ''}" data-market="combo_${c.value}" data-value="${c.value}" data-prob="${c.prob.toFixed(0)}">
                <div class="combo-value">${c.value}</div>
                <div class="combo-stats">
                  <span class="combo-prob">${c.prob.toFixed(0)}%</span>
                  <span class="combo-odds">@${c.odds}</span>
                </div>
              </div>
            `).join('')}
          </div>
        </div>
        
        <div class="analysis-grid">
          <div class="analysis-card">
            <div class="card-title">
              <div class="card-title-icon">ðŸ“Š</div>
              <span>Expected Goals</span>
              <span class="card-title-badge">${d.xG.total.toFixed(2)}</span>
            </div>
            <div class="prob-row">
              <span class="prob-label">${m.home.name.split(' ')[0]}</span>
              <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${(d.xG.home/3)*100}%"></div></div>
              <span class="prob-value">${d.xG.home.toFixed(2)}</span>
            </div>
            <div class="prob-row">
              <span class="prob-label">${m.away.name.split(' ')[0]}</span>
              <div class="prob-bar-track"><div class="prob-bar-fill green" style="width:${(d.xG.away/3)*100}%"></div></div>
              <span class="prob-value">${d.xG.away.toFixed(2)}</span>
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">ðŸŽ¯</div><span>1X2</span></div>
            <div class="prob-row">
              <span class="prob-label">1 Casa</span>
              <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${d.p1X2.home}%"></div></div>
              <span class="prob-value">${d.p1X2.home.toFixed(0)}%</span>
            </div>
            <div class="prob-row">
              <span class="prob-label">X Pari</span>
              <div class="prob-bar-track"><div class="prob-bar-fill yellow" style="width:${d.p1X2.draw}%"></div></div>
              <span class="prob-value">${d.p1X2.draw.toFixed(0)}%</span>
            </div>
            <div class="prob-row">
              <span class="prob-label">2 Ospite</span>
              <div class="prob-bar-track"><div class="prob-bar-fill purple" style="width:${d.p1X2.away}%"></div></div>
              <span class="prob-value">${d.p1X2.away.toFixed(0)}%</span>
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">âš½</div><span>Over/Under & GG</span></div>
            ${[1.5, 2.5, 3.5].map(l => `
              <div class="prob-row">
                <span class="prob-label">O/U ${l}</span>
                <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${d.pOU[l].over}%"></div></div>
                <span class="prob-value">${d.pOU[l].over.toFixed(0)}%</span>
              </div>
            `).join('')}
            <div class="prob-row">
              <span class="prob-label">GG</span>
              <div class="prob-bar-track"><div class="prob-bar-fill green" style="width:${d.pBTTS}%"></div></div>
              <span class="prob-value">${d.pBTTS.toFixed(0)}%</span>
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">ðŸš©</div><span>Corner</span></div>
            <div class="stat-grid">
              <div class="stat-box"><div class="stat-box-label">Casa</div><div class="stat-box-value">${d.corners.home.toFixed(1)}</div><div class="stat-box-sub">media</div></div>
              <div class="stat-box"><div class="stat-box-label">Tot</div><div class="stat-box-value">${d.corners.total.toFixed(1)}</div><div class="stat-box-sub">media</div></div>
              <div class="stat-box"><div class="stat-box-label">Ospite</div><div class="stat-box-value">${d.corners.away.toFixed(1)}</div><div class="stat-box-sub">media</div></div>
            </div>
            <div class="ou-lines" style="margin-top: 12px;">
              ${d.corners.probs ? Object.entries(d.corners.probs).map(([line, p]) => `
                <div class="ou-line-row">
                  <span class="ou-line-label">Corner ${line}</span>
                  <span class="ou-line-over ${p.over >= 55 ? 'highlight' : ''}">O ${p.over.toFixed(0)}%</span>
                  <span class="ou-line-under ${p.under >= 55 ? 'highlight' : ''}">U ${p.under.toFixed(0)}%</span>
                </div>
              `).join('') : ''}
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">ðŸŸ¨</div><span>Cartellini</span></div>
            <div class="stat-grid">
              <div class="stat-box"><div class="stat-box-label">Casa</div><div class="stat-box-value">${d.cards.home.toFixed(1)}</div><div class="stat-box-sub">media</div></div>
              <div class="stat-box"><div class="stat-box-label">Tot</div><div class="stat-box-value">${d.cards.total.toFixed(1)}</div><div class="stat-box-sub">media</div></div>
              <div class="stat-box"><div class="stat-box-label">Ospite</div><div class="stat-box-value">${d.cards.away.toFixed(1)}</div><div class="stat-box-sub">media</div></div>
            </div>
            <div class="ou-lines" style="margin-top: 12px;">
              ${d.cards.probs ? Object.entries(d.cards.probs).map(([line, p]) => `
                <div class="ou-line-row">
                  <span class="ou-line-label">Carte ${line}</span>
                  <span class="ou-line-over ${p.over >= 55 ? 'highlight' : ''}">O ${p.over.toFixed(0)}%</span>
                  <span class="ou-line-under ${p.under >= 55 ? 'highlight' : ''}">U ${p.under.toFixed(0)}%</span>
                </div>
              `).join('') : ''}
            </div>
          </div>
          
          <!-- SEZIONE SCOMMESSE SPECIALI -->
          <div class="analysis-card wide">
            <div class="card-title"><div class="card-title-icon">ðŸŽ°</div><span>Multigoal Range</span></div>
            <div class="multigoal-grid">
              ${d.multigoal ? d.multigoal.slice(0, 6).map((mg, i) => `
                <div class="multigoal-box ${i === 0 ? 'best' : ''}">
                  <div class="multigoal-range">${mg.range}</div>
                  <div class="multigoal-prob">${mg.prob.toFixed(0)}%</div>
                  <div class="multigoal-quota">@${mg.quota}</div>
                </div>
              `).join('') : '<div>N/A</div>'}
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">â±ï¸</div><span>Gol per Tempo</span></div>
            ${d.temporalDistribution ? `
              <div class="prob-row">
                <span class="prob-label">Over 0.5 1Â°T</span>
                <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${d.temporalDistribution.primoTempo.over05}%"></div></div>
                <span class="prob-value">${d.temporalDistribution.primoTempo.over05.toFixed(0)}%</span>
              </div>
              <div class="prob-row">
                <span class="prob-label">Over 0.5 2Â°T</span>
                <div class="prob-bar-track"><div class="prob-bar-fill green" style="width:${d.temporalDistribution.secondoTempo.over05}%"></div></div>
                <span class="prob-value">${d.temporalDistribution.secondoTempo.over05.toFixed(0)}%</span>
              </div>
              <div class="prob-row">
                <span class="prob-label">Over 1.5 1Â°T</span>
                <div class="prob-bar-track"><div class="prob-bar-fill yellow" style="width:${d.temporalDistribution.primoTempo.over15}%"></div></div>
                <span class="prob-value">${d.temporalDistribution.primoTempo.over15.toFixed(0)}%</span>
              </div>
              <div class="tempo-highlight">
                <span>âš¡ Tempo con piÃ¹ gol:</span>
                <strong>${d.temporalDistribution.tempoConPiuGol}</strong>
                <span class="tempo-prob">(${d.temporalDistribution.probTempoConPiuGol.toFixed(0)}%)</span>
              </div>
            ` : '<div>N/A</div>'}
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">ðŸ </div><span>MG ${m.home.name.split(' ')[0]}</span></div>
            ${d.multigoalHome ? d.multigoalHome.map(mg => `
              <div class="prob-row">
                <span class="prob-label">${mg.range} gol</span>
                <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${mg.prob}%"></div></div>
                <span class="prob-value">${mg.prob.toFixed(0)}%</span>
              </div>
            `).join('') : '<div>N/A</div>'}
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">âœˆï¸</div><span>MG ${m.away.name.split(' ')[0]}</span></div>
            ${d.multigoalAway ? d.multigoalAway.map(mg => `
              <div class="prob-row">
                <span class="prob-label">${mg.range} gol</span>
                <div class="prob-bar-track"><div class="prob-bar-fill purple" style="width:${mg.prob}%"></div></div>
                <span class="prob-value">${mg.prob.toFixed(0)}%</span>
              </div>
            `).join('') : '<div>N/A</div>'}
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">ðŸ“ˆ</div><span>Forma + MG Consigliato</span></div>
            <div class="form-display">
              <div class="form-team">
                <span class="form-team-name">${m.home.name.split(' ')[0]}</span>
                <span class="form-string">${d.homeForm ? d.homeForm.split('').map(c => 
                  c === 'W' ? '<span class="form-w">V</span>' : 
                  c === 'D' ? '<span class="form-d">P</span>' : 
                  '<span class="form-l">S</span>'
                ).join('') : 'N/A'}</span>
              </div>
              <div class="form-team">
                <span class="form-team-name">${m.away.name.split(' ')[0]}</span>
                <span class="form-string">${d.awayForm ? d.awayForm.split('').map(c => 
                  c === 'W' ? '<span class="form-w">V</span>' : 
                  c === 'D' ? '<span class="form-d">P</span>' : 
                  '<span class="form-l">S</span>'
                ).join('') : 'N/A'}</span>
              </div>
            </div>
            <!-- MG PIÃ™ PROBABILE -->
            <div style="display: flex; gap: 10px; margin-top: 12px;">
              <div class="mg-best-box" style="flex:1">
                <div class="mg-best-label">ðŸ  MG ${m.home.name.split(' ')[0]}</div>
                <div class="mg-best-value">${d.multigoalHome ? d.multigoalHome.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).range : 'N/A'}</div>
                <div class="mg-best-prob">${d.multigoalHome ? d.multigoalHome.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).prob.toFixed(0) : 0}%</div>
              </div>
              <div class="mg-best-box" style="flex:1">
                <div class="mg-best-label">âœˆï¸ MG ${m.away.name.split(' ')[0]}</div>
                <div class="mg-best-value">${d.multigoalAway ? d.multigoalAway.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).range : 'N/A'}</div>
                <div class="mg-best-prob">${d.multigoalAway ? d.multigoalAway.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).prob.toFixed(0) : 0}%</div>
              </div>
            </div>
          </div>
          
          <!-- CLASSIFICA E MOTIVAZIONE -->
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">ðŸ†</div><span>Classifica</span></div>
            ${d.homePosition ? `
              <div class="standings-card">
                <div class="standings-header">
                  <div>
                    <span style="font-weight:600; font-size:0.85rem;">${m.home.name.split(' ')[0]}</span>
                    <span class="standings-position">${d.homePosition.position}Â°<sup>/${d.homePosition.totalTeams}</sup></span>
                  </div>
                  <span class="motivation-badge ${d.homePosition.motivationColor}">${d.homePosition.motivationText}</span>
                </div>
                <div class="standings-stats">
                  <span class="standings-stat">ðŸ“Š ${d.homePosition.points} pt</span>
                  <span class="standings-stat">âœ… ${d.homePosition.won}V</span>
                  <span class="standings-stat">âž– ${d.homePosition.draw}P</span>
                  <span class="standings-stat">âŒ ${d.homePosition.lost}S</span>
                </div>
              </div>
            ` : '<div class="standings-card"><span style="color:var(--text-dark)">Classifica non disponibile</span></div>'}
            ${d.awayPosition ? `
              <div class="standings-card">
                <div class="standings-header">
                  <div>
                    <span style="font-weight:600; font-size:0.85rem;">${m.away.name.split(' ')[0]}</span>
                    <span class="standings-position">${d.awayPosition.position}Â°<sup>/${d.awayPosition.totalTeams}</sup></span>
                  </div>
                  <span class="motivation-badge ${d.awayPosition.motivationColor}">${d.awayPosition.motivationText}</span>
                </div>
                <div class="standings-stats">
                  <span class="standings-stat">ðŸ“Š ${d.awayPosition.points} pt</span>
                  <span class="standings-stat">âœ… ${d.awayPosition.won}V</span>
                  <span class="standings-stat">âž– ${d.awayPosition.draw}P</span>
                  <span class="standings-stat">âŒ ${d.awayPosition.lost}S</span>
                </div>
              </div>
            ` : ''}
          </div>
          
          <!-- INFORTUNATI -->
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">ðŸ¥</div><span>Assenze</span></div>
            <div class="injuries-card" style="margin-bottom: 8px;">
              <div class="injuries-header">
                <span>ðŸ  ${m.home.name.split(' ')[0]}</span>
              </div>
              ${d.homeInjuries && d.homeInjuries.length > 0 ? `
                <div class="injuries-list">
                  ${d.homeInjuries.slice(0, 5).map(inj => `
                    <span class="injury-chip">âŒ ${inj.player}</span>
                  `).join('')}
                  ${d.homeInjuries.length > 5 ? `<span class="injury-chip">+${d.homeInjuries.length - 5} altri</span>` : ''}
                </div>
              ` : '<span class="no-injuries">âœ… Rosa completa</span>'}
            </div>
            <div class="injuries-card">
              <div class="injuries-header">
                <span>âœˆï¸ ${m.away.name.split(' ')[0]}</span>
              </div>
              ${d.awayInjuries && d.awayInjuries.length > 0 ? `
                <div class="injuries-list">
                  ${d.awayInjuries.slice(0, 5).map(inj => `
                    <span class="injury-chip">âŒ ${inj.player}</span>
                  `).join('')}
                  ${d.awayInjuries.length > 5 ? `<span class="injury-chip">+${d.awayInjuries.length - 5} altri</span>` : ''}
                </div>
              ` : '<span class="no-injuries">âœ… Rosa completa</span>'}
            </div>
          </div>
          
          <div class="analysis-card wide">
            <div class="card-title"><div class="card-title-icon">ðŸŽ²</div><span>Risultati Esatti</span></div>
            <div class="scores-grid">
              ${d.exactScores.map((s, i) => `
                <div class="score-box ${i === 0 ? 'highlight' : ''}">
                  <div class="score-box-value">${s.h}-${s.a}</div>
                  <div class="score-box-prob">${s.p.toFixed(1)}%</div>
                </div>
              `).join('')}
            </div>
            <!-- MG CASA / MG OSPITE sotto risultati esatti -->
            <div class="mg-under-scores">
              <div class="mg-box-compact">
                <div class="mg-box-label">ðŸ  MG ${m.home.name.split(' ')[0]}</div>
                <div class="mg-box-value">${d.multigoalHome ? d.multigoalHome.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).range : 'N/A'}</div>
                <div class="mg-box-prob">${d.multigoalHome ? d.multigoalHome.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).prob.toFixed(0) : 0}%</div>
              </div>
              <div class="mg-box-compact">
                <div class="mg-box-label">âœˆï¸ MG ${m.away.name.split(' ')[0]}</div>
                <div class="mg-box-value">${d.multigoalAway ? d.multigoalAway.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).range : 'N/A'}</div>
                <div class="mg-box-prob">${d.multigoalAway ? d.multigoalAway.reduce((best, mg) => mg.prob > best.prob ? mg : best, {range:'N/A', prob:0}).prob.toFixed(0) : 0}%</div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="predictions-panel">
          <div class="predictions-header">
            <div class="predictions-title">âš½ PRONOSTICI AI</div>
            <div class="predictions-subtitle">Clicca per aggiungere alla schedina</div>
            <div class="predictions-legend">
              <div class="legend-item"><span class="legend-dot high"></span> Alta (&gt;65%)</div>
              <div class="legend-item"><span class="legend-dot mid"></span> Media (50-65%)</div>
              <div class="legend-item"><span class="legend-dot low"></span> Bassa (&lt;50%)</div>
            </div>
          </div>
          <div class="predictions-grid">
            ${d.predictions.map(p => `
              <div class="prediction-card ${isInSlip(m.id, p.market) ? 'selected' : ''}" data-market="${p.market}" data-value="${p.value}" data-prob="${p.prob.toFixed(0)}">
                <div class="prediction-market">${p.market}</div>
                <div class="prediction-value">${p.value}</div>
                <div class="prediction-prob ${getProbClass(p.prob)}">${p.prob.toFixed(0)}%</div>
              </div>
            `).join('')}
          </div>
        </div>
      `;
    }

    function renderSlipFloating() {
      if (state.slip.length === 0) return '';
      return `
        <div class="slip-floating">
          <div class="slip-count">ðŸŽ« ${state.slip.length} pronostici</div>
          <button class="slip-btn primary" id="viewSlip">ðŸ“‹ Vedi</button>
          <button class="slip-btn secondary" id="copySlip">ðŸ“‹ Copia</button>
          <button class="slip-btn danger" id="clearSlip">ðŸ—‘ï¸</button>
        </div>
      `;
    }

    function renderSlipModal() {
      const totalProb = state.slip.reduce((acc, s) => acc * (s.prob / 100), 1) * 100;
      return `
        <div class="slip-modal" id="slipModal">
          <div class="slip-modal-content">
            <div class="slip-modal-header">
              <div class="slip-modal-title">ðŸŽ« La Tua Schedina</div>
              <button class="slip-modal-close" id="closeSlip">Ã—</button>
            </div>
            <div class="slip-modal-body">
              ${state.slip.map(s => `
                <div class="slip-item">
                  <div class="slip-item-info">
                    <div class="slip-item-match">${esc(s.matchName)}</div>
                    <div class="slip-item-bet">${s.market}: ${s.value}</div>
                    <div class="slip-item-prob">${s.prob}%</div>
                  </div>
                  <button class="slip-item-remove" data-key="${s.key}">Ã—</button>
                </div>
              `).join('')}
              <div class="slip-total">
                <div class="slip-total-label">ProbabilitÃ  Combinata</div>
                <div class="slip-total-value">${totalProb.toFixed(2)}%</div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function attachEvents() {
      // LIVE Tab
      // Consigli Tab
      document.getElementById('consigliTab')?.addEventListener('click', toggleConsigliMode);
      document.getElementById('refreshLive')?.addEventListener('click', loadLiveMatches);
      
      // Date tabs
      document.querySelectorAll('.date-tab[data-date]').forEach(tab => {
        tab.addEventListener('click', () => {
          if (state.liveMode) {
            state.liveMode = false;
            stopLiveAutoRefresh();
          }
          state.consigliMode = false; // Disattiva anche consigli mode
          loadMatches(parseInt(tab.dataset.date));
        });
      });
      
      // League select
      document.getElementById('leagueSelect')?.addEventListener('change', e => {
        const id = parseInt(e.target.value);
        if (id) {
          state.selectedLeague = state.leagues.find(l => l.id === id);
          state.view = 'matches';
          render();
        }
      });
      
      // Back buttons
      document.getElementById('backToLeagues')?.addEventListener('click', () => {
        state.view = 'leagues';
        state.selectedLeague = null;
        render();
      });
      
      document.getElementById('backToMatches')?.addEventListener('click', () => {
        state.view = 'matches';
        state.selectedMatch = null;
        state.analysis = null;
        render();
      });
      
      // Match items
      document.querySelectorAll('.match-item').forEach(el => {
        el.addEventListener('click', () => {
          const m = state.matches.find(x => x.id === parseInt(el.dataset.id));
          if (m) analyzeMatch(m);
        });
      });
      
      // PICK CARDS nella home - aggiungi alla schedina
      document.querySelectorAll('.pick-card').forEach(el => {
        el.addEventListener('click', () => {
          const matchId = parseInt(el.dataset.matchid);
          const match = state.matches.find(m => m.id === matchId);
          if (match) {
            addToSlip(match, el.dataset.market, el.dataset.value, parseFloat(el.dataset.prob));
          }
        });
      });
      
      // RADDOPPI COMBINATI - aggiungi tutte le scommesse alla schedina
      document.querySelectorAll('.raddoppio-card').forEach(el => {
        el.addEventListener('click', () => {
          const idx = parseInt(el.dataset.raddoppio);
          const raddoppio = state.dailyPicks.raddoppi[idx];
          if (raddoppio) {
            raddoppio.bets.forEach(b => {
              addToSlip(b.match, 'radd_' + b.bet, b.bet, b.prob);
            });
          }
        });
      });
      
      // Predictions click to add (nella pagina analisi)
      document.querySelectorAll('.prediction-card, .combo-card').forEach(el => {
        el.addEventListener('click', () => {
          const m = state.selectedMatch;
          if (m) addToSlip(m, el.dataset.market, el.dataset.value, parseFloat(el.dataset.prob));
        });
      });
      
      // MONEY MANAGEMENT
      document.getElementById('bankrollInput')?.addEventListener('change', e => {
        state.money.bankroll = parseFloat(e.target.value) || 100;
        saveMoney();
        render();
      });
      
      document.getElementById('targetInput')?.addEventListener('change', e => {
        state.money.target = parseFloat(e.target.value) || 500;
        saveMoney();
        render();
      });
      
      document.getElementById('totalBetsInput')?.addEventListener('change', e => {
        state.money.totalBets = parseInt(e.target.value) || 10;
        saveMoney();
        render();
      });
      
      document.getElementById('oddsInput')?.addEventListener('change', e => {
        state.money.currentOdds = parseFloat(e.target.value) || 1.80;
        saveMoney();
        render();
      });
      
      // BET RESULT BUTTONS
      document.getElementById('betWin')?.addEventListener('click', () => recordBetResult(true));
      document.getElementById('betLoss')?.addEventListener('click', () => recordBetResult(false));
      document.getElementById('betReset')?.addEventListener('click', resetMoney);
      
      // Slip actions
      document.getElementById('openSlip')?.addEventListener('click', () => { state.slipModal = true; render(); });
      document.getElementById('viewSlip')?.addEventListener('click', () => { state.slipModal = true; render(); });
      document.getElementById('closeSlip')?.addEventListener('click', () => { state.slipModal = false; render(); });
      document.getElementById('slipModal')?.addEventListener('click', e => { if (e.target.id === 'slipModal') { state.slipModal = false; render(); }});
      document.getElementById('clearSlip')?.addEventListener('click', clearSlip);
      
      document.getElementById('copySlip')?.addEventListener('click', () => {
        const text = state.slip.map(s => `${s.matchName}: ${s.market} ${s.value} (${s.prob}%)`).join('\n');
        navigator.clipboard.writeText(text);
        alert('Schedina copiata!');
      });
      
      // Remove from slip
      document.querySelectorAll('.slip-item-remove').forEach(btn => {
        btn.addEventListener('click', () => removeFromSlip(btn.dataset.key));
      });
    }

    // === INIT ===
    async function init() {
      console.log('ðŸš€ BettingPro v5 starting...');
      
      // Mostra interfaccia subito
      loadSlipFromLocalStorage();
      loadTrackingFromLocalStorage();
      render();
      
      // Check API status in background (non bloccante)
      checkAPIStatus().catch(e => console.warn('API check failed:', e));
      
      // Carica partite
      try {
        await loadMatches(0);
      } catch (e) {
        console.error('Load matches failed:', e);
        state.loading = false;
        render();
      }
      
      // Verifica automatica risultati pronostici pendenti (non bloccante)
      autoVerifyPendingBets().catch(e => console.warn('Auto-verify failed:', e));
      
      // Controlla risultati ogni 10 minuti
      setInterval(() => {
        autoVerifyPendingBets().catch(e => console.warn('Auto-verify interval failed:', e));
      }, 10 * 60 * 1000);
    }

    init();
  </script>
</body>
</html>


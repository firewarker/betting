<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BettingPro - AI Betting Intelligence</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #0c1222;
      --bg-card: #141d2f;
      --bg-card-light: #1a2642;
      --bg-input: #0f172a;
      --accent-cyan: #22d3ee;
      --accent-blue: #3b82f6;
      --accent-green: #10b981;
      --accent-yellow: #fbbf24;
      --accent-red: #ef4444;
      --accent-purple: #a855f7;
      --text-white: #ffffff;
      --text-gray: #94a3b8;
      --text-dark: #64748b;
      --border: rgba(255,255,255,0.08);
      --glow-cyan: 0 0 20px rgba(34, 211, 238, 0.3);
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, sans-serif;
      background: var(--bg-dark);
      background-image: radial-gradient(ellipse at top, rgba(34,211,238,0.05) 0%, transparent 50%),
                        radial-gradient(ellipse at bottom right, rgba(59,130,246,0.05) 0%, transparent 50%);
      color: var(--text-white);
      min-height: 100vh;
      padding-bottom: 100px;
    }
    .header {
      background: rgba(12,18,34,0.95);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--border);
      padding: 12px 24px;
      position: sticky;
      top: 0;
      z-index: 100;
    }
    .header-inner {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
    }
    .brand { display: flex; align-items: center; gap: 12px; }
    .brand-icon {
      width: 40px; height: 40px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      border-radius: 10px;
      display: flex; align-items: center; justify-content: center;
      font-size: 1.3rem;
    }
    .brand-name {
      font-size: 1.3rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .header-right { display: flex; align-items: center; gap: 16px; }
    .status-bar { display: flex; gap: 12px; }
    .status-item { display: flex; align-items: center; gap: 6px; font-size: 0.7rem; color: var(--text-dark); }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--text-dark); }
    .status-dot.online { background: var(--accent-green); box-shadow: 0 0 8px var(--accent-green); }
    .status-dot.loading { background: var(--accent-yellow); animation: blink 1s infinite; }
    @keyframes blink { 0%,100%{opacity:1} 50%{opacity:.3} }
    .slip-badge {
      display: flex; align-items: center; gap: 8px;
      padding: 8px 16px;
      background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
      border-radius: 20px;
      font-size: 0.8rem; font-weight: 700;
      cursor: pointer;
    }
    .slip-badge:hover { transform: scale(1.05); }
    .stats-badge {
      display: flex; align-items: center; gap: 8px;
      padding: 8px 16px;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
      border-radius: 20px;
      font-size: 0.8rem; font-weight: 700;
      cursor: pointer;
    }
    .stats-badge:hover { transform: scale(1.05); }
    .stats-modal {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.85);
      display: flex; align-items: center; justify-content: center;
      z-index: 2000; padding: 20px;
    }
    .stats-modal-content {
      background: var(--bg-card);
      border-radius: 20px;
      width: 100%; max-width: 600px;
      max-height: 90vh; overflow-y: auto;
      border: 1px solid var(--border);
    }
    .stats-modal-header {
      display: flex; justify-content: space-between; align-items: center;
      padding: 20px; border-bottom: 1px solid var(--border);
    }
    .stats-modal-title { font-size: 1.2rem; font-weight: 800; color: var(--accent-purple); }
    .stats-modal-close { background: none; border: none; color: var(--text-gray); font-size: 1.5rem; cursor: pointer; }
    .stats-modal-body { padding: 20px; }
    .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 20px; }
    .stats-grid-item { background: var(--bg-input); padding: 16px; border-radius: 12px; text-align: center; }
    .stats-grid-value { font-size: 1.5rem; font-weight: 800; }
    .stats-grid-value.green { color: var(--accent-green); }
    .stats-grid-value.red { color: var(--accent-red); }
    .stats-grid-value.yellow { color: var(--accent-yellow); }
    .stats-grid-value.purple { color: var(--accent-purple); }
    .stats-grid-label { font-size: 0.7rem; color: var(--text-gray); margin-top: 4px; }
    .stats-winrate-box { background: var(--bg-input); border-radius: 16px; padding: 24px; text-align: center; margin-bottom: 20px; }
    .stats-winrate-big { font-size: 3rem; font-weight: 800; }
    .stats-winrate-big.good { color: var(--accent-green); }
    .stats-winrate-big.medium { color: var(--accent-yellow); }
    .stats-winrate-big.bad { color: var(--accent-red); }
    .stats-winrate-label { font-size: 0.9rem; color: var(--text-gray); }
    .stats-by-pick { margin-top: 20px; }
    .stats-pick-title { font-size: 0.9rem; font-weight: 700; margin-bottom: 12px; color: var(--text-white); }
    .stats-pick-item { display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; background: var(--bg-input); border-radius: 8px; margin-bottom: 8px; }
    .stats-pick-name { font-size: 0.85rem; color: var(--text-gray); }
    .stats-pick-rate { font-size: 0.85rem; font-weight: 700; }
    .stats-pick-rate.good { color: var(--accent-green); }
    .stats-pick-rate.medium { color: var(--accent-yellow); }
    .stats-pick-rate.bad { color: var(--accent-red); }
    .stats-buttons { display: flex; gap: 10px; margin-top: 20px; }
    .stats-btn { flex: 1; padding: 12px; border: none; border-radius: 10px; font-weight: 700; cursor: pointer; }
    .stats-btn-check { background: var(--accent-cyan); color: var(--bg-dark); }
    .stats-btn-reset { background: var(--accent-red); color: white; }
    .main { max-width: 1400px; margin: 0 auto; padding: 24px; }
    .date-tabs {
      display: flex; gap: 8px; margin-bottom: 20px; flex-wrap: wrap;
    }
    .date-tab {
      padding: 10px 20px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.85rem; font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .date-tab:hover { border-color: var(--accent-cyan); color: var(--text-white); }
    .date-tab.active {
      background: linear-gradient(135deg, rgba(34,211,238,0.2), rgba(59,130,246,0.2));
      border-color: var(--accent-cyan);
      color: var(--accent-cyan);
    }
    .panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .panel-title { font-size: 1rem; font-weight: 700; margin-bottom: 16px; color: var(--accent-cyan); }
    .select-field {
      width: 100%;
      padding: 14px 18px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-white);
      font-size: 0.95rem;
      cursor: pointer;
    }
    .select-field:focus { outline: none; border-color: var(--accent-cyan); }
    .matches-list { display: flex; flex-direction: column; gap: 10px; }
    .match-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 18px;
      background: var(--bg-card-light);
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .match-item:hover {
      border-color: var(--accent-cyan);
      transform: translateX(4px);
    }
    .match-item-left { display: flex; align-items: center; gap: 14px; flex: 1; min-width: 0; }
    .match-item-time {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      color: var(--accent-cyan);
      min-width: 45px;
    }
    .match-item-teams { font-weight: 600; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .match-item-badge {
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.65rem;
      font-weight: 700;
      background: var(--bg-input);
      color: var(--text-gray);
      flex-shrink: 0;
    }
    .match-item-badge.live { background: var(--accent-red); color: white; }
    .back-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 20px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.85rem;
      cursor: pointer;
      margin-bottom: 20px;
    }
    .back-btn:hover { border-color: var(--accent-cyan); color: var(--accent-cyan); }
    .analysis-hero {
      background: linear-gradient(145deg, var(--bg-card), var(--bg-card-light));
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 30px;
      margin-bottom: 20px;
      text-align: center;
    }
    .hero-league { font-size: 0.8rem; color: var(--text-dark); margin-bottom: 20px; }
    .hero-match { display: flex; align-items: center; justify-content: center; gap: 24px; margin-bottom: 20px; flex-wrap: wrap; }
    .hero-team { display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .hero-team-logo { width: 60px; height: 60px; object-fit: contain; }
    .hero-team-logo-fallback {
      width: 60px; height: 60px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      border-radius: 14px;
      display: flex; align-items: center; justify-content: center;
      font-weight: 700; font-size: 1rem;
    }
    .hero-team-name { font-size: 1rem; font-weight: 700; max-width: 120px; text-align: center; }
    .hero-prediction { display: flex; align-items: center; gap: 10px; }
    .hero-score-box {
      width: 50px; height: 50px;
      background: var(--bg-input);
      border: 2px solid var(--accent-cyan);
      border-radius: 12px;
      display: flex; align-items: center; justify-content: center;
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.5rem; font-weight: 700;
    }
    .hero-vs { padding: 6px 12px; background: var(--accent-blue); border-radius: 6px; font-weight: 700; font-size: 0.8rem; }
    .analysis-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; margin-bottom: 20px; }
    .analysis-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
    }
    .analysis-card.wide { grid-column: 1 / -1; }
    .card-title {
      display: flex; align-items: center; gap: 10px;
      margin-bottom: 16px;
      font-size: 0.9rem; font-weight: 700;
    }
    .card-title-icon {
      width: 32px; height: 32px;
      background: linear-gradient(135deg, rgba(34,211,238,0.2), rgba(59,130,246,0.2));
      border-radius: 8px;
      display: flex; align-items: center; justify-content: center;
      font-size: 1rem;
    }
    .card-title-badge {
      margin-left: auto;
      padding: 4px 10px;
      background: var(--accent-cyan);
      border-radius: 6px;
      font-size: 0.7rem; font-weight: 700;
      color: var(--bg-dark);
    }
    .prob-row { display: flex; align-items: center; gap: 10px; margin-bottom: 12px; }
    .prob-row:last-child { margin-bottom: 0; }
    .prob-label { width: 80px; font-size: 0.8rem; color: var(--text-gray); }
    .prob-bar-track { flex: 1; height: 8px; background: var(--bg-input); border-radius: 4px; overflow: hidden; }
    .prob-bar-fill { height: 100%; border-radius: 4px; }
    .prob-bar-fill.cyan { background: linear-gradient(90deg, var(--accent-cyan), var(--accent-blue)); }
    .prob-bar-fill.green { background: linear-gradient(90deg, var(--accent-green), #34d399); }
    .prob-bar-fill.yellow { background: linear-gradient(90deg, var(--accent-yellow), #fcd34d); }
    .prob-bar-fill.purple { background: linear-gradient(90deg, var(--accent-purple), #c084fc); }
    .prob-value {
      width: 50px; text-align: right;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem; font-weight: 600;
      color: var(--accent-cyan);
    }
    .stat-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
    .stat-box {
      background: var(--bg-card-light);
      border-radius: 10px;
      padding: 12px;
      text-align: center;
    }
    .stat-box-label { font-size: 0.65rem; color: var(--text-dark); margin-bottom: 4px; text-transform: uppercase; }
    .stat-box-value { font-family: 'JetBrains Mono', monospace; font-size: 1.2rem; font-weight: 700; color: var(--accent-cyan); }
    .stat-box-sub { font-size: 0.6rem; color: var(--text-dark); margin-top: 2px; }
    
    /* CORNER & CARTELLINI POTENZIATI */
    .corner-cards-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .corner-section, .cards-section {
      background: var(--bg-input);
      border-radius: 12px;
      padding: 16px;
    }
    .corner-header, .cards-header {
      font-size: 0.75rem;
      font-weight: 700;
      color: var(--text-dark);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 12px;
      text-align: center;
    }
    .corner-pick, .cards-pick {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--bg-card);
      padding: 10px 14px;
      border-radius: 10px;
      margin-bottom: 12px;
    }
    .corner-pick-value, .cards-pick-value {
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-white);
    }
    .corner-pick-prob, .cards-pick-prob {
      font-size: 0.9rem;
      font-weight: 700;
      padding: 4px 10px;
      border-radius: 6px;
    }
    .corner-pick-prob.high, .cards-pick-prob.high { background: var(--accent-green); color: var(--bg-dark); }
    .corner-pick-prob.medium, .cards-pick-prob.medium { background: var(--accent-yellow); color: var(--bg-dark); }
    .corner-stats, .cards-stats { display: flex; flex-direction: column; gap: 6px; }
    .corner-stat, .cards-stat {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: var(--text-gray);
    }
    .corner-stat strong, .cards-stat strong { color: var(--text-white); }
    .corner-stat.total, .cards-stat.total {
      margin-top: 4px;
      padding-top: 6px;
      border-top: 1px solid var(--border);
    }
    .corner-stat.total strong { color: var(--accent-cyan); }
    .cards-stat.total strong { color: var(--accent-yellow); }
    .scores-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 8px; }
    .score-box {
      background: var(--bg-card-light);
      border-radius: 8px;
      padding: 10px 6px;
      text-align: center;
    }
    .score-box.highlight { background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue)); }
    .score-box-value { font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; font-weight: 700; }
    .score-box-prob { font-size: 0.6rem; color: var(--text-dark); margin-top: 2px; }
    .score-box.highlight .score-box-prob { color: rgba(255,255,255,0.8); }
    
    /* COMBO SUGGERITE */
    .combo-panel {
      background: linear-gradient(135deg, var(--bg-card), var(--bg-card-light));
      border: 2px solid var(--accent-purple);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 20px;
    }
    .combo-title { font-size: 1.1rem; font-weight: 700; color: var(--accent-purple); margin-bottom: 16px; }
    .combo-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 12px; }
    .combo-card {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    .combo-card:hover { border-color: var(--accent-purple); transform: translateY(-2px); }
    .combo-card.selected { border-color: var(--accent-green); background: rgba(16,185,129,0.1); }
    .combo-value { font-size: 1rem; font-weight: 700; margin-bottom: 8px; }
    .combo-stats { display: flex; justify-content: center; gap: 12px; font-size: 0.75rem; }
    .combo-prob { color: var(--accent-cyan); }
    .combo-odds { color: var(--accent-green); }
    
    /* CONFRONTO PRONOSTICI */
    .comparison-panel {
      background: linear-gradient(135deg, var(--bg-card), var(--bg-card-light));
      border: 2px solid var(--accent-cyan);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 20px;
    }
    .comparison-title { font-size: 1.1rem; font-weight: 700; color: var(--accent-cyan); margin-bottom: 16px; text-align: center; }
    .comparison-grid { display: flex; align-items: center; justify-content: center; gap: 16px; flex-wrap: wrap; }
    .comparison-box {
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      text-align: center;
      flex: 1;
      min-width: 140px;
      max-width: 200px;
    }
    .comparison-box.ai { border-color: var(--accent-purple); }
    .comparison-box.stats { border-color: var(--accent-green); }
    .comparison-box-header { font-size: 0.7rem; font-weight: 700; color: var(--text-dark); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
    .comparison-box.ai .comparison-box-header { color: var(--accent-purple); }
    .comparison-box.stats .comparison-box-header { color: var(--accent-green); }
    .comparison-box-pick { font-size: 1.2rem; font-weight: 800; color: var(--text-white); margin-bottom: 4px; }
    .comparison-box-prob { font-size: 1.5rem; font-weight: 800; color: var(--accent-cyan); margin-bottom: 8px; }
    .comparison-box-basis { font-size: 0.65rem; color: var(--text-dark); line-height: 1.3; }
    .comparison-vs { font-size: 1rem; font-weight: 800; color: var(--text-dark); }
    .comparison-verdict {
      margin-top: 16px;
      padding: 12px 16px;
      background: var(--bg-input);
      border-radius: 10px;
      text-align: center;
      font-size: 0.85rem;
      color: var(--text-gray);
    }
    
    /* PRONOSTICI AI */
    .predictions-panel {
      background: linear-gradient(135deg, var(--bg-card), var(--bg-card-light));
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 20px;
    }
    .predictions-header { text-align: center; margin-bottom: 20px; }
    .predictions-title {
      font-size: 1.3rem; font-weight: 800; margin-bottom: 8px;
      background: linear-gradient(135deg, var(--accent-cyan), var(--accent-blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .predictions-subtitle { font-size: 0.8rem; color: var(--text-dark); }
    .predictions-legend { display: flex; justify-content: center; gap: 16px; margin-top: 10px; font-size: 0.7rem; }
    .legend-item { display: flex; align-items: center; gap: 4px; }
    .legend-dot { width: 10px; height: 10px; border-radius: 50%; }
    .legend-dot.high { background: var(--accent-green); }
    .legend-dot.mid { background: var(--accent-yellow); }
    .legend-dot.low { background: var(--accent-red); }
    .predictions-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 12px; }
    .prediction-card {
      background: var(--bg-input);
      border: 2px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .prediction-card:hover { border-color: var(--accent-cyan); transform: translateY(-2px); }
    .prediction-card.selected { border-color: var(--accent-green); background: rgba(16,185,129,0.15); }
    .prediction-card.selected::after {
      content: 'âœ“';
      position: absolute;
      top: 8px; right: 8px;
      width: 20px; height: 20px;
      background: var(--accent-green);
      border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-size: 0.7rem; font-weight: 700;
    }
    .prediction-market { font-size: 0.65rem; color: var(--text-dark); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px; }
    .prediction-value { font-size: 1.1rem; font-weight: 800; margin-bottom: 8px; }
    .prediction-prob {
      display: inline-flex; align-items: center; gap: 4px;
      padding: 4px 10px;
      border-radius: 12px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.75rem; font-weight: 600;
    }
    .prediction-prob.high { background: rgba(16,185,129,0.2); color: var(--accent-green); }
    .prediction-prob.mid { background: rgba(251,191,36,0.2); color: var(--accent-yellow); }
    .prediction-prob.low { background: rgba(239,68,68,0.2); color: var(--accent-red); }
    
    /* HOME SECTIONS - Picks del giorno */
    .home-sections { display: flex; flex-direction: column; gap: 20px; margin-bottom: 24px; }
    .picks-section {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      position: relative;
      overflow: hidden;
    }
    .picks-section::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 3px;
    }
    .picks-section.raddoppi::before { background: linear-gradient(90deg, var(--accent-green), var(--accent-cyan)); }
    .picks-section.gg::before { background: linear-gradient(90deg, var(--accent-yellow), var(--accent-green)); }
    .picks-section.over::before { background: linear-gradient(90deg, var(--accent-cyan), var(--accent-blue)); }
    .picks-section.pareggi::before { background: linear-gradient(90deg, var(--accent-purple), var(--accent-blue)); }
    .picks-section.over1t::before { background: linear-gradient(90deg, var(--accent-red), var(--accent-yellow)); }
    
    /* AI CONSIGLIO */
    .ai-advice {
      background: linear-gradient(135deg, rgba(168,85,247,0.15), rgba(34,211,238,0.15));
      border: 2px solid var(--accent-purple);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 20px;
      position: relative;
      overflow: hidden;
    }
    .ai-advice::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--accent-purple), var(--accent-cyan), var(--accent-green));
    }
    .ai-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .ai-icon {
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
    }
    .ai-title-group { flex: 1; }
    .ai-title {
      font-size: 1.1rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .ai-subtitle { font-size: 0.75rem; color: var(--text-dark); }
    .ai-confidence {
      padding: 6px 14px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 700;
    }
    .ai-confidence.high { background: rgba(16,185,129,0.2); color: var(--accent-green); }
    .ai-confidence.medium { background: rgba(251,191,36,0.2); color: var(--accent-yellow); }
    .ai-confidence.low { background: rgba(239,68,68,0.2); color: var(--accent-red); }
    .ai-pick {
      background: var(--bg-input);
      border-radius: 16px;
      padding: 20px;
      text-align: center;
      margin-bottom: 16px;
    }
    .ai-pick-label { font-size: 0.7rem; color: var(--text-dark); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
    .ai-pick-value {
      font-size: 1.8rem;
      font-weight: 800;
      color: var(--accent-cyan);
      margin-bottom: 4px;
    }
    .ai-pick-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1rem;
      color: var(--accent-green);
    }
    .ai-reasoning {
      background: var(--bg-card-light);
      border-radius: 12px;
      padding: 16px;
    }
    .ai-reasoning-title {
      font-size: 0.75rem;
      color: var(--text-dark);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .ai-reasoning-list { display: flex; flex-direction: column; gap: 8px; }
    .ai-reason {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.85rem;
      color: var(--text-gray);
    }
    .ai-reason-icon { font-size: 1rem; }
    .ai-reason.positive { color: var(--accent-green); }
    .ai-reason.negative { color: var(--accent-red); }
    .ai-reason.warning { color: var(--accent-yellow); }
    .ai-reason.neutral { color: var(--accent-yellow); }
    .ai-alternatives {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    .ai-alt-title { font-size: 0.7rem; color: var(--text-dark); margin-bottom: 10px; }
    .ai-alt-grid { display: flex; gap: 10px; flex-wrap: wrap; }
    .ai-alt-chip {
      padding: 8px 14px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 20px;
      font-size: 0.8rem;
      color: var(--text-gray);
      cursor: pointer;
      transition: all 0.2s;
    }
    .ai-alt-chip:hover { border-color: var(--accent-cyan); color: var(--text-white); }
    
    /* LIVE BETTING */
    .live-tab { 
      background: linear-gradient(135deg, var(--accent-red), #ff6b6b) !important; 
      animation: livePulse 2s infinite;
    }
    .live-tab.active { box-shadow: 0 0 20px rgba(239,68,68,0.5); }
    @keyframes livePulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }
    .live-badge-count {
      background: white;
      color: var(--accent-red);
      font-size: 0.7rem;
      font-weight: 800;
      padding: 2px 6px;
      border-radius: 10px;
      margin-left: 6px;
    }
    .live-section {
      background: linear-gradient(145deg, rgba(239,68,68,0.08), rgba(251,191,36,0.08));
      border: 1px solid rgba(239,68,68,0.3);
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .live-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    .live-title {
      font-size: 1.1rem;
      font-weight: 800;
      color: var(--accent-red);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .live-dot {
      width: 10px;
      height: 10px;
      background: var(--accent-red);
      border-radius: 50%;
      animation: livePulse 1s infinite;
    }
    .live-refresh-btn {
      padding: 8px 16px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .live-refresh-btn:hover { border-color: var(--accent-cyan); color: var(--text-white); }
    .live-alerts-grid { display: flex; flex-direction: column; gap: 16px; }
    .live-alert-card {
      background: var(--bg-card);
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid var(--border);
      transition: all 0.3s;
    }
    .live-alert-card:hover { transform: translateY(-2px); box-shadow: 0 8px 24px rgba(0,0,0,0.3); }
    .live-alert-card.high { border-color: var(--accent-red); border-width: 2px; }
    .live-alert-card.medium { border-color: var(--accent-yellow); }
    .live-alert-card.low { border-color: var(--accent-cyan); }
    .live-alert-header {
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .live-alert-card.high .live-alert-header { background: rgba(239,68,68,0.15); }
    .live-alert-card.medium .live-alert-header { background: rgba(251,191,36,0.15); }
    .live-alert-card.low .live-alert-header { background: rgba(34,211,238,0.15); }
    .live-alert-level {
      font-size: 0.75rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .live-alert-card.high .live-alert-level { color: var(--accent-red); }
    .live-alert-card.medium .live-alert-level { color: var(--accent-yellow); }
    .live-alert-card.low .live-alert-level { color: var(--accent-cyan); }
    .live-alert-time {
      display: flex;
      align-items: center;
      gap: 6px;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 700;
      color: var(--accent-red);
    }
    .live-alert-body { padding: 16px; }
    .live-alert-match {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .live-alert-teams { font-weight: 600; color: var(--text-white); }
    .live-alert-score {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.2rem;
      font-weight: 800;
      color: var(--accent-cyan);
      background: var(--bg-input);
      padding: 6px 12px;
      border-radius: 8px;
    }
    .live-alert-stats {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      margin-bottom: 12px;
      padding: 10px;
      background: var(--bg-input);
      border-radius: 10px;
    }
    .live-stat {
      font-size: 0.8rem;
      color: var(--text-gray);
    }
    .live-stat strong { color: var(--text-white); }
    .live-alert-pick {
      background: linear-gradient(135deg, rgba(16,185,129,0.15), rgba(34,211,238,0.15));
      border: 1px solid var(--accent-green);
      border-radius: 12px;
      padding: 14px;
      text-align: center;
    }
    .live-pick-label { font-size: 0.7rem; color: var(--text-dark); margin-bottom: 6px; }
    .live-pick-value {
      font-size: 1.3rem;
      font-weight: 800;
      color: var(--accent-green);
    }
    .live-pick-details {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-top: 8px;
      font-size: 0.85rem;
    }
    .live-pick-prob { color: var(--accent-cyan); }
    .live-pick-reason {
      font-size: 0.8rem;
      color: var(--text-gray);
      margin-top: 10px;
      font-style: italic;
    }
    .live-empty {
      text-align: center;
      padding: 40px;
      color: var(--text-dark);
    }
    .live-empty-icon { font-size: 3rem; margin-bottom: 12px; }
    .live-filters {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .live-filter-btn {
      padding: 6px 14px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 20px;
      font-size: 0.8rem;
      color: var(--text-gray);
      cursor: pointer;
      transition: all 0.2s;
    }
    .live-filter-btn:hover { border-color: var(--accent-cyan); }
    .live-filter-btn.active { background: var(--accent-cyan); color: var(--bg-dark); border-color: var(--accent-cyan); }
    .live-auto-refresh {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.75rem;
      color: var(--text-dark);
    }
    .live-countdown {
      font-family: 'JetBrains Mono', monospace;
      color: var(--accent-cyan);
    }
    .ai-alt-chip span { color: var(--accent-green); margin-left: 6px; }
    .picks-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; }
    .picks-title { display: flex; align-items: center; gap: 10px; font-size: 1rem; font-weight: 700; }
    .picks-title-icon { font-size: 1.3rem; }
    .picks-count { 
      padding: 4px 12px; 
      background: var(--bg-input); 
      border-radius: 12px; 
      font-size: 0.75rem; 
      color: var(--text-gray); 
    }
    .picks-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px; }
    .pick-card {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 16px;
      background: var(--bg-card-light);
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .pick-card:hover { border-color: var(--accent-cyan); transform: translateX(4px); }
    .pick-card.selected { border-color: var(--accent-green); background: rgba(16,185,129,0.1); }
    .pick-info { flex: 1; min-width: 0; }
    .pick-match { font-size: 0.8rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 4px; }
    .pick-league { font-size: 0.65rem; color: var(--text-dark); }
    .pick-bet { display: flex; flex-direction: column; align-items: flex-end; gap: 4px; }
    .pick-value { font-weight: 700; color: var(--accent-cyan); }
    .pick-prob { 
      font-family: 'JetBrains Mono', monospace; 
      font-size: 0.75rem; 
      padding: 2px 8px; 
      border-radius: 6px;
      background: rgba(16,185,129,0.2); 
      color: var(--accent-green); 
    }
    
    /* RADDOPPI COMBINATI */
    .raddoppi-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 14px; }
    .raddoppio-card {
      background: linear-gradient(145deg, var(--bg-card-light), var(--bg-input));
      border: 2px solid var(--accent-green);
      border-radius: 14px;
      padding: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .raddoppio-card:hover { transform: translateY(-3px); box-shadow: 0 8px 24px rgba(16,185,129,0.2); }
    .raddoppio-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .raddoppio-badge {
      background: var(--accent-green);
      color: var(--bg-dark);
      padding: 4px 10px;
      border-radius: 8px;
      font-size: 0.7rem;
      font-weight: 700;
    }
    .raddoppio-odds {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--accent-cyan);
    }
    .raddoppio-bets { display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; }
    .raddoppio-bet {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: var(--bg-input);
      border-radius: 8px;
    }
    .raddoppio-match { font-size: 0.8rem; color: var(--text-gray); }
    .raddoppio-pick { 
      font-weight: 700; 
      color: var(--accent-cyan);
      padding: 2px 8px;
      background: rgba(34,211,238,0.15);
      border-radius: 4px;
      font-size: 0.8rem;
    }
    .raddoppio-footer { text-align: center; }
    .raddoppio-prob {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      color: var(--accent-green);
      font-weight: 600;
    }
    
    /* MONEY MANAGEMENT */
    .money-section {
      background: linear-gradient(135deg, var(--bg-card), var(--bg-card-light));
      border: 2px solid var(--accent-purple);
      border-radius: 20px;
      padding: 24px;
    }
    .money-header { text-align: center; margin-bottom: 20px; }
    .money-title { 
      font-size: 1.2rem; font-weight: 800; 
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 6px;
    }
    .money-subtitle { font-size: 0.8rem; color: var(--text-dark); }
    .money-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 20px; }
    .money-input-group { display: flex; flex-direction: column; gap: 6px; }
    .money-label { font-size: 0.75rem; color: var(--text-gray); text-transform: uppercase; letter-spacing: 0.5px; }
    .money-input {
      padding: 14px 16px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-white);
      font-size: 1.1rem;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 600;
    }
    .money-input:focus { outline: none; border-color: var(--accent-cyan); }
    .money-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; }
    .money-stat {
      background: var(--bg-input);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
    }
    .money-stat-label { font-size: 0.65rem; color: var(--text-dark); text-transform: uppercase; margin-bottom: 6px; }
    .money-stat-value { font-family: 'JetBrains Mono', monospace; font-size: 1.3rem; font-weight: 700; }
    .money-stat-value.green { color: var(--accent-green); }
    .money-stat-value.cyan { color: var(--accent-cyan); }
    .money-stat-value.yellow { color: var(--accent-yellow); }
    .money-stat-value.purple { color: var(--accent-purple); }
    .money-strategy { 
      margin-top: 16px; 
      padding: 16px; 
      background: var(--bg-card-light); 
      border-radius: 12px; 
      display: flex; 
      flex-wrap: wrap; 
      gap: 12px; 
      justify-content: center;
    }
    .strategy-btn {
      padding: 10px 20px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .strategy-btn:hover { border-color: var(--accent-cyan); color: var(--text-white); }
    .strategy-btn.active { background: var(--accent-purple); border-color: var(--accent-purple); color: white; }
    
    /* SISTEMA OBIETTIVO */
    .money-grid-4 { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); 
      gap: 12px; 
      margin-bottom: 20px; 
    }
    .progress-section { margin-bottom: 20px; }
    .progress-bar-container {
      position: relative;
      height: 32px;
      background: var(--bg-input);
      border-radius: 16px;
      overflow: hidden;
    }
    .progress-bar-fill {
      position: absolute;
      top: 0; left: 0; bottom: 0;
      background: linear-gradient(90deg, var(--accent-green), var(--accent-cyan));
      border-radius: 16px;
      transition: width 0.5s;
    }
    .progress-bar-text {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--text-white);
      text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    }
    .stake-section {
      background: linear-gradient(145deg, rgba(34,211,238,0.1), rgba(59,130,246,0.1));
      border: 2px solid var(--accent-cyan);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      text-align: center;
    }
    .stake-section.warning { border-color: var(--accent-yellow); }
    .stake-section.reached { border-color: var(--accent-green); background: rgba(16,185,129,0.15); }
    .stake-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 16px;
      font-size: 0.85rem;
    }
    .stake-label { color: var(--text-gray); font-weight: 600; }
    .stake-remaining { color: var(--accent-cyan); }
    .stake-reached {
      font-size: 1.5rem;
      font-weight: 800;
      color: var(--accent-green);
      padding: 20px;
    }
    .stake-value { margin-bottom: 12px; }
    .stake-amount {
      font-family: 'JetBrains Mono', monospace;
      font-size: 2.5rem;
      font-weight: 800;
      color: var(--accent-cyan);
      text-shadow: 0 0 20px rgba(34,211,238,0.5);
    }
    .stake-info { font-size: 0.85rem; color: var(--text-gray); margin-top: 8px; }
    .stake-warning { 
      font-size: 0.8rem; 
      color: var(--accent-yellow); 
      margin-top: 8px;
      padding: 6px 12px;
      background: rgba(251,191,36,0.1);
      border-radius: 8px;
      display: inline-block;
    }
    .stake-preview {
      font-size: 0.9rem;
      color: var(--text-gray);
      margin-bottom: 16px;
    }
    .stake-preview strong { color: var(--accent-green); }
    .stake-buttons { display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; }
    .stake-btn {
      padding: 12px 28px;
      border: none;
      border-radius: 10px;
      font-size: 0.95rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
    }
    .stake-btn.win { background: var(--accent-green); color: white; }
    .stake-btn.win:hover { transform: scale(1.05); box-shadow: 0 4px 16px rgba(16,185,129,0.4); }
    .stake-btn.loss { background: var(--accent-red); color: white; }
    .stake-btn.loss:hover { transform: scale(1.05); box-shadow: 0 4px 16px rgba(239,68,68,0.4); }
    .stake-btn.reset { background: var(--bg-card); border: 1px solid var(--border); color: var(--text-gray); }
    .stake-btn.reset:hover { border-color: var(--accent-cyan); color: var(--text-white); }
    
    /* SCHEDINA FLOATING */
    .slip-floating {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      background: rgba(12,18,34,0.98);
      backdrop-filter: blur(20px);
      border-top: 1px solid var(--border);
      padding: 12px 20px;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
    }
    .slip-count {
      display: flex; align-items: center; gap: 8px;
      padding: 8px 16px;
      background: var(--accent-cyan);
      border-radius: 20px;
      font-weight: 700;
      color: var(--bg-dark);
    }
    .slip-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 10px;
      font-size: 0.85rem; font-weight: 700;
      cursor: pointer;
      display: flex; align-items: center; gap: 6px;
    }
    .slip-btn.primary { background: var(--accent-green); color: white; }
    .slip-btn.secondary { background: var(--bg-card); border: 1px solid var(--border); color: var(--text-white); }
    .slip-btn.danger { background: transparent; border: 1px solid var(--accent-red); color: var(--accent-red); }
    
    /* SLIP MODAL */
    .slip-modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .slip-modal-content {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 20px;
      width: 100%;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
    }
    .slip-modal-header {
      padding: 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .slip-modal-title { font-size: 1.2rem; font-weight: 700; }
    .slip-modal-close {
      width: 32px; height: 32px;
      background: var(--bg-input);
      border: none;
      border-radius: 8px;
      color: var(--text-gray);
      cursor: pointer;
      font-size: 1.2rem;
    }
    .slip-modal-body { padding: 20px; }
    .slip-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      background: var(--bg-card-light);
      border-radius: 10px;
      margin-bottom: 10px;
    }
    .slip-item-info { flex: 1; }
    .slip-item-match { font-size: 0.75rem; color: var(--text-dark); margin-bottom: 4px; }
    .slip-item-bet { font-weight: 700; }
    .slip-item-prob { font-size: 0.8rem; color: var(--accent-cyan); }
    .slip-item-remove {
      width: 28px; height: 28px;
      background: transparent;
      border: 1px solid var(--accent-red);
      border-radius: 6px;
      color: var(--accent-red);
      cursor: pointer;
    }
    .slip-total {
      padding: 16px;
      background: var(--bg-input);
      border-radius: 12px;
      text-align: center;
      margin-top: 16px;
    }
    .slip-total-label { font-size: 0.8rem; color: var(--text-dark); margin-bottom: 4px; }
    .slip-total-value { font-size: 1.5rem; font-weight: 800; color: var(--accent-green); }
    
    .loading { display: flex; flex-direction: column; align-items: center; padding: 40px; }
    .spinner { width: 40px; height: 40px; border: 3px solid var(--border); border-top-color: var(--accent-cyan); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 12px; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-text { color: var(--text-gray); font-size: 0.9rem; }
    .empty { text-align: center; padding: 40px; color: var(--text-dark); }
    .empty-icon { font-size: 2.5rem; margin-bottom: 12px; }
    
    @media (max-width: 768px) {
      .main { padding: 16px; }
      .header { padding: 10px 16px; }
      .brand-name { font-size: 1.1rem; }
      .status-bar { display: none; }
      .hero-match { gap: 16px; }
      .hero-team-logo, .hero-team-logo-fallback { width: 50px; height: 50px; }
      .hero-score-box { width: 40px; height: 40px; font-size: 1.2rem; }
      .analysis-grid { grid-template-columns: 1fr; }
      .predictions-grid { grid-template-columns: repeat(2, 1fr); }
      .stat-grid { grid-template-columns: repeat(3, 1fr); }
      .combo-grid { grid-template-columns: repeat(2, 1fr); }
      .corner-cards-grid { grid-template-columns: 1fr; }
      .comparison-grid { flex-direction: column; }
      .comparison-box { max-width: 100%; }
      .comparison-vs { display: none; }
      .slip-floating { flex-wrap: wrap; gap: 10px; padding: 10px 16px; }
    }
    
    /* TRACKING & STATS */
    .track-btn {
      background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 10px;
      font-weight: 700;
      cursor: pointer;
      margin-top: 12px;
      width: 100%;
      font-size: 0.95rem;
      transition: all 0.3s;
    }
    .track-btn:hover { transform: scale(1.02); box-shadow: 0 4px 15px rgba(16,185,129,0.4); }
    .track-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    .track-btn.tracked { background: var(--text-dark); }
    
    .stats-section {
      background: linear-gradient(145deg, rgba(168,85,247,0.1), rgba(34,211,238,0.1));
      border: 1px solid rgba(168,85,247,0.3);
      border-radius: 20px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .stats-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    .stats-title {
      font-size: 1.1rem;
      font-weight: 800;
      color: var(--accent-purple);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .stats-overview {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }
    .stats-card {
      background: var(--bg-card);
      padding: 16px;
      border-radius: 12px;
      text-align: center;
    }
    .stats-card-value {
      font-size: 1.8rem;
      font-weight: 800;
      color: var(--text-white);
    }
    .stats-card-value.green { color: var(--accent-green); }
    .stats-card-value.red { color: var(--accent-red); }
    .stats-card-value.yellow { color: var(--accent-yellow); }
    .stats-card-label {
      font-size: 0.75rem;
      color: var(--text-gray);
      margin-top: 4px;
    }
    .stats-winrate {
      background: var(--bg-card);
      padding: 20px;
      border-radius: 16px;
      text-align: center;
      margin-bottom: 20px;
    }
    .stats-winrate-value {
      font-size: 3rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .stats-winrate-label {
      font-size: 0.9rem;
      color: var(--text-gray);
    }
    .stats-breakdown {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .stats-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--bg-card);
      padding: 12px 16px;
      border-radius: 10px;
    }
    .stats-row-label {
      font-weight: 600;
      color: var(--text-white);
    }
    .stats-row-value {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .stats-row-wr {
      font-weight: 700;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.85rem;
    }
    .stats-row-wr.good { background: rgba(16,185,129,0.2); color: var(--accent-green); }
    .stats-row-wr.medium { background: rgba(251,191,36,0.2); color: var(--accent-yellow); }
    .stats-row-wr.bad { background: rgba(239,68,68,0.2); color: var(--accent-red); }
    .stats-row-count {
      font-size: 0.8rem;
      color: var(--text-dark);
    }
    .stats-toggle-btn {
      padding: 8px 16px;
      background: var(--bg-input);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text-gray);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .stats-toggle-btn:hover { border-color: var(--accent-purple); color: var(--text-white); }
    .stats-toggle-btn.active { background: var(--accent-purple); color: white; border-color: var(--accent-purple); }
    
    .live-track-btn {
      background: linear-gradient(135deg, var(--accent-green), var(--accent-cyan));
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      font-weight: 700;
      cursor: pointer;
      font-size: 0.85rem;
      margin-top: 10px;
      transition: all 0.2s;
    }
    .live-track-btn:hover { transform: scale(1.02); }
    .live-track-btn.tracked { background: var(--text-dark); }
    
    @media (max-width: 600px) {
      .stats-overview { grid-template-columns: repeat(2, 1fr); }
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <script>
    // ===================================================
    // BETTINGPRO v5 - COMPLETO CON SCHEDINA E FIREBASE
    // ===================================================
    
    const CONFIG = {
      API_FOOTBALL: {
        key: 'aeb2864a3d4dbb8395fa53c83a876a93',
        baseURL: 'https://v3.football.api-sports.io'
      },
      FOOTYSTATS: {
        key: 'bec59b6f83404b0bd79c40076be71f6f3abec62afdacf5eeba296f2357993f3e',
        baseURL: 'https://api.footystats.org'
      },
      FIREBASE: {
        url: 'https://bettingpro-d0125-default-rtdb.europe-west1.firebasedatabase.app'
      }
    };

    // Generate unique user ID
    const getUserId = () => {
      let id = localStorage.getItem('bettingpro_uid');
      if (!id) {
        id = 'user_' + Math.random().toString(36).substr(2, 9);
        localStorage.setItem('bettingpro_uid', id);
      }
      return id;
    };
    const USER_ID = getUserId();

    let state = {
      view: 'leagues',
      selectedDate: 0, // 0=oggi, -1=ieri, 1=domani, 2=dopodomani
      leagues: [],
      matches: [],
      selectedLeague: null,
      selectedMatch: null,
      analysis: null,
      loading: false,
      api: { football: 'offline', footystats: 'offline' },
      fsData: new Map(),
      slip: [], // Schedina
      slipModal: false,
      // Picks del giorno
      dailyPicks: { raddoppi: [], gg: [], over25: [], pareggi: [], over1T: [] },
      // Money Management - Sistema Obiettivo
      money: {
        bankroll: parseFloat(localStorage.getItem('bp_bankroll')) || 100,
        target: parseFloat(localStorage.getItem('bp_target')) || 500,
        totalBets: parseInt(localStorage.getItem('bp_totalbets')) || 10,
        currentBet: parseInt(localStorage.getItem('bp_currentbet')) || 1,
        currentOdds: parseFloat(localStorage.getItem('bp_odds')) || 1.80,
        history: JSON.parse(localStorage.getItem('bp_history') || '[]')
      },
      // LIVE Betting
      liveMode: false,
      liveMatches: [],
      liveAlerts: [],
      liveLoading: false,
      liveInterval: null,
      liveBackgroundInterval: null,
      countdownInterval: null,
      liveCountdown: 60,
      // Tracking Pronostici
      trackedBets: JSON.parse(localStorage.getItem('bp_tracked') || '[]'),
      statsView: false,
      statsModal: false
    };

    // === UTILITIES ===
    const esc = t => String(t || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]));
    const clamp = (min, v, max) => Math.max(min, Math.min(max, v));
    const formatTime = d => d ? new Date(d).toLocaleTimeString('it-IT', {hour:'2-digit', minute:'2-digit'}) : '--:--';
    const formatDate = d => d ? new Date(d).toLocaleDateString('it-IT', {day:'2-digit', month:'2-digit'}) : '--/--';
    const formatDateFull = d => d ? new Date(d).toLocaleDateString('it-IT', {weekday:'short', day:'2-digit', month:'short'}) : '';
    const getInitials = n => n ? n.split(' ').map(w => w[0]).join('').slice(0,3).toUpperCase() : '??';
    
    function getDateString(offset = 0) {
      const d = new Date();
      d.setDate(d.getDate() + offset);
      return d.toISOString().split('T')[0];
    }
    
    function getDateLabel(offset) {
      if (offset === -1) return 'Ieri';
      if (offset === 0) return 'Oggi';
      if (offset === 1) return 'Domani';
      if (offset === 2) return 'Dopodomani';
      return '';
    }

    // Poisson
    const factorial = n => { let r = 1; for (let i = 2; i <= n; i++) r *= i; return r; };
    const poisson = (l, k) => l <= 0 ? (k === 0 ? 1 : 0) : (Math.pow(l, k) * Math.exp(-l)) / factorial(k);

    // === DAILY PICKS - Analisi rapida di tutte le partite ===
    
    // Campionati TOP con dati affidabili (IDs API-Football)
    const TOP_LEAGUES = [
      // Italia
      135, 136, // Serie A, Serie B
      // Inghilterra
      39, 40, 41, // Premier, Championship, League One
      // Spagna
      140, 141, // La Liga, Segunda
      // Germania
      78, 79, // Bundesliga, 2. Bundesliga
      // Francia
      61, 62, // Ligue 1, Ligue 2
      // Altri top
      88,  // Eredivisie (Olanda)
      94,  // Primeira Liga (Portogallo)
      144, // Jupiler Pro (Belgio)
      203, // Super Lig (Turchia)
      // Coppe europee
      2, 3, 848, // Champions, Europa League, Conference
    ];
    
    function calculateDailyPicks() {
      if (state.matches.length === 0) return;
      
      const picks = { raddoppi: [], gg: [], over25: [], pareggi: [], over1T: [] };
      const safeBets = []; // Per costruire i raddoppi
      
      state.matches.forEach(match => {
        // Skip partite giÃ  iniziate o finite
        if (['1H','2H','HT','ET','P','LIVE','FT','AET','PEN'].includes(match.status)) return;
        
        // Per i RADDOPPI: solo campionati top
        const isTopLeague = TOP_LEAGUES.includes(match.league.id);
        
        // Calcolo rapido basato su FootyStats se disponibile
        let fsMatch = null;
        const fsKeys = [
          `${match.home.name.toLowerCase()}_${match.away.name.toLowerCase()}`,
          match.home.name.toLowerCase().replace(/\s+/g, '') + '_' + match.away.name.toLowerCase().replace(/\s+/g, '')
        ];
        for (const k of fsKeys) {
          if (state.fsData.has(k)) { fsMatch = state.fsData.get(k); break; }
        }
        
        // Stima xG base
        let homeXG = 1.35, awayXG = 1.10;
        
        if (fsMatch) {
          if (fsMatch.home_xg) homeXG = fsMatch.home_xg;
          else if (fsMatch.home_ppg) homeXG = fsMatch.home_ppg * 0.8;
          else if (fsMatch.avg_goals_home) homeXG = fsMatch.avg_goals_home;
          
          if (fsMatch.away_xg) awayXG = fsMatch.away_xg;
          else if (fsMatch.away_ppg) awayXG = fsMatch.away_ppg * 0.7;
          else if (fsMatch.avg_goals_away) awayXG = fsMatch.avg_goals_away;
        }
        
        // Home advantage
        homeXG *= 1.10;
        awayXG *= 0.93;
        
        homeXG = clamp(0.3, homeXG, 3.5);
        awayXG = clamp(0.2, awayXG, 3.0);
        
        const totXG = homeXG + awayXG;
        
        // Calcola probabilitÃ 
        const p1X2 = quickCalc1X2(homeXG, awayXG);
        const pOver15 = quickCalcOver(homeXG, awayXG, 1.5);
        const pOver25 = quickCalcOver(homeXG, awayXG, 2.5);
        const pBTTS = quickCalcBTTS(homeXG, awayXG);
        
        const matchInfo = {
          match,
          matchName: `${match.home.name} vs ${match.away.name}`,
          shortName: `${match.home.name.substring(0,12)} - ${match.away.name.substring(0,12)}`,
          league: `${match.league.country} - ${match.league.name}`,
          time: formatTime(match.date)
        };
        
        // === PRONOSTICI SICURI PER RADDOPPI (solo campionati TOP e prob >= 75%) ===
        if (isTopLeague) {
          const p1X = p1X2.home + p1X2.draw;
          const pX2 = p1X2.draw + p1X2.away;
          
          // 1X (casa o pareggio)
          if (p1X >= 78) {
            safeBets.push({ ...matchInfo, bet: '1X', prob: p1X, odds: (100 / p1X).toFixed(2) });
          }
          // X2 (pareggio o trasferta)
          if (pX2 >= 78) {
            safeBets.push({ ...matchInfo, bet: 'X2', prob: pX2, odds: (100 / pX2).toFixed(2) });
          }
          // Over 1.5
          if (pOver15 >= 80) {
            safeBets.push({ ...matchInfo, bet: 'Over 1.5', prob: pOver15, odds: (100 / pOver15).toFixed(2) });
          }
          // 1 secco molto probabile
          if (p1X2.home >= 73) {
            safeBets.push({ ...matchInfo, bet: '1', prob: p1X2.home, odds: (100 / p1X2.home).toFixed(2) });
          }
          // 2 secco molto probabile
          if (p1X2.away >= 70) {
            safeBets.push({ ...matchInfo, bet: '2', prob: p1X2.away, odds: (100 / p1X2.away).toFixed(2) });
          }
        }
        
        // GG del giorno (prob >= 55%) - tutti i campionati
        if (pBTTS >= 55) {
          picks.gg.push({ ...matchInfo, bet: 'GG', prob: pBTTS });
        }
        
        // OVER 2.5 del giorno - SOLO con xG alto (evita falsi positivi)
        if (pOver25 >= 55 && totXG >= 3.0) {
          picks.over25.push({ ...matchInfo, bet: 'Over 2.5', prob: pOver25, xgTotal: totXG.toFixed(2) });
        }
        
        // PAREGGI del giorno (prob >= 28% - i pareggi hanno sempre prob basse)
        if (p1X2.draw >= 28 && p1X2.home < 50 && p1X2.away < 50) {
          picks.pareggi.push({ ...matchInfo, bet: 'X', prob: p1X2.draw });
        }
        
        // OVER 1Â° TEMPO - Per partite con xG MOLTO alto
        // Circa 45% dei gol avviene nel primo tempo
        const pOver05_1T = quickCalcOver(homeXG * 0.45, awayXG * 0.45, 0.5);
        const pOver15_1T = quickCalcOver(homeXG * 0.45, awayXG * 0.45, 1.5);
        
        // Over 0.5 1T (almeno 1 gol nel primo tempo) - xG >= 3.0
        if (pOver05_1T >= 75 && totXG >= 3.0) {
          picks.over1T.push({ ...matchInfo, bet: 'Over 0.5 1T', prob: pOver05_1T, xgTotal: totXG.toFixed(2) });
        }
        // Over 1.5 1T (almeno 2 gol nel primo tempo) - xG >= 3.8
        if (pOver15_1T >= 55 && totXG >= 3.8) {
          picks.over1T.push({ ...matchInfo, bet: 'Over 1.5 1T', prob: pOver15_1T, xgTotal: totXG.toFixed(2) });
        }
      });
      
      // === COSTRUISCI RADDOPPI (combinazioni che fanno quota ~2.00) ===
      picks.raddoppi = buildRaddoppi(safeBets);
      
      // Ordina per probabilitÃ  decrescente e limita a 6 per categoria
      picks.gg = picks.gg.sort((a, b) => b.prob - a.prob).slice(0, 6);
      picks.over25 = picks.over25.sort((a, b) => b.prob - a.prob).slice(0, 6);
      picks.pareggi = picks.pareggi.sort((a, b) => b.prob - a.prob).slice(0, 6);
      picks.over1T = picks.over1T.sort((a, b) => b.prob - a.prob).slice(0, 6);
      
      state.dailyPicks = picks;
      console.log('ðŸŽ¯ Daily picks:', Object.keys(picks).map(k => `${k}: ${picks[k].length}`).join(', '));
    }
    
    // Costruisce combinazioni per raddoppi (quota target ~2.00)
    function buildRaddoppi(safeBets) {
      if (safeBets.length < 2) return [];
      
      const raddoppi = [];
      const targetOdds = 2.0;
      const tolerance = 0.25; // quota tra 1.75 e 2.25
      
      // Ordina per probabilitÃ  decrescente
      safeBets.sort((a, b) => b.prob - a.prob);
      
      // Prova combinazioni di 2, 3, 4 partite
      for (let size = 2; size <= Math.min(4, safeBets.length); size++) {
        const combos = getCombinations(safeBets, size);
        
        for (const combo of combos) {
          // Verifica che non ci siano partite duplicate
          const matchIds = combo.map(c => c.match.id);
          if (new Set(matchIds).size !== matchIds.length) continue;
          
          // Calcola quota totale e probabilitÃ  combinata
          const totalOdds = combo.reduce((acc, c) => acc * parseFloat(c.odds), 1);
          const totalProb = combo.reduce((acc, c) => acc * (c.prob / 100), 1) * 100;
          
          // Se la quota Ã¨ vicina a 2.00
          if (totalOdds >= targetOdds - tolerance && totalOdds <= targetOdds + tolerance) {
            raddoppi.push({
              bets: combo,
              totalOdds: totalOdds.toFixed(2),
              totalProb: totalProb.toFixed(1),
              size: combo.length
            });
          }
        }
      }
      
      // Ordina per probabilitÃ  combinata e prendi i migliori 6
      return raddoppi
        .sort((a, b) => parseFloat(b.totalProb) - parseFloat(a.totalProb))
        .slice(0, 6);
    }
    
    // Genera combinazioni di k elementi da un array
    function getCombinations(arr, k) {
      if (k === 1) return arr.map(x => [x]);
      if (k === arr.length) return [arr];
      if (k > arr.length) return [];
      
      const result = [];
      const n = arr.length;
      
      // Limita per performance
      const maxCombos = 500;
      let count = 0;
      
      function combine(start, combo) {
        if (count >= maxCombos) return;
        if (combo.length === k) {
          result.push([...combo]);
          count++;
          return;
        }
        for (let i = start; i < n && count < maxCombos; i++) {
          combo.push(arr[i]);
          combine(i + 1, combo);
          combo.pop();
        }
      }
      
      combine(0, []);
      return result;
    }
    
    // Calcoli rapidi per picks (senza Dixon-Coles per velocitÃ )
    function quickCalc1X2(lH, lA) {
      let pH = 0, pD = 0, pA = 0;
      for (let i = 0; i <= 5; i++) {
        for (let j = 0; j <= 5; j++) {
          const p = poisson(lH, i) * poisson(lA, j);
          if (i > j) pH += p; else if (i === j) pD += p; else pA += p;
        }
      }
      const t = pH + pD + pA;
      return { home: (pH/t)*100, draw: (pD/t)*100, away: (pA/t)*100 };
    }
    
    function quickCalcOver(lH, lA, line) {
      let pUnder = 0;
      for (let i = 0; i <= 5; i++) {
        for (let j = 0; j <= 5; j++) {
          if (i + j <= Math.floor(line)) pUnder += poisson(lH, i) * poisson(lA, j);
        }
      }
      return clamp(10, (1 - pUnder) * 100, 90);
    }
    
    function quickCalcBTTS(lH, lA) {
      return clamp(15, (1 - poisson(lH, 0)) * (1 - poisson(lA, 0)) * 100, 85);
    }
    
    // === MONEY MANAGEMENT ===
    // === MONEY MANAGEMENT - SISTEMA OBIETTIVO ===
    
    function saveMoney() {
      localStorage.setItem('bp_bankroll', state.money.bankroll);
      localStorage.setItem('bp_target', state.money.target);
      localStorage.setItem('bp_totalbets', state.money.totalBets);
      localStorage.setItem('bp_currentbet', state.money.currentBet);
      localStorage.setItem('bp_odds', state.money.currentOdds);
      localStorage.setItem('bp_history', JSON.stringify(state.money.history.slice(-30)));
    }
    
    // Calcola quanto puntare per raggiungere l'obiettivo
    function calculateStake() {
      const { bankroll, target, totalBets, currentBet, currentOdds } = state.money;
      const remainingBets = totalBets - currentBet + 1;
      
      if (remainingBets <= 0 || bankroll <= 0 || currentOdds <= 1) {
        return { stake: 0, error: 'Parametri non validi' };
      }
      
      if (bankroll >= target) {
        return { stake: 0, reached: true };
      }
      
      // Calcola il moltiplicatore necessario per giocata
      const totalMultiplier = target / bankroll;
      const perBetMultiplier = Math.pow(totalMultiplier, 1 / remainingBets);
      
      // Calcola la puntata necessaria
      // Se vinco: bankroll + stake Ã— (odds - 1) = bankroll Ã— perBetMultiplier
      const stake = bankroll * (perBetMultiplier - 1) / (currentOdds - 1);
      
      // Limiti di sicurezza
      if (stake > bankroll * 0.95) {
        return { stake: Math.round(bankroll * 0.95 * 100) / 100, warning: 'âš ï¸ Rischio MOLTO alto!' };
      }
      
      if (stake < 0.5) {
        return { stake: 0.5, warning: 'Puntata minima â‚¬0.50' };
      }
      
      return {
        stake: Math.round(stake * 100) / 100,
        perBetMultiplier: perBetMultiplier.toFixed(3),
        potentialWin: Math.round(stake * (currentOdds - 1) * 100) / 100,
        newBankroll: Math.round((bankroll + stake * (currentOdds - 1)) * 100) / 100
      };
    }
    
    function recordBetResult(won) {
      const calc = calculateStake();
      const stake = calc.stake || 0;
      
      state.money.history.push({
        bet: state.money.currentBet,
        date: new Date().toLocaleTimeString('it-IT', {hour:'2-digit', minute:'2-digit'}),
        odds: state.money.currentOdds,
        stake: stake,
        won: won,
        bankrollBefore: state.money.bankroll
      });
      
      if (won) {
        state.money.bankroll += stake * (state.money.currentOdds - 1);
      } else {
        state.money.bankroll -= stake;
      }
      
      state.money.bankroll = Math.max(0, Math.round(state.money.bankroll * 100) / 100);
      state.money.currentBet++;
      
      saveMoney();
      render();
    }
    
    function resetMoney() {
      state.money.currentBet = 1;
      state.money.history = [];
      saveMoney();
      render();
    }
    
    function getMoneyStats() {
      const { bankroll, target, totalBets, currentBet, currentOdds, history } = state.money;
      const calc = calculateStake();
      const wins = history.filter(h => h.won).length;
      const losses = history.filter(h => !h.won).length;
      const progress = Math.min(100, (bankroll / target) * 100);
      
      return {
        bankroll,
        target,
        totalBets,
        currentBet,
        currentOdds,
        remainingBets: Math.max(0, totalBets - currentBet + 1),
        progress,
        stake: calc.stake || 0,
        warning: calc.warning,
        error: calc.error,
        reached: calc.reached,
        potentialWin: calc.potentialWin || 0,
        newBankroll: calc.newBankroll || bankroll,
        perBetMultiplier: calc.perBetMultiplier || '-',
        wins,
        losses,
        winRate: (wins + losses) > 0 ? ((wins / (wins + losses)) * 100).toFixed(0) : '-'
      };
    }

    // === FIREBASE SCHEDINA ===
    async function loadSlipFromFirebase() {
      try {
        const res = await fetch(`${CONFIG.FIREBASE.url}/slips/${USER_ID}.json`);
        const data = await res.json();
        if (data && Array.isArray(data.items)) {
          state.slip = data.items;
          console.log('ðŸ“‹ Schedina caricata:', state.slip.length, 'pronostici');
        }
      } catch (e) {
        console.warn('Firebase load error:', e);
      }
    }

    async function saveSlipToFirebase() {
      try {
        await fetch(`${CONFIG.FIREBASE.url}/slips/${USER_ID}.json`, {
          method: 'PUT',
          body: JSON.stringify({ items: state.slip, updated: Date.now() })
        });
        console.log('ðŸ’¾ Schedina salvata');
      } catch (e) {
        console.warn('Firebase save error:', e);
      }
    }

    function addToSlip(match, market, value, prob) {
      const key = `${match.id}_${market}`;
      const exists = state.slip.find(s => s.key === key);
      if (exists) {
        state.slip = state.slip.filter(s => s.key !== key);
      } else {
        state.slip.push({
          key,
          matchId: match.id,
          matchName: `${match.home.name} vs ${match.away.name}`,
          matchDate: match.date,
          market,
          value,
          prob
        });
      }
      saveSlipToFirebase();
      render();
    }

    function removeFromSlip(key) {
      state.slip = state.slip.filter(s => s.key !== key);
      saveSlipToFirebase();
      render();
    }

    function clearSlip() {
      state.slip = [];
      saveSlipToFirebase();
      render();
    }

    function isInSlip(matchId, market) {
      return state.slip.some(s => s.key === `${matchId}_${market}`);
    }

    // === API CALLS ===
    async function callAPIFootball(endpoint, params = {}) {
      const url = new URL(CONFIG.API_FOOTBALL.baseURL + endpoint);
      Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, v));
      
      state.api.football = 'loading';
      
      try {
        const res = await fetch(url.toString(), {
          headers: {
            'x-rapidapi-key': CONFIG.API_FOOTBALL.key,
            'x-rapidapi-host': 'v3.football.api-sports.io'
          }
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        state.api.football = 'online';
        return data;
      } catch (e) {
        console.error('API Football error:', e);
        state.api.football = 'offline';
        return null;
      }
    }

    async function callFootyStats(endpoint, params = {}) {
      const url = new URL(CONFIG.FOOTYSTATS.baseURL + endpoint);
      url.searchParams.append('key', CONFIG.FOOTYSTATS.key);
      Object.entries(params).forEach(([k, v]) => url.searchParams.append(k, v));
      
      state.api.footystats = 'loading';
      
      // Lista proxy CORS con fallback automatico
      const proxies = [
        'https://api.allorigins.win/raw?url=',
        'https://corsproxy.org/?',
        'https://cors-anywhere.herokuapp.com/'
      ];
      
      for (const proxy of proxies) {
        try {
          const proxyUrl = proxy + encodeURIComponent(url.toString());
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 10000);
          
          const res = await fetch(proxyUrl, { signal: controller.signal });
          clearTimeout(timeout);
          
          if (!res.ok) continue; // Prova prossimo proxy
          
          const data = await res.json();
          state.api.footystats = 'online';
          console.log('âœ… FootyStats OK via:', proxy.split('/')[2]);
          return data;
        } catch (e) {
          console.warn('Proxy failed:', proxy.split('/')[2], e.message);
          continue; // Prova prossimo proxy
        }
      }
      
      // Tutti i proxy falliti
      console.error('FootyStats: tutti i proxy falliti');
      state.api.footystats = 'offline';
      return null;
    }

    // === DATA LOADING ===
    async function loadMatches(dateOffset = 0) {
      state.loading = true;
      state.selectedDate = dateOffset;
      render();
      
      const dateStr = getDateString(dateOffset);
      console.log('ðŸ“… Loading matches for:', dateStr);
      
      const data = await callAPIFootball('/fixtures', { date: dateStr, timezone: 'Europe/Rome' });
      
      if (data?.response) {
        const leagueMap = new Map();
        data.response.forEach(f => {
          const key = f.league.id;
          if (!leagueMap.has(key)) {
            leagueMap.set(key, {
              id: f.league.id,
              name: f.league.name,
              country: f.league.country,
              logo: f.league.logo,
              season: f.league.season,
              matchCount: 0
            });
          }
          leagueMap.get(key).matchCount++;
        });
        
        state.leagues = Array.from(leagueMap.values())
          .sort((a, b) => `${a.country} ${a.name}`.localeCompare(`${b.country} ${b.name}`));
        
        state.matches = data.response.map(f => ({
          id: f.fixture.id,
          date: f.fixture.date,
          timestamp: f.fixture.timestamp,
          status: f.fixture.status.short,
          elapsed: f.fixture.status.elapsed,
          league: f.league,
          home: { id: f.teams.home.id, name: f.teams.home.name, logo: f.teams.home.logo },
          away: { id: f.teams.away.id, name: f.teams.away.name, logo: f.teams.away.logo },
          goals: f.goals
        }));
        
        console.log(`âœ… Loaded ${state.leagues.length} leagues, ${state.matches.length} matches`);
      }
      
      // Load FootyStats
      const fsData = await callFootyStats('/todays-matches', {});
      if (fsData?.data) {
        fsData.data.forEach(m => {
          if (m.home_name && m.away_name) {
            const keys = [
              `${m.home_name.toLowerCase()}_${m.away_name.toLowerCase()}`,
              m.home_name.toLowerCase().replace(/\s+/g, '') + '_' + m.away_name.toLowerCase().replace(/\s+/g, '')
            ];
            keys.forEach(k => state.fsData.set(k, m));
          }
        });
      }
      
      // Calcola i picks del giorno
      calculateDailyPicks();
      
      state.loading = false;
      render();
    }

    // === ANALYSIS ENGINE ===
    async function analyzeMatch(match) {
      state.selectedMatch = match;
      state.view = 'analysis';
      state.loading = true;
      state.analysis = null;
      render();
      
      let homeStats = null, awayStats = null, h2h = [], apiPred = null;
      let homeLastMatches = [], awayLastMatches = [];
      
      try {
        const [hs, as] = await Promise.all([
          callAPIFootball('/teams/statistics', { team: match.home.id, league: match.league.id, season: match.league.season || 2024 }),
          callAPIFootball('/teams/statistics', { team: match.away.id, league: match.league.id, season: match.league.season || 2024 })
        ]);
        homeStats = hs?.response;
        awayStats = as?.response;
      } catch (e) {}
      
      // NUOVO: Ottieni ultime 5 partite per calcolare form REALE
      try {
        const [homeLastRes, awayLastRes] = await Promise.all([
          callAPIFootball('/fixtures', { team: match.home.id, last: 5 }),
          callAPIFootball('/fixtures', { team: match.away.id, last: 5 })
        ]);
        homeLastMatches = homeLastRes?.response || [];
        awayLastMatches = awayLastRes?.response || [];
      } catch (e) {}
      
      try {
        const h2hRes = await callAPIFootball('/fixtures/headtohead', { h2h: `${match.home.id}-${match.away.id}`, last: 10 });
        h2h = h2hRes?.response || [];
      } catch (e) {}
      
      try {
        const predRes = await callAPIFootball('/predictions', { fixture: match.id });
        apiPred = predRes?.response?.[0];
      } catch (e) {}
      
      let fsMatch = null;
      const fsKeys = [
        `${match.home.name.toLowerCase()}_${match.away.name.toLowerCase()}`,
        match.home.name.toLowerCase().replace(/\s+/g, '') + '_' + match.away.name.toLowerCase().replace(/\s+/g, '')
      ];
      for (const k of fsKeys) {
        if (state.fsData.has(k)) {
          fsMatch = state.fsData.get(k);
          break;
        }
      }
      
      // Calcola form reale dalle ultime partite
      const homeForm = calculateRealForm(homeLastMatches, match.home.id);
      const awayForm = calculateRealForm(awayLastMatches, match.away.id);
      
      state.analysis = buildAnalysis(match, homeStats, awayStats, h2h, apiPred, fsMatch, homeForm, awayForm);
      state.loading = false;
      render();
    }
    
    // NUOVO: Calcola form reale dalle ultime partite
    function calculateRealForm(matches, teamId) {
      if (!matches || matches.length === 0) return 'DDDDD';
      
      let form = '';
      matches.forEach(m => {
        const homeGoals = m.goals?.home ?? 0;
        const awayGoals = m.goals?.away ?? 0;
        const isHome = m.teams?.home?.id === teamId;
        
        if (isHome) {
          if (homeGoals > awayGoals) form += 'W';
          else if (homeGoals < awayGoals) form += 'L';
          else form += 'D';
        } else {
          if (awayGoals > homeGoals) form += 'W';
          else if (awayGoals < homeGoals) form += 'L';
          else form += 'D';
        }
      });
      
      return form || 'DDDDD';
    }

    // === ALGORITMO AVANZATO ===
    function buildAnalysis(match, homeStats, awayStats, h2h, apiPred, fsMatch, homeForm, awayForm) {
      // Extract real data
      const homeData = extractTeamData(homeStats, 'home');
      const awayData = extractTeamData(awayStats, 'away');
      
      // NUOVO: Usa form reale calcolata dalle ultime partite
      if (homeForm && homeForm !== 'DDDDD') homeData.form = homeForm;
      if (awayForm && awayForm !== 'DDDDD') awayData.form = awayForm;
      
      // Calculate xG
      let homeXG = calculateXG(homeData, awayData, 'home', apiPred, fsMatch);
      let awayXG = calculateXG(awayData, homeData, 'away', apiPred, fsMatch);
      
      // H2H adjustment
      if (h2h.length >= 3) {
        const adj = analyzeH2H(h2h, match.home.id);
        homeXG *= adj.homeMultiplier;
        awayXG *= adj.awayMultiplier;
      }
      
      // Home advantage (casa gioca meglio, trasferta peggio)
      homeXG *= 1.10;  // +10% vantaggio casa
      awayXG *= 0.93;  // -7% svantaggio trasferta
      
      // Clamp ai valori realistici
      homeXG = clamp(0.25, homeXG, 3.8);
      awayXG = clamp(0.15, awayXG, 3.2);
      
      const totXG = homeXG + awayXG;
      
      // Probabilities
      const p1X2 = calc1X2(homeXG, awayXG);
      const pOU = calcOU(homeXG, awayXG);
      
      // BTTS avanzato: usa Poisson + dati storici clean sheet
      let pBTTS = calcBTTS(homeXG, awayXG);
      
      // Aggiusta BTTS con dati clean sheet e failed to score
      const homeWillScore = 100 - homeData.failedToScorePct; // % che la casa segna
      const awayWillScore = 100 - awayData.failedToScorePct; // % che l'ospite segna
      const historicalBTTS = (homeWillScore * awayWillScore) / 100;
      
      // Media ponderata: 60% Poisson, 40% storico
      pBTTS = (pBTTS * 0.60) + (historicalBTTS * 0.40);
      pBTTS = clamp(15, pBTTS, 85);
      
      const exactScores = calcExactScores(homeXG, awayXG);
      
      // Corners & Cards
      const corners = calcCorners(homeData, awayData, fsMatch);
      const cards = calcCards(homeData, awayData, fsMatch);
      
      // Build predictions
      const predictions = buildPredictions(match, homeXG, awayXG, p1X2, pOU, pBTTS, exactScores, corners, cards);
      
      // Build combos
      const combos = buildCombos(p1X2, pOU, pBTTS);
      
      // H2H info
      const h2hInfo = summarizeH2H(h2h, match.home.id);
      
      // NUOVO: Calcola momentum per entrambe le squadre
      const homeMomentum = calculateMomentum(homeData.form);
      const awayMomentum = calculateMomentum(awayData.form);
      
      return {
        match,
        xG: { home: homeXG, away: awayXG, total: totXG },
        p1X2, pOU, pBTTS,
        exactScores: exactScores.slice(0, 12),
        corners, cards,
        h2h: h2hInfo,
        predictions,
        combos,
        homeMomentum, awayMomentum,
        quality: (homeStats || awayStats) ? 'enhanced' : 'base'
      };
    }

    function extractTeamData(stats, side) {
      if (!stats) return { 
        goalsFor: 1.3, goalsAgainst: 1.2, form: 'DDDDD', corners: 5.0, cards: 1.8,
        cleanSheetPct: 25, failedToScorePct: 25, played: 10, wins: 4, draws: 3, losses: 3
      };
      
      const goals = stats.goals || {};
      const fixtures = stats.fixtures || {};
      const played = (side === 'home' ? fixtures.played?.home : fixtures.played?.away) || fixtures.played?.total || 10;
      const wins = (side === 'home' ? fixtures.wins?.home : fixtures.wins?.away) || fixtures.wins?.total || 4;
      const draws = (side === 'home' ? fixtures.draws?.home : fixtures.draws?.away) || fixtures.draws?.total || 3;
      const losses = (side === 'home' ? fixtures.loses?.home : fixtures.loses?.away) || fixtures.loses?.total || 3;
      
      const forAvg = side === 'home' 
        ? (goals.for?.average?.home || goals.for?.average?.total || 1.3)
        : (goals.for?.average?.away || goals.for?.average?.total || 1.1);
      const againstAvg = side === 'home'
        ? (goals.against?.average?.home || goals.against?.average?.total || 1.2)
        : (goals.against?.average?.away || goals.against?.average?.total || 1.3);
      
      // Clean sheet e failed to score percentuali
      const cleanSheetPct = stats.clean_sheet ? 
        ((side === 'home' ? stats.clean_sheet.home : stats.clean_sheet.away) || stats.clean_sheet.total || 0) / played * 100 : 25;
      const failedToScorePct = stats.failed_to_score ?
        ((side === 'home' ? stats.failed_to_score.home : stats.failed_to_score.away) || stats.failed_to_score.total || 0) / played * 100 : 25;
      
      return {
        goalsFor: parseFloat(forAvg) || 1.3,
        goalsAgainst: parseFloat(againstAvg) || 1.2,
        form: stats.form || 'DDDDD',
        corners: 5.0,
        cards: parseFloat(stats.cards?.yellow?.total) / (played || 1) || 1.8,
        cleanSheetPct: cleanSheetPct || 25,
        failedToScorePct: failedToScorePct || 25,
        played, wins, draws, losses,
        winRate: played > 0 ? (wins / played) * 100 : 40
      };
    }

    function calculateXG(teamData, oppData, side, apiPred, fsMatch) {
      // Base: attacco squadra vs difesa avversaria (ponderato)
      const attackStrength = teamData.goalsFor / 1.25; // Normalizzato su media campionato ~1.25
      const defenseWeakness = oppData.goalsAgainst / 1.25;
      
      let xg = 1.25 * attackStrength * defenseWeakness; // Expected goals base
      
      // Fattore forma recente (peso aumentato al 30%)
      const formMultiplier = calculateFormMultiplier(teamData.form);
      xg = xg * 0.70 + xg * formMultiplier * 0.30;
      
      // NUOVO: Fattore momentum (trend recente - crisi o forma top)
      const momentum = calculateMomentum(teamData.form);
      xg = xg * momentum.multiplier;
      
      // Fattore win rate (squadre che vincono spesso segnano di piÃ¹)
      if (teamData.winRate > 60) xg *= 1.08;
      else if (teamData.winRate < 30) xg *= 0.90;
      
      // Fattore clean sheet avversario (se l'avversario fa molti clean sheet, segnerai meno)
      if (oppData.cleanSheetPct > 40) xg *= 0.88;
      else if (oppData.cleanSheetPct < 20) xg *= 1.10;
      
      // Fattore failed to score (se la squadra spesso non segna)
      if (teamData.failedToScorePct > 35) xg *= 0.85;
      else if (teamData.failedToScorePct < 15) xg *= 1.08;
      
      // API Predictions (peso 35% se disponibili - sono dati molto accurati)
      if (apiPred?.predictions?.goals) {
        const apiGoal = side === 'home' ? parseFloat(apiPred.predictions.goals.home) : parseFloat(apiPred.predictions.goals.away);
        if (apiGoal > 0) xg = (xg * 0.65) + (apiGoal * 0.35);
      }
      
      // FootyStats xG reali (peso 40% se disponibili - sono i piÃ¹ accurati)
      if (fsMatch) {
        const fsXg = side === 'home' ? fsMatch.home_xg : fsMatch.away_xg;
        const fsPpg = side === 'home' ? fsMatch.home_ppg : fsMatch.away_ppg;
        const fsAvgGoals = side === 'home' ? fsMatch.avg_goals_home : fsMatch.avg_goals_away;
        
        if (fsXg && fsXg > 0) {
          xg = (xg * 0.60) + (fsXg * 0.40);
        } else if (fsAvgGoals && fsAvgGoals > 0) {
          xg = (xg * 0.65) + (fsAvgGoals * 0.35);
        } else if (fsPpg && fsPpg > 0) {
          xg = (xg * 0.75) + (fsPpg * 0.6 * 0.25); // PPG convertito in gol attesi
        }
      }
      
      return xg;
    }

    function calculateFormMultiplier(form) {
      if (!form || form.length === 0) return 1.0;
      
      const recent = form.slice(0, 5).split('');
      let score = 0;
      let totalWeight = 0;
      
      recent.forEach((r, i) => {
        // Peso decrescente: partita piÃ¹ recente conta di piÃ¹
        const weight = Math.pow(0.8, i); // 1, 0.8, 0.64, 0.51, 0.41
        totalWeight += weight;
        
        if (r === 'W') score += 1.0 * weight;      // Vittoria = 1.0
        else if (r === 'D') score += 0.35 * weight; // Pareggio = 0.35
        else if (r === 'L') score += 0.0 * weight;  // Sconfitta = 0
      });
      
      const avgScore = totalWeight > 0 ? score / totalWeight : 0.5;
      
      // Converti in moltiplicatore: range 0.80 - 1.20
      // Score 0 (tutte sconfitte) -> 0.80
      // Score 0.5 (medio) -> 1.00
      // Score 1 (tutte vittorie) -> 1.20
      return 0.80 + (avgScore * 0.40);
    }
    
    // NUOVO: Calcola momentum (trend recente) - rileva crisi e momenti top
    function calculateMomentum(form) {
      if (!form || form.length < 3) return { multiplier: 1.0, status: 'normal', message: '' };
      
      const recent = form.slice(0, 5).toUpperCase();
      const wins = (recent.match(/W/g) || []).length;
      const losses = (recent.match(/L/g) || []).length;
      const draws = (recent.match(/D/g) || []).length;
      
      let multiplier = 1.0;
      let status = 'normal';
      let message = '';
      
      // CRISI: 3+ sconfitte nelle ultime 5
      if (losses >= 3) {
        multiplier = 0.85; // -15%
        status = 'crisis';
        message = `In crisi (${wins}V-${draws}P-${losses}S)`;
      }
      // CRISI LIEVE: 0 vittorie nelle ultime 5
      else if (wins === 0 && recent.length >= 4) {
        multiplier = 0.90; // -10%
        status = 'crisis';
        message = `Senza vittorie (${wins}V-${draws}P-${losses}S)`;
      }
      // ON FIRE: 4+ vittorie nelle ultime 5
      else if (wins >= 4) {
        multiplier = 1.10; // +10%
        status = 'hot';
        message = `In grande forma (${wins}V-${draws}P-${losses}S)`;
      }
      // BUONA FORMA: 3 vittorie nelle ultime 5
      else if (wins === 3 && losses <= 1) {
        multiplier = 1.05; // +5%
        status = 'good';
        message = `In buona forma (${wins}V-${draws}P-${losses}S)`;
      }
      // FORMA NEGATIVA: 2+ sconfitte, 0-1 vittorie
      else if (losses >= 2 && wins <= 1) {
        multiplier = 0.93; // -7%
        status = 'poor';
        message = `Forma negativa (${wins}V-${draws}P-${losses}S)`;
      }
      
      return { multiplier, status, message, wins, draws, losses };
    }

    function analyzeH2H(h2h, homeId) {
      if (!h2h || h2h.length === 0) return { homeMultiplier: 1.0, awayMultiplier: 1.0 };
      
      let hg = 0, ag = 0, totalWeight = 0;
      
      h2h.forEach((m, index) => {
        // Peso decrescente per partite piÃ¹ vecchie
        const weight = Math.pow(0.85, index); // Partite recenti contano di piÃ¹
        totalWeight += weight;
        
        const homeGoals = m.goals?.home || 0;
        const awayGoals = m.goals?.away || 0;
        
        if (m.teams?.home?.id === homeId) {
          hg += homeGoals * weight;
          ag += awayGoals * weight;
        } else {
          hg += awayGoals * weight;
          ag += homeGoals * weight;
        }
      });
      
      // Normalizza per il peso totale
      const avgHome = totalWeight > 0 ? hg / totalWeight : 1.2;
      const avgAway = totalWeight > 0 ? ag / totalWeight : 1.0;
      const avgTotal = (avgHome + avgAway) / 2;
      
      // Calcola moltiplicatori con range piÃ¹ ampio per H2H significativi
      const homeMultiplier = avgTotal > 0.1 ? clamp(0.85, avgHome / avgTotal, 1.15) : 1.0;
      const awayMultiplier = avgTotal > 0.1 ? clamp(0.85, avgAway / avgTotal, 1.15) : 1.0;
      
      return { homeMultiplier, awayMultiplier };
    }

    function summarizeH2H(h2h, homeId) {
      const info = { matches: h2h.length, homeWins: 0, draws: 0, awayWins: 0, totalGoals: 0 };
      h2h.forEach(m => {
        const hg = m.goals?.home || 0, ag = m.goals?.away || 0;
        info.totalGoals += hg + ag;
        if (m.teams?.home?.id === homeId) {
          if (hg > ag) info.homeWins++; else if (hg < ag) info.awayWins++; else info.draws++;
        } else {
          if (ag > hg) info.homeWins++; else if (ag < hg) info.awayWins++; else info.draws++;
        }
      });
      info.avgGoals = info.matches ? (info.totalGoals / info.matches).toFixed(1) : '2.5';
      return info;
    }

    function calcCorners(homeData, awayData, fsMatch) {
      // Base: medie italiane tipiche per corner
      let h = 5.2, a = 4.3;
      
      // FootyStats ha dati piÃ¹ precisi sui corner
      if (fsMatch) {
        if (fsMatch.home_corners && fsMatch.home_corners > 0) h = fsMatch.home_corners;
        else if (fsMatch.team_a_corners_avg && fsMatch.team_a_corners_avg > 0) h = fsMatch.team_a_corners_avg;
        
        if (fsMatch.away_corners && fsMatch.away_corners > 0) a = fsMatch.away_corners;
        else if (fsMatch.team_b_corners_avg && fsMatch.team_b_corners_avg > 0) a = fsMatch.team_b_corners_avg;
        
        // Se disponibile media totale della partita
        if (fsMatch.corners_avg && fsMatch.corners_avg > 0) {
          const fsTotal = fsMatch.corners_avg;
          const ratio = h / (h + a);
          h = fsTotal * ratio;
          a = fsTotal * (1 - ratio);
        }
      }
      
      const total = h + a;
      const probs = {};
      
      // Calcolo probabilitÃ  con distribuzione normale approssimata
      [8.5, 9.5, 10.5, 11.5].forEach(line => {
        const diff = total - line;
        // Deviazione standard tipica per corner: ~2.5
        const stdDev = 2.5;
        const zScore = diff / stdDev;
        // Approssimazione della CDF normale
        const overProb = 50 + (zScore * 30); // Semplificazione lineare
        probs[line] = { 
          over: clamp(12, overProb, 88), 
          under: clamp(12, 100 - overProb, 88) 
        };
      });
      
      return { home: h, away: a, total, probs };
    }

    function calcCards(homeData, awayData, fsMatch) {
      let h = homeData.cards, a = awayData.cards;
      if (fsMatch) {
        if (fsMatch.home_cards) h = fsMatch.home_cards;
        if (fsMatch.away_cards) a = fsMatch.away_cards;
      }
      const total = h + a;
      const probs = {};
      [2.5, 3.5, 4.5, 5.5].forEach(line => {
        const diff = total - line;
        probs[line] = { over: clamp(15, 50 + diff * 13, 85), under: clamp(15, 50 - diff * 13, 85) };
      });
      return { home: h, away: a, total, probs };
    }

    function calc1X2(lH, lA) {
      let pH = 0, pD = 0, pA = 0;
      for (let i = 0; i <= 6; i++) {
        for (let j = 0; j <= 6; j++) {
          const p = poisson(lH, i) * poisson(lA, j);
          if (i > j) pH += p; else if (i === j) pD += p; else pA += p;
        }
      }
      const t = pH + pD + pA;
      return { home: (pH/t)*100, draw: (pD/t)*100, away: (pA/t)*100 };
    }

    function calcBTTS(lH, lA) {
      return clamp(15, (1 - poisson(lH, 0)) * (1 - poisson(lA, 0)) * 100, 85);
    }

    function calcOU(lH, lA) {
      const result = {};
      [1.5, 2.5, 3.5, 4.5].forEach(line => {
        let pU = 0;
        for (let i = 0; i <= 6; i++) {
          for (let j = 0; j <= 6; j++) {
            if (i + j <= Math.floor(line)) pU += poisson(lH, i) * poisson(lA, j);
          }
        }
        result[line] = { over: clamp(5, (1 - pU) * 100, 95), under: clamp(5, pU * 100, 95) };
      });
      return result;
    }

    function calcExactScores(lH, lA) {
      const scores = [];
      
      // Dixon-Coles correction factor per risultati a basso punteggio
      // Questo corregge la tendenza del Poisson a sottostimare 0-0, 1-0, 0-1, 1-1
      const rho = 0.13; // Fattore di correlazione (valori tipici: 0.10-0.15)
      
      for (let i = 0; i <= 5; i++) {
        for (let j = 0; j <= 5; j++) {
          let p = poisson(lH, i) * poisson(lA, j);
          
          // Applica Dixon-Coles correction per risultati bassi
          if (i === 0 && j === 0) {
            p *= (1 + lH * lA * rho); // 0-0 leggermente piÃ¹ probabile
          } else if (i === 0 && j === 1) {
            p *= (1 + lH * rho); // 0-1 
          } else if (i === 1 && j === 0) {
            p *= (1 + lA * rho); // 1-0
          } else if (i === 1 && j === 1) {
            p *= (1 - rho); // 1-1 leggermente meno probabile (giÃ  frequente)
          }
          
          scores.push({ h: i, a: j, p: p * 100 });
        }
      }
      
      // Normalizza le probabilitÃ 
      const total = scores.reduce((sum, s) => sum + s.p, 0);
      scores.forEach(s => s.p = (s.p / total) * 100);
      
      return scores.sort((a, b) => b.p - a.p);
    }

    function calcMultigol(lH, lA, min, max) {
      let prob = 0;
      for (let i = 0; i <= 6; i++) {
        for (let j = 0; j <= 6; j++) {
          const t = i + j;
          if (t >= min && t <= max) prob += poisson(lH, i) * poisson(lA, j);
        }
      }
      return prob * 100;
    }

    function calcTeamMultigol(l, min, max) {
      let prob = 0;
      for (let i = min; i <= max; i++) prob += poisson(l, i);
      return prob * 100;
    }

    function buildPredictions(match, homeXG, awayXG, p1X2, pOU, pBTTS, exactScores, corners, cards) {
      const preds = [];
      const totXG = homeXG + awayXG;
      
      // xG Primo Tempo (circa 45% dei gol nel 1T)
      const homeXG_1T = homeXG * 0.45;
      const awayXG_1T = awayXG * 0.45;
      
      // 1X2
      const max1X2 = Math.max(p1X2.home, p1X2.draw, p1X2.away);
      let esito = p1X2.home === max1X2 ? '1' : (p1X2.away === max1X2 ? '2' : 'X');
      preds.push({ market: 'Esito 1X2', value: esito, prob: max1X2 });
      
      // GG/NG
      preds.push({ market: 'GG/NG', value: pBTTS >= 50 ? 'GG' : 'NG', prob: pBTTS >= 50 ? pBTTS : 100-pBTTS });
      
      // Over/Under 2.5
      preds.push({ market: 'O/U 2.5', value: pOU[2.5].over >= 50 ? 'Over 2.5' : 'Under 2.5', prob: Math.max(pOU[2.5].over, pOU[2.5].under) });
      
      // Over/Under 1.5
      preds.push({ market: 'O/U 1.5', value: pOU[1.5].over >= 50 ? 'Over 1.5' : 'Under 1.5', prob: Math.max(pOU[1.5].over, pOU[1.5].under) });
      
      // === OVER PRIMO TEMPO ===
      const pOver05_1T = calcOver1T(homeXG_1T, awayXG_1T, 0.5);
      const pOver15_1T = calcOver1T(homeXG_1T, awayXG_1T, 1.5);
      
      // Over 0.5 1T
      preds.push({ market: 'O/U 0.5 1T', value: pOver05_1T >= 50 ? 'Over 0.5 1T' : 'Under 0.5 1T', prob: Math.max(pOver05_1T, 100 - pOver05_1T) });
      
      // Over 1.5 1T (solo se xG Ã¨ alto)
      if (totXG >= 2.5) {
        preds.push({ market: 'O/U 1.5 1T', value: pOver15_1T >= 50 ? 'Over 1.5 1T' : 'Under 1.5 1T', prob: Math.max(pOver15_1T, 100 - pOver15_1T) });
      }
      
      // Multigol
      const mg13 = calcMultigol(homeXG, awayXG, 1, 3);
      const mg24 = calcMultigol(homeXG, awayXG, 2, 4);
      preds.push({ market: 'Multigol', value: totXG < 2.8 ? '1-3' : '2-4', prob: totXG < 2.8 ? mg13 : mg24 });
      
      // MG Casa 1-3
      const mgH = calcTeamMultigol(homeXG, 1, 3);
      preds.push({ market: 'MG Casa', value: '1-3', prob: mgH });
      
      // MG Ospite 1-3
      const mgA = calcTeamMultigol(awayXG, 1, 3);
      preds.push({ market: 'MG Ospite', value: '1-3', prob: mgA });
      
      // Corner
      const cProb = corners.probs[9.5];
      preds.push({ market: 'Corner', value: cProb.over >= 50 ? 'Over 9.5' : 'Under 9.5', prob: Math.max(cProb.over, cProb.under) });
      
      // Cartellini
      const cardLine = cards.total > 4 ? 4.5 : 3.5;
      const cardProb = cards.probs[cardLine];
      preds.push({ market: 'Cartellini', value: cardProb.over >= 50 ? `Over ${cardLine}` : `Under ${cardLine}`, prob: Math.max(cardProb.over, cardProb.under) });
      
      // Risultato Esatto
      preds.push({ market: 'Ris. Esatto', value: `${exactScores[0].h}-${exactScores[0].a}`, prob: exactScores[0].p });
      
      return preds.sort((a, b) => b.prob - a.prob);
    }
    
    // Calcola Over Primo Tempo
    function calcOver1T(homeXG_1T, awayXG_1T, line) {
      let pUnder = 0;
      for (let i = 0; i <= 4; i++) {
        for (let j = 0; j <= 4; j++) {
          if (i + j <= Math.floor(line)) {
            pUnder += poisson(homeXG_1T, i) * poisson(awayXG_1T, j);
          }
        }
      }
      return clamp(10, (1 - pUnder) * 100, 90);
    }

    function buildCombos(p1X2, pOU, pBTTS) {
      const combos = [];
      
      // 1X + Over 1.5
      const p1X = p1X2.home + p1X2.draw;
      const o15 = pOU[1.5].over;
      combos.push({ value: '1X + Over 1.5', prob: (p1X * o15) / 100, odds: (100 / ((p1X * o15) / 100)).toFixed(2) });
      
      // 1 + Over 1.5
      combos.push({ value: '1 + Over 1.5', prob: (p1X2.home * o15) / 100, odds: (100 / ((p1X2.home * o15) / 100)).toFixed(2) });
      
      // GG + Under 3.5
      const u35 = pOU[3.5].under;
      combos.push({ value: 'GG + Under 3.5', prob: (pBTTS * u35) / 100, odds: (100 / ((pBTTS * u35) / 100)).toFixed(2) });
      
      // GG + Over 2.5
      const o25 = pOU[2.5].over;
      combos.push({ value: 'GG + Over 2.5', prob: (pBTTS * o25) / 100, odds: (100 / ((pBTTS * o25) / 100)).toFixed(2) });
      
      return combos.sort((a, b) => b.prob - a.prob);
    }
    
    // === AI ADVICE - Genera il consiglio intelligente ===
    function generateAIAdvice(match, analysis) {
      const { xG, p1X2, pOU, pBTTS, exactScores } = analysis;
      const homeXG = xG.home;
      const awayXG = xG.away;
      const totXG = xG.total;
      
      const advice = {
        pick: '',
        prob: 0,
        confidence: 'medium',
        reasons: [],
        alternatives: []
      };
      
      // Analisi della partita
      const homeStrong = homeXG > 1.8;
      const awayWeak = awayXG < 0.8;
      const awayStrong = awayXG > 1.5;
      const homeWeak = homeXG < 1.0;
      const highScoring = totXG >= 3.0;
      const veryHighScoring = totXG >= 3.8;
      const lowScoring = totXG < 2.2;
      const balanced = Math.abs(homeXG - awayXG) < 0.5;
      const ggLikely = pBTTS >= 55 && homeXG > 0.9 && awayXG > 0.9;
      
      // === LOGICA DI SELEZIONE ===
      
      // CASO 1: Casa dominante (xG casa alto, ospite basso)
      if (homeStrong && awayWeak && p1X2.home >= 65) {
        advice.pick = '1 (Vittoria Casa)';
        advice.prob = p1X2.home;
        advice.confidence = p1X2.home >= 75 ? 'high' : 'medium';
        advice.reasons.push({ text: `xG Casa ${homeXG.toFixed(2)} molto superiore`, type: 'positive' });
        advice.reasons.push({ text: `xG Ospite solo ${awayXG.toFixed(2)}`, type: 'positive' });
        advice.reasons.push({ text: `ProbabilitÃ  ${p1X2.home.toFixed(0)}% favorevole`, type: 'positive' });
        
        if (highScoring) {
          advice.alternatives.push({ pick: '1 + Over 1.5', prob: ((p1X2.home * pOU[1.5].over) / 100).toFixed(0) });
        }
        advice.alternatives.push({ pick: '1X', prob: (p1X2.home + p1X2.draw).toFixed(0) });
      }
      // CASO 2: Trasferta dominante
      else if (awayStrong && homeWeak && p1X2.away >= 60) {
        advice.pick = '2 (Vittoria Ospite)';
        advice.prob = p1X2.away;
        advice.confidence = p1X2.away >= 70 ? 'high' : 'medium';
        advice.reasons.push({ text: `xG Ospite ${awayXG.toFixed(2)} superiore`, type: 'positive' });
        advice.reasons.push({ text: `xG Casa debole ${homeXG.toFixed(2)}`, type: 'positive' });
        
        advice.alternatives.push({ pick: 'X2', prob: (p1X2.away + p1X2.draw).toFixed(0) });
      }
      // CASO 3: Partita da GOL (xG totale alto)
      else if (veryHighScoring && pOU[2.5].over >= 70) {
        advice.pick = 'Over 2.5';
        advice.prob = pOU[2.5].over;
        advice.confidence = pOU[2.5].over >= 80 ? 'high' : 'medium';
        advice.reasons.push({ text: `xG Totale ${totXG.toFixed(2)} molto alto`, type: 'positive' });
        advice.reasons.push({ text: `Entrambe le squadre segnano regolarmente`, type: 'positive' });
        
        advice.alternatives.push({ pick: 'Over 1.5 1T', prob: '60+' });
        advice.alternatives.push({ pick: 'Over 3.5', prob: pOU[3.5].over.toFixed(0) });
        if (ggLikely) advice.alternatives.push({ pick: 'GG', prob: pBTTS.toFixed(0) });
      }
      // CASO 4: GG probabile (entrambe segnano)
      else if (ggLikely && pBTTS >= 60) {
        advice.pick = 'GG (Entrambe Segnano)';
        advice.prob = pBTTS;
        advice.confidence = pBTTS >= 70 ? 'high' : 'medium';
        advice.reasons.push({ text: `xG Casa ${homeXG.toFixed(2)} - segnerÃ `, type: 'positive' });
        advice.reasons.push({ text: `xG Ospite ${awayXG.toFixed(2)} - segnerÃ `, type: 'positive' });
        
        if (highScoring) advice.alternatives.push({ pick: 'GG + Over 2.5', prob: ((pBTTS * pOU[2.5].over) / 100).toFixed(0) });
        advice.alternatives.push({ pick: 'Over 2.5', prob: pOU[2.5].over.toFixed(0) });
      }
      // CASO 5: Over 1.5 sicuro
      else if (pOU[1.5].over >= 80) {
        advice.pick = 'Over 1.5';
        advice.prob = pOU[1.5].over;
        advice.confidence = 'high';
        advice.reasons.push({ text: `ProbabilitÃ  ${pOU[1.5].over.toFixed(0)}% molto alta`, type: 'positive' });
        advice.reasons.push({ text: `xG Totale ${totXG.toFixed(2)} supporta gol`, type: 'positive' });
        
        advice.alternatives.push({ pick: '1X + Over 1.5', prob: (((p1X2.home + p1X2.draw) * pOU[1.5].over) / 100).toFixed(0) });
      }
      // CASO 6: 1X sicuro (casa non perde)
      else if ((p1X2.home + p1X2.draw) >= 80) {
        advice.pick = '1X (Casa o Pareggio)';
        advice.prob = p1X2.home + p1X2.draw;
        advice.confidence = 'high';
        advice.reasons.push({ text: `Casa forte con xG ${homeXG.toFixed(2)}`, type: 'positive' });
        advice.reasons.push({ text: `Vittoria ospite improbabile (${p1X2.away.toFixed(0)}%)`, type: 'positive' });
        
        advice.alternatives.push({ pick: '1', prob: p1X2.home.toFixed(0) });
        if (highScoring) advice.alternatives.push({ pick: '1X + Over 1.5', prob: (((p1X2.home + p1X2.draw) * pOU[1.5].over) / 100).toFixed(0) });
      }
      // CASO 7: Partita equilibrata
      else if (balanced && p1X2.draw >= 28) {
        advice.pick = 'Under 3.5';
        advice.prob = pOU[3.5].under;
        advice.confidence = lowScoring ? 'medium' : 'low';
        advice.reasons.push({ text: `Partita equilibrata (xG simili)`, type: 'neutral' });
        advice.reasons.push({ text: `Possibile pareggio (${p1X2.draw.toFixed(0)}%)`, type: 'neutral' });
        
        advice.alternatives.push({ pick: 'X', prob: p1X2.draw.toFixed(0) });
        advice.alternatives.push({ pick: 'Under 2.5', prob: pOU[2.5].under.toFixed(0) });
      }
      // CASO 8: Default - Over 1.5 (quasi sempre valido)
      else {
        advice.pick = 'Over 1.5';
        advice.prob = pOU[1.5].over;
        advice.confidence = pOU[1.5].over >= 70 ? 'medium' : 'low';
        advice.reasons.push({ text: `Pronostico piÃ¹ sicuro per questa partita`, type: 'neutral' });
        advice.reasons.push({ text: `xG Totale ${totXG.toFixed(2)}`, type: 'neutral' });
        
        if (p1X2.home >= 55) advice.alternatives.push({ pick: '1X', prob: (p1X2.home + p1X2.draw).toFixed(0) });
      }
      
      // Aggiungi warning se i dati non sono affidabili
      if (analysis.quality === 'base') {
        advice.reasons.push({ text: 'Dati statistici limitati', type: 'negative' });
        if (advice.confidence === 'high') advice.confidence = 'medium';
      }
      
      // NUOVO: Aggiungi warning sul momentum delle squadre
      if (analysis.homeMomentum && analysis.homeMomentum.status === 'crisis') {
        advice.reasons.push({ text: `âš ï¸ ${analysis.match.home.name}: ${analysis.homeMomentum.message}`, type: 'warning' });
        // Abbassa la confidenza se la squadra favorita Ã¨ in crisi
        if (advice.pick.includes('1') && !advice.pick.includes('X') && advice.confidence === 'high') {
          advice.confidence = 'medium';
        }
      } else if (analysis.homeMomentum && analysis.homeMomentum.status === 'hot') {
        advice.reasons.push({ text: `ðŸ”¥ ${analysis.match.home.name}: ${analysis.homeMomentum.message}`, type: 'positive' });
      }
      
      if (analysis.awayMomentum && analysis.awayMomentum.status === 'crisis') {
        advice.reasons.push({ text: `âš ï¸ ${analysis.match.away.name}: ${analysis.awayMomentum.message}`, type: 'warning' });
        // Abbassa la confidenza se la squadra favorita Ã¨ in crisi
        if (advice.pick.includes('2') && advice.confidence === 'high') {
          advice.confidence = 'medium';
        }
      } else if (analysis.awayMomentum && analysis.awayMomentum.status === 'hot') {
        advice.reasons.push({ text: `ðŸ”¥ ${analysis.match.away.name}: ${analysis.awayMomentum.message}`, type: 'positive' });
      }
      
      return advice;
    }

    function getProbClass(prob) {
      if (prob >= 65) return 'high';
      if (prob >= 50) return 'mid';
      return 'low';
    }

    // === LIVE BETTING SYSTEM ===
    
    async function loadLiveMatches() {
      state.liveLoading = true;
      render();
      
      try {
        // Usa la stessa API giÃ  configurata
        const data = await callAPIFootball('/fixtures', { live: 'all' });
        
        if (data && data.response) {
          state.liveMatches = data.response.map(f => ({
            id: f.fixture.id,
            status: f.fixture.status.short,
            elapsed: f.fixture.status.elapsed || 0,
            league: {
              id: f.league.id,
              name: f.league.name,
              country: f.league.country,
              logo: f.league.logo
            },
            home: { id: f.teams.home.id, name: f.teams.home.name, logo: f.teams.home.logo },
            away: { id: f.teams.away.id, name: f.teams.away.name, logo: f.teams.away.logo },
            goals: { home: f.goals.home || 0, away: f.goals.away || 0 },
            stats: f.statistics || []
          }));
          
          // Calcola gli alert
          calculateLiveAlerts();
        }
      } catch (e) {
        console.error('Live load error:', e);
      }
      
      state.liveLoading = false;
      render();
    }
    
    function calculateLiveAlerts() {
      const alerts = [];
      
      state.liveMatches.forEach(match => {
        const elapsed = match.elapsed;
        const homeGoals = match.goals.home;
        const awayGoals = match.goals.away;
        const totalGoals = homeGoals + awayGoals;
        
        // Estrai statistiche se disponibili
        let stats = { shots: 0, shotsOn: 0, corners: 0, possession: 50 };
        if (match.stats && match.stats.length >= 2) {
          const homeStats = match.stats[0]?.statistics || [];
          const awayStats = match.stats[1]?.statistics || [];
          
          const getStat = (arr, type) => {
            const s = arr.find(s => s.type === type);
            return s ? (parseInt(s.value) || 0) : 0;
          };
          
          stats = {
            shotsHome: getStat(homeStats, 'Total Shots'),
            shotsAway: getStat(awayStats, 'Total Shots'),
            shotsOnHome: getStat(homeStats, 'Shots on Goal'),
            shotsOnAway: getStat(awayStats, 'Shots on Goal'),
            cornersHome: getStat(homeStats, 'Corner Kicks'),
            cornersAway: getStat(awayStats, 'Corner Kicks'),
            possessionHome: getStat(homeStats, 'Ball Possession'),
            possessionAway: getStat(awayStats, 'Ball Possession')
          };
          stats.shots = stats.shotsHome + stats.shotsAway;
          stats.shotsOn = stats.shotsOnHome + stats.shotsOnAway;
          stats.corners = stats.cornersHome + stats.cornersAway;
        }
        
        // === LOGICA ALERT OTTIMIZZATA ===
        
        // ALERT 1: 0-0 con tanti tiri (Over 0.5) - Dal 45' al 85'
        if (totalGoals === 0 && elapsed >= 45 && elapsed <= 85) {
          const pressure = stats.shotsOn * 2 + stats.corners * 0.5;
          let prob = 50 + (elapsed - 40) * 0.6 + pressure * 2;
          prob = Math.min(95, prob);
          
          if (prob >= 60 && stats.shotsOn >= 3) {
            const quotaStimata = (100 / prob).toFixed(2);
            alerts.push({
              match,
              type: 'over05',
              level: prob >= 75 ? 'high' : 'medium',
              pick: 'Over 0.5',
              prob: prob.toFixed(0),
              quota: quotaStimata,
              reason: `${stats.shotsOn} tiri in porta, ${stats.corners} corner - il gol arriverÃ !`,
              stats
            });
          }
        }
        
        // ALERT 2: 0-0 o 1-0 tardi (Over 1.5) - Soglia tiri abbassata
        if (totalGoals <= 1 && elapsed >= 55 && elapsed <= 85) {
          const pressure = stats.shotsOn * 1.5 + stats.corners * 0.3;
          let prob = 40 + pressure * 1.8;
          
          if (totalGoals === 0) prob += 15;
          if (elapsed >= 65) prob += 8;
          if (elapsed >= 75) prob += 5;
          prob = Math.min(88, prob);
          
          if (prob >= 58 && stats.shots >= 10) {
            const quotaStimata = (100 / prob).toFixed(2);
            alerts.push({
              match,
              type: 'over15',
              level: prob >= 70 ? 'high' : 'medium',
              pick: 'Over 1.5',
              prob: prob.toFixed(0),
              quota: quotaStimata,
              reason: `${stats.shots} tiri totali, partita sbloccata in arrivo`,
              stats
            });
          }
        }
        
        // ALERT 3: 1-1 partita aperta (Over 2.5)
        if (homeGoals === 1 && awayGoals === 1 && elapsed >= 50 && elapsed <= 85) {
          let prob = 55 + (stats.shotsOn * 1.5);
          if (elapsed >= 60) prob += 8;
          if (elapsed >= 70) prob += 5;
          prob = Math.min(82, prob);
          
          if (prob >= 55) {
            const quotaStimata = (100 / prob).toFixed(2);
            alerts.push({
              match,
              type: 'over25',
              level: prob >= 68 ? 'high' : 'medium',
              pick: 'Over 2.5',
              prob: prob.toFixed(0),
              quota: quotaStimata,
              reason: `Partita aperta, entrambe hanno giÃ  segnato`,
              stats
            });
          }
        }
        
        // ALERT 3b: 2-1 o 1-2 (Over 3.5 possibile)
        if ((homeGoals === 2 && awayGoals === 1) || (homeGoals === 1 && awayGoals === 2)) {
          if (elapsed >= 55 && elapsed <= 80) {
            let prob = 50 + stats.shotsOn * 1.5;
            if (elapsed >= 65) prob += 5;
            prob = Math.min(75, prob);
            
            if (prob >= 55 && stats.shotsOn >= 4) {
              alerts.push({
                match,
                type: 'over35',
                level: prob >= 65 ? 'high' : 'medium',
                pick: 'Over 3.5',
                prob: prob.toFixed(0),
                quota: (100 / prob).toFixed(2),
                reason: `Partita vivace (${homeGoals}-${awayGoals}), ${stats.shotsOn} tiri in porta`,
                stats
              });
            }
          }
        }
        
        // ALERT 4: Squadra domina ma non segna - Soglie abbassate
        if (totalGoals === 0 && elapsed >= 35 && elapsed <= 80) {
          const homeDominating = stats.shotsOnHome >= 3 && stats.possessionHome >= 55;
          const awayDominating = stats.shotsOnAway >= 3 && stats.possessionAway >= 55;
          
          if (homeDominating && stats.shotsOnHome > stats.shotsOnAway + 1) {
            let prob = 55 + stats.shotsOnHome * 4;
            prob = Math.min(88, prob);
            alerts.push({
              match,
              type: 'homeScores',
              level: prob >= 72 ? 'high' : 'medium',
              pick: `${match.home.name.substring(0,15)} Segna`,
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `Dominio: ${stats.shotsOnHome} tiri in porta, ${stats.possessionHome}% possesso`,
              stats
            });
          } else if (awayDominating && stats.shotsOnAway > stats.shotsOnHome + 1) {
            let prob = 50 + stats.shotsOnAway * 4;
            prob = Math.min(85, prob);
            alerts.push({
              match,
              type: 'awayScores',
              level: prob >= 70 ? 'high' : 'medium',
              pick: `${match.away.name.substring(0,15)} Segna`,
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `Dominio ospite: ${stats.shotsOnAway} tiri in porta, ${stats.possessionAway}% possesso`,
              stats
            });
          }
        }
        
        // ALERT 5: Intervallo con tanti tiri (Gol 2Â° Tempo) - Soglia abbassata
        if (match.status === 'HT' && totalGoals <= 2) {
          let prob = 50 + stats.shotsOn * 2.5;
          prob = Math.min(88, prob);
          
          if (prob >= 60 && stats.shotsOn >= 3) {
            alerts.push({
              match,
              type: 'goal2T',
              level: prob >= 72 ? 'high' : 'medium',
              pick: 'Gol 2Â° Tempo',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `${stats.shotsOn} tiri in porta nel 1Â° tempo - gol in arrivo!`,
              stats
            });
          }
        }
        
        // === ALERT PRIMO TEMPO ===
        
        // ALERT 6: Over 0.5 Primo Tempo (0-0 tra 20' e 45')
        if (totalGoals === 0 && elapsed >= 20 && elapsed <= 45 && match.status === '1H') {
          const pressure = stats.shotsOn * 2.5 + stats.corners * 0.5;
          let prob = 35 + (elapsed - 15) * 0.8 + pressure * 2;
          prob = Math.min(90, prob);
          
          if (prob >= 60 && stats.shotsOn >= 3) {
            alerts.push({
              match,
              type: 'over05_1T',
              level: prob >= 72 ? 'high' : 'medium',
              pick: 'Over 0.5 1Â°T',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `${stats.shotsOn} tiri in porta in ${elapsed}' - gol in arrivo!`,
              stats
            });
          }
        }
        
        // ALERT 7: Squadra Segna nel 1Â° Tempo (dominio evidente 15'-40')
        if (totalGoals === 0 && elapsed >= 15 && elapsed <= 40 && match.status === '1H') {
          const homeDominating = stats.shotsOnHome >= 3 && stats.possessionHome >= 55;
          const awayDominating = stats.shotsOnAway >= 3 && stats.possessionAway >= 55;
          
          if (homeDominating && stats.shotsOnHome > stats.shotsOnAway + 1) {
            let prob = 50 + stats.shotsOnHome * 5;
            prob = Math.min(85, prob);
            if (prob >= 60) {
              alerts.push({
                match,
                type: 'homeScores1T',
                level: prob >= 72 ? 'high' : 'medium',
                pick: `${match.home.name.substring(0,12)} Segna 1Â°T`,
                prob: prob.toFixed(0),
                quota: (100 / prob).toFixed(2),
                reason: `Dominio: ${stats.shotsOnHome} tiri in porta, ${stats.possessionHome}% possesso`,
                stats
              });
            }
          } else if (awayDominating && stats.shotsOnAway > stats.shotsOnHome + 1) {
            let prob = 45 + stats.shotsOnAway * 5;
            prob = Math.min(82, prob);
            if (prob >= 60) {
              alerts.push({
                match,
                type: 'awayScores1T',
                level: prob >= 70 ? 'high' : 'medium',
                pick: `${match.away.name.substring(0,12)} Segna 1Â°T`,
                prob: prob.toFixed(0),
                quota: (100 / prob).toFixed(2),
                reason: `Dominio ospite: ${stats.shotsOnAway} tiri in porta, ${stats.possessionAway}% possesso`,
                stats
              });
            }
          }
        }
        
        // ALERT 8: Over 1.5 Primo Tempo (1-0 o 0-1 tra 25' e 45')
        if (totalGoals === 1 && elapsed >= 25 && elapsed <= 45 && match.status === '1H') {
          let prob = 40 + stats.shotsOn * 2.5;
          if (stats.shotsOn >= 5) prob += 10;
          prob = Math.min(82, prob);
          
          if (prob >= 55 && stats.shotsOn >= 4) {
            alerts.push({
              match,
              type: 'over15_1T',
              level: prob >= 68 ? 'high' : 'medium',
              pick: 'Over 1.5 1Â°T',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `GiÃ  1 gol + ${stats.shotsOn} tiri in porta - altro gol probabile!`,
              stats
            });
          }
        }
        
        // ALERT 9: Gol nei primi minuti di ripresa (50'-60')
        if (totalGoals <= 1 && elapsed >= 50 && elapsed <= 65 && match.status === '2H') {
          let prob = 45 + stats.shotsOn * 2;
          if (totalGoals === 0) prob += 10;
          prob = Math.min(80, prob);
          
          if (prob >= 58 && stats.shotsOn >= 4) {
            alerts.push({
              match,
              type: 'earlyGoal2T',
              level: prob >= 68 ? 'high' : 'medium',
              pick: totalGoals === 0 ? 'Over 0.5' : 'Over 1.5',
              prob: prob.toFixed(0),
              quota: (100 / prob).toFixed(2),
              reason: `Inizio 2Â°T con ${stats.shotsOn} tiri - pressione alta!`,
              stats
            });
          }
        }
      });
      
      // Ordina per livello e probabilitÃ 
      alerts.sort((a, b) => {
        const levelOrder = { high: 0, medium: 1, low: 2 };
        if (levelOrder[a.level] !== levelOrder[b.level]) {
          return levelOrder[a.level] - levelOrder[b.level];
        }
        return parseFloat(b.prob) - parseFloat(a.prob);
      });
      
      state.liveAlerts = alerts;
    }
    
    // === LIVE BACKGROUND MONITORING ===
    function startLiveBackgroundMonitoring() {
      // Carica subito i dati LIVE
      loadLiveMatchesBackground();
      
      // Poi ogni 90 secondi in background
      state.liveBackgroundInterval = setInterval(() => {
        loadLiveMatchesBackground();
      }, 90000); // 90 secondi in background
    }
    
    async function loadLiveMatchesBackground() {
      try {
        const data = await callAPIFootball('/fixtures', { live: 'all' });
        
        if (data && data.response) {
          state.liveMatches = data.response.map(f => ({
            id: f.fixture.id,
            status: f.fixture.status.short,
            elapsed: f.fixture.status.elapsed || 0,
            league: {
              id: f.league.id,
              name: f.league.name,
              country: f.league.country,
              logo: f.league.logo
            },
            home: { id: f.teams.home.id, name: f.teams.home.name, logo: f.teams.home.logo },
            away: { id: f.teams.away.id, name: f.teams.away.name, logo: f.teams.away.logo },
            goals: { home: f.goals.home || 0, away: f.goals.away || 0 },
            stats: f.statistics || []
          }));
          
          // Calcola gli alert
          calculateLiveAlerts();
          
          // Aggiorna solo il badge senza re-renderizzare tutto
          updateLiveBadge();
        }
      } catch (e) {
        console.warn('Live background load error:', e);
      }
    }
    
    function updateLiveBadge() {
      const badge = document.querySelector('#liveTab');
      if (badge) {
        const alertCount = state.liveAlerts.length;
        const dot = '<span class="live-dot"></span>';
        const countBadge = alertCount > 0 ? `<span class="live-badge-count">${alertCount}</span>` : '';
        badge.innerHTML = `${dot} LIVE ${countBadge}`;
      }
    }
    
    function startLiveAutoRefresh() {
      if (state.liveInterval) return;
      
      // Countdown visivo
      state.liveCountdown = 60;
      state.countdownInterval = setInterval(() => {
        state.liveCountdown--;
        const countdownEl = document.querySelector('.live-countdown');
        if (countdownEl) {
          countdownEl.textContent = state.liveCountdown + 's';
        }
        if (state.liveCountdown <= 0) {
          state.liveCountdown = 60;
        }
      }, 1000);
      
      // Refresh dati ogni 60 secondi quando nella sezione LIVE
      state.liveInterval = setInterval(() => {
        if (state.liveMode) {
          loadLiveMatches();
          state.liveCountdown = 60;
        }
      }, 60000);
    }
    
    function stopLiveAutoRefresh() {
      if (state.liveInterval) {
        clearInterval(state.liveInterval);
        state.liveInterval = null;
      }
      if (state.countdownInterval) {
        clearInterval(state.countdownInterval);
        state.countdownInterval = null;
      }
    }
    
    function toggleLiveMode() {
      state.liveMode = !state.liveMode;
      if (state.liveMode) {
        loadLiveMatches();
        startLiveAutoRefresh();
      } else {
        stopLiveAutoRefresh();
      }
      render();
    }
    
    // === TRACKING PRONOSTICI ===
    
    function trackBet(type, matchId, matchName, pick, prob, odds, isLive = false) {
      const bet = {
        id: Date.now(),
        type, // 'prematch' o 'live'
        matchId,
        matchName,
        pick,
        prob: parseFloat(prob),
        odds: parseFloat(odds) || 0,
        isLive,
        timestamp: new Date().toISOString(),
        status: 'pending', // pending, won, lost
        result: null
      };
      
      state.trackedBets.push(bet);
      saveTrackedBets();
      
      // Salva anche su Firebase
      saveTrackingToFirebase();
      
      return bet;
    }
    
    // Funzione per tracking LIVE (chiamata da onclick)
    function trackLiveBet(matchId, matchName, pick, prob, odds, event) {
      event.stopPropagation();
      if (!state.trackedBets.some(b => b.matchId === matchId && b.isLive)) {
        trackBet('live', matchId, matchName, pick, prob, odds, true);
        render();
        alert('âœ… Pronostico LIVE tracciato!');
      }
    }
    
    // Funzione per tracking PRE-MATCH (chiamata da onclick)
    function trackPrematchBet(matchId, matchName, pick, prob, event) {
      event.stopPropagation();
      if (!state.trackedBets.some(b => b.matchId === matchId && b.type === 'prematch')) {
        trackBet('prematch', matchId, matchName, pick, prob, 0, false);
        render();
        alert('âœ… Pronostico tracciato!');
      }
    }
    
    function updateBetResult(betId, status, result) {
      const bet = state.trackedBets.find(b => b.id === betId);
      if (bet) {
        bet.status = status;
        bet.result = result;
        saveTrackedBets();
        saveTrackingToFirebase();
      }
    }
    
    function saveTrackedBets() {
      localStorage.setItem('bp_tracked', JSON.stringify(state.trackedBets));
    }
    
    async function saveTrackingToFirebase() {
      try {
        await fetch(`${CONFIG.FIREBASE.url}/tracking/${USER_ID}.json`, {
          method: 'PUT',
          body: JSON.stringify(state.trackedBets)
        });
      } catch (e) {
        console.warn('Firebase tracking save error:', e);
      }
    }
    
    async function loadTrackingFromFirebase() {
      try {
        const res = await fetch(`${CONFIG.FIREBASE.url}/tracking/${USER_ID}.json`);
        const data = await res.json();
        if (data && Array.isArray(data)) {
          state.trackedBets = data;
          saveTrackedBets();
        }
      } catch (e) {
        console.warn('Firebase tracking load error:', e);
      }
    }
    
    async function checkPendingResults() {
      const pending = state.trackedBets.filter(b => b.status === 'pending');
      
      for (const bet of pending) {
        try {
          const data = await callAPIFootball('/fixtures', { id: bet.matchId });
          if (data && data.response && data.response[0]) {
            const fixture = data.response[0];
            const status = fixture.fixture.status.short;
            
            // Solo se la partita Ã¨ finita
            if (['FT', 'AET', 'PEN'].includes(status)) {
              const homeGoals = fixture.goals.home;
              const awayGoals = fixture.goals.away;
              const totalGoals = homeGoals + awayGoals;
              const result = `${homeGoals}-${awayGoals}`;
              
              // Verifica se ha vinto
              let won = false;
              const pick = bet.pick.toLowerCase();
              
              if (pick.includes('over 0.5') && totalGoals >= 1) won = true;
              else if (pick.includes('over 1.5') && totalGoals >= 2) won = true;
              else if (pick.includes('over 2.5') && totalGoals >= 3) won = true;
              else if (pick.includes('over 3.5') && totalGoals >= 4) won = true;
              else if (pick.includes('under 2.5') && totalGoals < 3) won = true;
              else if (pick.includes('under 3.5') && totalGoals < 4) won = true;
              else if (pick.includes('gg') && homeGoals > 0 && awayGoals > 0) won = true;
              else if (pick.includes('ng') && (homeGoals === 0 || awayGoals === 0)) won = true;
              else if (pick === '1' && homeGoals > awayGoals) won = true;
              else if (pick === 'x' && homeGoals === awayGoals) won = true;
              else if (pick === '2' && homeGoals < awayGoals) won = true;
              else if (pick === '1x' && homeGoals >= awayGoals) won = true;
              else if (pick === 'x2' && homeGoals <= awayGoals) won = true;
              else if (pick.includes('segna') && totalGoals > 0) won = true;
              else if (pick.includes('gol 2Â°') && totalGoals > 0) won = true; // Semplificato
              
              updateBetResult(bet.id, won ? 'won' : 'lost', result);
            }
          }
        } catch (e) {
          console.warn('Check result error:', e);
        }
      }
      
      render();
    }
    
    function getTrackingStats() {
      const stats = {
        total: state.trackedBets.length,
        pending: state.trackedBets.filter(b => b.status === 'pending').length,
        won: state.trackedBets.filter(b => b.status === 'won').length,
        lost: state.trackedBets.filter(b => b.status === 'lost').length,
        byType: {},
        byPick: {}
      };
      
      // Win rate
      const completed = stats.won + stats.lost;
      stats.winRate = completed > 0 ? ((stats.won / completed) * 100).toFixed(1) : 0;
      
      // Per tipo (prematch vs live)
      ['prematch', 'live'].forEach(type => {
        const bets = state.trackedBets.filter(b => b.type === type);
        const won = bets.filter(b => b.status === 'won').length;
        const lost = bets.filter(b => b.status === 'lost').length;
        const total = won + lost;
        stats.byType[type] = {
          total: bets.length,
          won,
          lost,
          winRate: total > 0 ? ((won / total) * 100).toFixed(1) : 0
        };
      });
      
      // Per tipo di pick
      const pickTypes = ['over 0.5', 'over 1.5', 'over 2.5', 'over 3.5', 'gg', '1x', 'x2', 'segna', 'gol 2Â°'];
      pickTypes.forEach(pickType => {
        const bets = state.trackedBets.filter(b => b.pick.toLowerCase().includes(pickType));
        const won = bets.filter(b => b.status === 'won').length;
        const lost = bets.filter(b => b.status === 'lost').length;
        const total = won + lost;
        if (bets.length > 0) {
          stats.byPick[pickType] = {
            total: bets.length,
            won,
            lost,
            winRate: total > 0 ? ((won / total) * 100).toFixed(1) : 0
          };
        }
      });
      
      return stats;
    }
    
    function clearOldTrackedBets() {
      // Rimuove bet completati piÃ¹ vecchi di 30 giorni
      const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
      state.trackedBets = state.trackedBets.filter(b => {
        if (b.status === 'pending') return true;
        return new Date(b.timestamp).getTime() > thirtyDaysAgo;
      });
      saveTrackedBets();
    }
    
    function renderStatsModal() {
      const stats = getTrackingStats();
      const winRateClass = stats.winRate >= 65 ? 'good' : stats.winRate >= 50 ? 'medium' : 'bad';
      
      return `
        <div class="stats-modal" id="statsModal">
          <div class="stats-modal-content">
            <div class="stats-modal-header">
              <div class="stats-modal-title">ðŸ“Š Statistiche Pronostici</div>
              <button class="stats-modal-close" id="closeStats">Ã—</button>
            </div>
            <div class="stats-modal-body">
              <div class="stats-winrate-box">
                <div class="stats-winrate-big ${winRateClass}">${stats.winRate}%</div>
                <div class="stats-winrate-label">Win Rate Totale</div>
              </div>
              
              <div class="stats-grid">
                <div class="stats-grid-item">
                  <div class="stats-grid-value purple">${stats.total}</div>
                  <div class="stats-grid-label">Totali</div>
                </div>
                <div class="stats-grid-item">
                  <div class="stats-grid-value green">${stats.won}</div>
                  <div class="stats-grid-label">Vinti</div>
                </div>
                <div class="stats-grid-item">
                  <div class="stats-grid-value red">${stats.lost}</div>
                  <div class="stats-grid-label">Persi</div>
                </div>
                <div class="stats-grid-item">
                  <div class="stats-grid-value yellow">${stats.pending}</div>
                  <div class="stats-grid-label">In attesa</div>
                </div>
              </div>
              
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px;">
                <div class="stats-grid-item">
                  <div class="stats-grid-value" style="color: var(--accent-cyan);">${stats.byType.prematch?.winRate || 0}%</div>
                  <div class="stats-grid-label">PRE-MATCH (${stats.byType.prematch?.won || 0}/${(stats.byType.prematch?.won || 0) + (stats.byType.prematch?.lost || 0)})</div>
                </div>
                <div class="stats-grid-item">
                  <div class="stats-grid-value" style="color: var(--accent-red);">${stats.byType.live?.winRate || 0}%</div>
                  <div class="stats-grid-label">LIVE (${stats.byType.live?.won || 0}/${(stats.byType.live?.won || 0) + (stats.byType.live?.lost || 0)})</div>
                </div>
              </div>
              
              <div class="stats-by-pick">
                <div class="stats-pick-title">ðŸ“ˆ Win Rate per Mercato</div>
                ${Object.entries(stats.byPick).map(([pick, data]) => {
                  const rateClass = data.winRate >= 65 ? 'good' : data.winRate >= 50 ? 'medium' : 'bad';
                  return `
                    <div class="stats-pick-item">
                      <div class="stats-pick-name">${pick.toUpperCase()}</div>
                      <div class="stats-pick-rate ${rateClass}">${data.won}/${data.won + data.lost} (${data.winRate}%)</div>
                    </div>
                  `;
                }).join('') || '<div style="color: var(--text-dark); text-align: center; padding: 20px;">Nessun dato ancora</div>'}
              </div>
              
              <div class="stats-buttons">
                <button class="stats-btn stats-btn-check" id="checkResults">ðŸ”„ Verifica Risultati</button>
                <button class="stats-btn stats-btn-reset" id="resetStats">ðŸ—‘ï¸ Reset</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    
    // === RENDER ===
    function render() {
      document.getElementById('app').innerHTML = `
        ${renderHeader()}
        <main class="main">
          ${state.loading ? renderLoading() :
            state.view === 'leagues' ? renderLeagues() :
            state.view === 'matches' ? renderMatches() :
            renderAnalysis()}
        </main>
        ${renderSlipFloating()}
        ${state.slipModal ? renderSlipModal() : ''}
        ${state.statsModal ? renderStatsModal() : ''}
      `;
      attachEvents();
    }

    function renderHeader() {
      const stats = getTrackingStats();
      return `
        <header class="header">
          <div class="header-inner">
            <div class="brand">
              <div class="brand-icon">âš½</div>
              <span class="brand-name">BettingPro</span>
            </div>
            <div class="header-right">
              <div class="status-bar">
                <div class="status-item">
                  <span class="status-dot ${state.api.football}"></span>
                  <span>API</span>
                </div>
                <div class="status-item">
                  <span class="status-dot ${state.api.footystats}"></span>
                  <span>Stats</span>
                </div>
              </div>
              <div class="stats-badge" id="openStats">
                ðŸ“Š ${stats.won}/${stats.won + stats.lost} ${stats.winRate}%
              </div>
              <div class="slip-badge" id="openSlip">
                ðŸŽ« ${state.slip.length} pronostici
              </div>
            </div>
          </div>
        </header>
      `;
    }

    function renderLoading() {
      return `<div class="loading"><div class="spinner"></div><div class="loading-text">Caricamento...</div></div>`;
    }

    function renderLeagues() {
      const picks = state.dailyPicks;
      const money = getMoneyStats();
      
      return `
        <div class="date-tabs">
          <div class="date-tab live-tab ${state.liveMode ? 'active' : ''}" id="liveTab">
            <span class="live-dot"></span> LIVE ${state.liveAlerts.length > 0 ? `<span class="live-badge-count">${state.liveAlerts.length}</span>` : ''}
          </div>
          ${[-1, 0, 1, 2].map(d => `
            <div class="date-tab ${!state.liveMode && state.selectedDate === d ? 'active' : ''}" data-date="${d}">
              ${getDateLabel(d)} ${d !== 0 ? `(${formatDate(getDateString(d))})` : ''}
            </div>
          `).join('')}
        </div>
        
        ${state.liveMode ? renderLiveSection() : `
        <!-- MONEY MANAGEMENT - SISTEMA OBIETTIVO -->
        <div class="money-section">
          <div class="money-header">
            <div class="money-title">ðŸŽ¯ Sistema Obiettivo</div>
            <div class="money-subtitle">Raggiungi il tuo target in N giocate</div>
          </div>
          
          <!-- INPUTS -->
          <div class="money-grid-4">
            <div class="money-input-group">
              <label class="money-label">ðŸ’° Cassa Attuale</label>
              <input type="number" class="money-input" id="bankrollInput" value="${money.bankroll.toFixed(2)}" min="1" step="10">
            </div>
            <div class="money-input-group">
              <label class="money-label">ðŸ† Obiettivo</label>
              <input type="number" class="money-input" id="targetInput" value="${money.target}" min="10" step="50">
            </div>
            <div class="money-input-group">
              <label class="money-label">ðŸŽ² NÂ° Giocate</label>
              <input type="number" class="money-input" id="totalBetsInput" value="${money.totalBets}" min="1" max="50" step="1">
            </div>
            <div class="money-input-group">
              <label class="money-label">ðŸ“Š Quota</label>
              <input type="number" class="money-input" id="oddsInput" value="${money.currentOdds}" min="1.01" step="0.05">
            </div>
          </div>
          
          <!-- PROGRESS BAR -->
          <div class="progress-section">
            <div class="progress-bar-container">
              <div class="progress-bar-fill" style="width: ${money.progress}%"></div>
              <div class="progress-bar-text">â‚¬${money.bankroll.toFixed(0)} / â‚¬${money.target} (${money.progress.toFixed(1)}%)</div>
            </div>
          </div>
          
          <!-- CALCOLO PUNTATA -->
          <div class="stake-section ${money.reached ? 'reached' : ''} ${money.warning ? 'warning' : ''}">
            <div class="stake-header">
              <span class="stake-label">Giocata ${money.currentBet} di ${money.totalBets}</span>
              <span class="stake-remaining">${money.remainingBets} rimaste</span>
            </div>
            ${money.reached ? `
              <div class="stake-reached">ðŸ† OBIETTIVO RAGGIUNTO!</div>
            ` : `
              <div class="stake-value">
                <div class="stake-amount">â‚¬${money.stake.toFixed(2)}</div>
                <div class="stake-info">@ ${money.currentOdds} â†’ Vincita â‚¬${money.potentialWin.toFixed(2)}</div>
                ${money.warning ? `<div class="stake-warning">${money.warning}</div>` : ''}
              </div>
              <div class="stake-preview">
                Se vinci: <strong>â‚¬${money.newBankroll.toFixed(2)}</strong>
              </div>
            `}
            <div class="stake-buttons">
              <button class="stake-btn win" id="betWin">âœ… VINTO</button>
              <button class="stake-btn loss" id="betLoss">âŒ PERSO</button>
              <button class="stake-btn reset" id="betReset">ðŸ”„ Reset</button>
            </div>
          </div>
          
          <!-- STATS -->
          <div class="money-stats">
            <div class="money-stat">
              <div class="money-stat-label">Cassa</div>
              <div class="money-stat-value green">â‚¬${money.bankroll.toFixed(0)}</div>
            </div>
            <div class="money-stat">
              <div class="money-stat-label">Vinte</div>
              <div class="money-stat-value cyan">${money.wins}</div>
            </div>
            <div class="money-stat">
              <div class="money-stat-label">Perse</div>
              <div class="money-stat-value yellow">${money.losses}</div>
            </div>
            <div class="money-stat">
              <div class="money-stat-label">Win Rate</div>
              <div class="money-stat-value purple">${money.winRate}%</div>
            </div>
          </div>
        </div>
        
        <!-- HOME SECTIONS - PICKS DEL GIORNO -->
        <div class="home-sections">
          
          <!-- RADDOPPI DEL GIORNO (COMBINAZIONI) -->
          ${picks.raddoppi.length > 0 ? `
          <div class="picks-section raddoppi">
            <div class="picks-header">
              <div class="picks-title"><span class="picks-title-icon">ðŸ’°</span> Raddoppi del Giorno</div>
              <span class="picks-count">${picks.raddoppi.length} combo</span>
            </div>
            <div class="raddoppi-grid">
              ${picks.raddoppi.map((r, idx) => `
                <div class="raddoppio-card" data-raddoppio="${idx}">
                  <div class="raddoppio-header">
                    <span class="raddoppio-badge">ðŸŽ¯ ${r.size} partite</span>
                    <span class="raddoppio-odds">@${r.totalOdds}</span>
                  </div>
                  <div class="raddoppio-bets">
                    ${r.bets.map(b => `
                      <div class="raddoppio-bet">
                        <span class="raddoppio-match">${esc(b.shortName)}</span>
                        <span class="raddoppio-pick">${b.bet}</span>
                      </div>
                    `).join('')}
                  </div>
                  <div class="raddoppio-footer">
                    <span class="raddoppio-prob">${r.totalProb}% prob</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
          ` : ''}
          
          <!-- GG DEL GIORNO -->
          ${picks.gg.length > 0 ? `
          <div class="picks-section gg">
            <div class="picks-header">
              <div class="picks-title"><span class="picks-title-icon">âš½</span> GG del Giorno</div>
              <span class="picks-count">${picks.gg.length} picks</span>
            </div>
            <div class="picks-grid">
              ${picks.gg.map(p => `
                <div class="pick-card ${isInSlip(p.match.id, 'pick_GG') ? 'selected' : ''}" 
                     data-matchid="${p.match.id}" data-market="pick_GG" data-value="GG" data-prob="${p.prob.toFixed(0)}">
                  <div class="pick-info">
                    <div class="pick-match">${esc(p.match.home.name)} vs ${esc(p.match.away.name)}</div>
                    <div class="pick-league">${p.time} â€¢ ${esc(p.league)}</div>
                  </div>
                  <div class="pick-bet">
                    <span class="pick-value">GG</span>
                    <span class="pick-prob">${p.prob.toFixed(0)}%</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
          ` : ''}
          
          <!-- OVER 2.5 DEL GIORNO -->
          ${picks.over25.length > 0 ? `
          <div class="picks-section over">
            <div class="picks-header">
              <div class="picks-title"><span class="picks-title-icon">ðŸ”¥</span> Over 2.5 del Giorno</div>
              <span class="picks-count">${picks.over25.length} picks</span>
            </div>
            <div class="picks-grid">
              ${picks.over25.map(p => `
                <div class="pick-card ${isInSlip(p.match.id, 'pick_O25') ? 'selected' : ''}" 
                     data-matchid="${p.match.id}" data-market="pick_O25" data-value="Over 2.5" data-prob="${p.prob.toFixed(0)}">
                  <div class="pick-info">
                    <div class="pick-match">${esc(p.match.home.name)} vs ${esc(p.match.away.name)}</div>
                    <div class="pick-league">${p.time} â€¢ xG: ${p.xgTotal}</div>
                  </div>
                  <div class="pick-bet">
                    <span class="pick-value">O 2.5</span>
                    <span class="pick-prob">${p.prob.toFixed(0)}%</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
          ` : ''}
          
          <!-- X DEL GIORNO -->
          ${picks.pareggi.length > 0 ? `
          <div class="picks-section pareggi">
            <div class="picks-header">
              <div class="picks-title"><span class="picks-title-icon">ðŸŽ²</span> X del Giorno</div>
              <span class="picks-count">${picks.pareggi.length} picks</span>
            </div>
            <div class="picks-grid">
              ${picks.pareggi.map(p => `
                <div class="pick-card ${isInSlip(p.match.id, 'pick_X') ? 'selected' : ''}" 
                     data-matchid="${p.match.id}" data-market="pick_X" data-value="X" data-prob="${p.prob.toFixed(0)}">
                  <div class="pick-info">
                    <div class="pick-match">${esc(p.match.home.name)} vs ${esc(p.match.away.name)}</div>
                    <div class="pick-league">${p.time} â€¢ ${esc(p.league)}</div>
                  </div>
                  <div class="pick-bet">
                    <span class="pick-value">X</span>
                    <span class="pick-prob">${p.prob.toFixed(0)}%</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
          ` : ''}
          
          <!-- OVER 1Â° TEMPO DEL GIORNO -->
          ${picks.over1T.length > 0 ? `
          <div class="picks-section over1t">
            <div class="picks-header">
              <div class="picks-title"><span class="picks-title-icon">â±ï¸</span> Over 1Â° Tempo</div>
              <span class="picks-count">${picks.over1T.length} picks</span>
            </div>
            <div class="picks-grid">
              ${picks.over1T.map(p => `
                <div class="pick-card ${isInSlip(p.match.id, 'pick_'+p.bet.replace(/\s+/g,'')) ? 'selected' : ''}" 
                     data-matchid="${p.match.id}" data-market="pick_${p.bet.replace(/\s+/g,'')}" data-value="${p.bet}" data-prob="${p.prob.toFixed(0)}">
                  <div class="pick-info">
                    <div class="pick-match">${esc(p.match.home.name)} vs ${esc(p.match.away.name)}</div>
                    <div class="pick-league">${p.time} â€¢ xG: ${p.xgTotal}</div>
                  </div>
                  <div class="pick-bet">
                    <span class="pick-value">${p.bet}</span>
                    <span class="pick-prob">${p.prob.toFixed(0)}%</span>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
          ` : ''}
        </div>
        
        <!-- SELEZIONA CAMPIONATO -->
        <div class="panel">
          <div class="panel-title">ðŸ“‹ Seleziona Campionato (${state.matches.length} partite)</div>
          ${state.leagues.length === 0 ? `<div class="empty"><div class="empty-icon">ðŸ“­</div>Nessuna partita</div>` : `
            <select class="select-field" id="leagueSelect">
              <option value="">-- Scegli un campionato --</option>
              ${state.leagues.map(l => `<option value="${l.id}">${esc(l.country)} - ${esc(l.name)} (${l.matchCount})</option>`).join('')}
            </select>
          `}
        </div>
      `}
      `;
    }
    
    function renderLiveSection() {
      if (state.liveLoading) {
        return `
          <div class="live-section">
            <div class="live-header">
              <div class="live-title"><span class="live-dot"></span> LIVE Alerts</div>
            </div>
            <div class="loading"><div class="spinner"></div><div class="loading-text">Caricamento partite live...</div></div>
          </div>
        `;
      }
      
      const alerts = state.liveAlerts;
      
      return `
        <div class="live-section">
          <div class="live-header">
            <div class="live-title"><span class="live-dot"></span> LIVE Alerts</div>
            <div style="display: flex; align-items: center; gap: 12px;">
              <div class="live-auto-refresh">ðŸ”„ Auto-refresh <span class="live-countdown">${state.liveCountdown}s</span></div>
              <button class="live-refresh-btn" id="refreshLive">âŸ³ Aggiorna</button>
            </div>
          </div>
          
          ${alerts.length === 0 ? `
            <div class="live-empty">
              <div class="live-empty-icon">ðŸ“¡</div>
              <div>Nessun alert al momento</div>
              <div style="font-size: 0.8rem; margin-top: 8px; color: var(--text-dark);">
                ${state.liveMatches.length} partite live monitorate
              </div>
            </div>
          ` : `
            <div class="live-alerts-grid">
              ${alerts.map(alert => `
                <div class="live-alert-card ${alert.level}">
                  <div class="live-alert-header">
                    <div class="live-alert-level">${alert.level === 'high' ? 'ðŸš¨ ALERT ALTO' : alert.level === 'medium' ? 'âš ï¸ ALERT MEDIO' : 'ðŸ”µ INFO'}</div>
                    <div class="live-alert-time"><span class="live-dot"></span> ${alert.match.elapsed}'</div>
                  </div>
                  <div class="live-alert-body">
                    <div class="live-alert-match">
                      <div class="live-alert-teams">${esc(alert.match.home.name)} vs ${esc(alert.match.away.name)}</div>
                      <div class="live-alert-score">${alert.match.goals.home} - ${alert.match.goals.away}</div>
                    </div>
                    <div class="live-alert-stats">
                      <div class="live-stat">ðŸŽ¯ Tiri in porta: <strong>${alert.stats.shotsOnHome || 0}-${alert.stats.shotsOnAway || 0}</strong></div>
                      <div class="live-stat">âš½ Tiri totali: <strong>${alert.stats.shotsHome || 0}-${alert.stats.shotsAway || 0}</strong></div>
                      <div class="live-stat">ðŸš© Corner: <strong>${alert.stats.cornersHome || 0}-${alert.stats.cornersAway || 0}</strong></div>
                      <div class="live-stat">ðŸ“Š Possesso: <strong>${alert.stats.possessionHome || 50}%-${alert.stats.possessionAway || 50}%</strong></div>
                    </div>
                    <div class="live-alert-pick">
                      <div class="live-pick-label">CONSIGLIO LIVE</div>
                      <div class="live-pick-value">${alert.pick}</div>
                      <div class="live-pick-details">
                        <span class="live-pick-prob">ðŸ“ˆ ${alert.prob}% prob</span>
                        <span style="color: var(--accent-yellow);">ðŸ’° ~@${alert.quota}</span>
                      </div>
                      <div class="live-pick-reason">ðŸ’¡ ${alert.reason}</div>
                      <button class="live-track-btn ${state.trackedBets.some(b => b.matchId === alert.match.id && b.isLive) ? 'tracked' : ''}"
                              data-matchid="${alert.match.id}"
                              data-matchname="${esc(alert.match.home.name)} vs ${esc(alert.match.away.name)}"
                              data-pick="${esc(alert.pick)}"
                              data-prob="${alert.prob}"
                              data-odds="${alert.quota}"
                              ${state.trackedBets.some(b => b.matchId === alert.match.id && b.isLive) ? 'disabled' : ''}>
                        ${state.trackedBets.some(b => b.matchId === alert.match.id && b.isLive) ? 'âœ… Tracciato' : 'ðŸŽ¯ GIOCATO'}
                      </button>
                    </div>
                  </div>
                </div>
              `).join('')}
            </div>
          `}
          
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border);">
            <div style="font-size: 0.8rem; color: var(--text-dark); margin-bottom: 8px;">ðŸ“Š Statistiche Monitorate</div>
            <div style="display: flex; gap: 16px; flex-wrap: wrap; font-size: 0.85rem; color: var(--text-gray);">
              <span>ðŸ”´ Partite LIVE: <strong style="color: var(--text-white);">${state.liveMatches.length}</strong></span>
              <span>ðŸš¨ Alert Alti: <strong style="color: var(--accent-red);">${alerts.filter(a => a.level === 'high').length}</strong></span>
              <span>âš ï¸ Alert Medi: <strong style="color: var(--accent-yellow);">${alerts.filter(a => a.level === 'medium').length}</strong></span>
            </div>
          </div>
        </div>
      `;
    }

    function renderMatches() {
      const matches = state.matches.filter(m => m.league.id === state.selectedLeague.id).sort((a, b) => a.timestamp - b.timestamp);
      
      return `
        <div class="back-btn" id="backToLeagues">â† Campionati</div>
        <div class="panel">
          <div class="panel-title">âš½ ${esc(state.selectedLeague.country)} - ${esc(state.selectedLeague.name)}</div>
          <div class="matches-list">
            ${matches.map(m => {
              const isLive = ['1H','2H','HT','ET','P','LIVE'].includes(m.status);
              return `
                <div class="match-item" data-id="${m.id}">
                  <div class="match-item-left">
                    <div class="match-item-time">${isLive ? m.elapsed+"'" : formatTime(m.date)}</div>
                    <div class="match-item-teams">${esc(m.home.name)} vs ${esc(m.away.name)}</div>
                  </div>
                  <div class="match-item-badge ${isLive ? 'live' : ''}">${isLive ? 'LIVE' : formatDate(m.date)}</div>
                </div>
              `;
            }).join('')}
          </div>
        </div>
      `;
    }

    function renderAnalysis() {
      const m = state.selectedMatch;
      const d = state.analysis;
      if (!d) return `<div class="back-btn" id="backToMatches">â† Partite</div><div class="empty">Errore analisi</div>`;
      
      // Genera consiglio AI
      const ai = generateAIAdvice(m, d);
      
      return `
        <div class="back-btn" id="backToMatches">â† Partite</div>
        
        <div class="analysis-hero">
          <div class="hero-league">${esc(m.league.country)} â€¢ ${esc(m.league.name)} â€¢ ${formatDateFull(m.date)} ${formatTime(m.date)}</div>
          <div class="hero-match">
            <div class="hero-team">
              ${m.home.logo ? `<img src="${m.home.logo}" class="hero-team-logo" onerror="this.style.display='none'">` : `<div class="hero-team-logo-fallback">${getInitials(m.home.name)}</div>`}
              <div class="hero-team-name">${esc(m.home.name)}</div>
            </div>
            <div class="hero-prediction">
              <div class="hero-score-box">${d.exactScores[0].h}</div>
              <div class="hero-vs">VS</div>
              <div class="hero-score-box">${d.exactScores[0].a}</div>
            </div>
            <div class="hero-team">
              ${m.away.logo ? `<img src="${m.away.logo}" class="hero-team-logo" onerror="this.style.display='none'">` : `<div class="hero-team-logo-fallback">${getInitials(m.away.name)}</div>`}
              <div class="hero-team-name">${esc(m.away.name)}</div>
            </div>
          </div>
        </div>
        
        <!-- AI CONSIGLIO -->
        <div class="ai-advice">
          <div class="ai-header">
            <div class="ai-icon">ðŸ¤–</div>
            <div class="ai-title-group">
              <div class="ai-title">Consiglio AI</div>
              <div class="ai-subtitle">Analisi basata su xG, statistiche e probabilitÃ </div>
            </div>
            <div class="ai-confidence ${ai.confidence}">${ai.confidence === 'high' ? 'ðŸŽ¯ Alta' : ai.confidence === 'medium' ? 'âœ“ Media' : 'âš ï¸ Bassa'}</div>
          </div>
          
          <div class="ai-pick">
            <div class="ai-pick-label">Pronostico Consigliato</div>
            <div class="ai-pick-value">${ai.pick}</div>
            <div class="ai-pick-prob">${ai.prob.toFixed(0)}% probabilitÃ </div>
          </div>
          
          <div class="ai-reasoning">
            <div class="ai-reasoning-title">ðŸ’¡ PerchÃ© questo pronostico</div>
            <div class="ai-reasoning-list">
              ${ai.reasons.map(r => `
                <div class="ai-reason ${r.type}">
                  <span class="ai-reason-icon">${r.type === 'positive' ? 'âœ…' : r.type === 'negative' ? 'âŒ' : r.type === 'warning' ? 'âš ï¸' : 'ðŸ“Š'}</span>
                  <span>${r.text}</span>
                </div>
              `).join('')}
            </div>
          </div>
          
          ${ai.alternatives.length > 0 ? `
            <div class="ai-alternatives">
              <div class="ai-alt-title">Alternative valide:</div>
              <div class="ai-alt-grid">
                ${ai.alternatives.map(a => `
                  <div class="ai-alt-chip">${a.pick}<span>${a.prob}%</span></div>
                `).join('')}
              </div>
            </div>
          ` : ''}
          
          <button class="track-btn ${state.trackedBets.some(b => b.matchId === m.id && b.type === 'prematch') ? 'tracked' : ''}" 
                  data-matchid="${m.id}"
                  data-matchname="${esc(m.home.name)} vs ${esc(m.away.name)}"
                  data-pick="${esc(ai.pick)}"
                  data-prob="${ai.prob.toFixed(0)}"
                  ${state.trackedBets.some(b => b.matchId === m.id && b.type === 'prematch') ? 'disabled' : ''}>
            ${state.trackedBets.some(b => b.matchId === m.id && b.type === 'prematch') ? 'âœ… Pronostico Tracciato' : 'ðŸŽ¯ GIOCATO - Traccia questo pronostico'}
          </button>
        </div>
        
        <div class="comparison-panel">
          <div class="comparison-title">ðŸ”® Confronto Pronostici</div>
          <div class="comparison-grid">
            <div class="comparison-box ai">
              <div class="comparison-box-header">ðŸ¤– ALGORITMO AI</div>
              <div class="comparison-box-pick">${ai.pick.split(' (')[0]}</div>
              <div class="comparison-box-prob">${ai.prob.toFixed(0)}%</div>
              <div class="comparison-box-basis">Basato su: xG, Dixon-Coles, Form, H2H</div>
            </div>
            <div class="comparison-vs">VS</div>
            <div class="comparison-box stats">
              <div class="comparison-box-header">ðŸ“Š STATISTICHE PURE</div>
              ${(() => {
                // Calcola pronostico statistiche pure (basato solo su medie, non xG)
                const statsPicks = [
                  { pick: 'Over 2.5', prob: d.pOU[2.5].over },
                  { pick: 'Under 2.5', prob: d.pOU[2.5].under },
                  { pick: 'GG', prob: d.pBTTS },
                  { pick: 'NG', prob: 100 - d.pBTTS },
                  { pick: 'Over 1.5', prob: d.pOU[1.5].over }
                ];
                const bestStats = statsPicks.sort((a, b) => b.prob - a.prob)[0];
                return `
                  <div class="comparison-box-pick">${bestStats.pick}</div>
                  <div class="comparison-box-prob">${bestStats.prob.toFixed(0)}%</div>
                  <div class="comparison-box-basis">Basato su: Medie gol, % storiche</div>
                `;
              })()}
            </div>
          </div>
          <div class="comparison-verdict">
            ${ai.pick.includes('Over') || ai.pick.includes('GG') ? 
              (d.pOU[2.5].over >= 55 || d.pBTTS >= 55 ? 
                'âœ… <strong>AI e Statistiche concordano:</strong> partita da gol!' : 
                'âš ï¸ <strong>Attenzione:</strong> AI e Statistiche in disaccordo') :
              (ai.prob >= 70 ? 
                'âœ… <strong>Pronostico solido:</strong> AI sicura al ' + ai.prob.toFixed(0) + '%' : 
                'ðŸ“Š <strong>Valuta entrambi:</strong> confronta prima di scommettere')}
          </div>
        </div>
        
        <div class="analysis-grid">
          <div class="analysis-card">
            <div class="card-title">
              <div class="card-title-icon">ðŸ“Š</div>
              <span>Expected Goals</span>
              <span class="card-title-badge">${d.xG.total.toFixed(2)}</span>
            </div>
            <div class="prob-row">
              <span class="prob-label">${m.home.name.split(' ')[0]}</span>
              <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${(d.xG.home/3)*100}%"></div></div>
              <span class="prob-value">${d.xG.home.toFixed(2)}</span>
            </div>
            <div class="prob-row">
              <span class="prob-label">${m.away.name.split(' ')[0]}</span>
              <div class="prob-bar-track"><div class="prob-bar-fill green" style="width:${(d.xG.away/3)*100}%"></div></div>
              <span class="prob-value">${d.xG.away.toFixed(2)}</span>
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">ðŸŽ¯</div><span>1X2</span></div>
            <div class="prob-row">
              <span class="prob-label">1 Casa</span>
              <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${d.p1X2.home}%"></div></div>
              <span class="prob-value">${d.p1X2.home.toFixed(0)}%</span>
            </div>
            <div class="prob-row">
              <span class="prob-label">X Pari</span>
              <div class="prob-bar-track"><div class="prob-bar-fill yellow" style="width:${d.p1X2.draw}%"></div></div>
              <span class="prob-value">${d.p1X2.draw.toFixed(0)}%</span>
            </div>
            <div class="prob-row">
              <span class="prob-label">2 Ospite</span>
              <div class="prob-bar-track"><div class="prob-bar-fill purple" style="width:${d.p1X2.away}%"></div></div>
              <span class="prob-value">${d.p1X2.away.toFixed(0)}%</span>
            </div>
          </div>
          
          <div class="analysis-card">
            <div class="card-title"><div class="card-title-icon">âš½</div><span>Over/Under & GG</span></div>
            ${[1.5, 2.5, 3.5].map(l => `
              <div class="prob-row">
                <span class="prob-label">O/U ${l}</span>
                <div class="prob-bar-track"><div class="prob-bar-fill cyan" style="width:${d.pOU[l].over}%"></div></div>
                <span class="prob-value">${d.pOU[l].over.toFixed(0)}%</span>
              </div>
            `).join('')}
            <div class="prob-row">
              <span class="prob-label">GG</span>
              <div class="prob-bar-track"><div class="prob-bar-fill green" style="width:${d.pBTTS}%"></div></div>
              <span class="prob-value">${d.pBTTS.toFixed(0)}%</span>
            </div>
          </div>
          
          <div class="analysis-card wide">
            <div class="card-title"><div class="card-title-icon">ðŸ“</div><span>Corner & Cartellini - Pronostici</span></div>
            <div class="corner-cards-grid">
              <div class="corner-section">
                <div class="corner-header">ðŸš© CORNER</div>
                <div class="corner-pick">
                  <span class="corner-pick-value">Over ${d.corners.total >= 10 ? '10.5' : d.corners.total >= 9 ? '9.5' : '8.5'}</span>
                  <span class="corner-pick-prob ${d.corners.probs[d.corners.total >= 10 ? 10.5 : d.corners.total >= 9 ? 9.5 : 8.5]?.over >= 60 ? 'high' : 'medium'}">${(d.corners.probs[d.corners.total >= 10 ? 10.5 : d.corners.total >= 9 ? 9.5 : 8.5]?.over || 50).toFixed(0)}%</span>
                </div>
                <div class="corner-stats">
                  <div class="corner-stat"><span>Casa:</span><strong>${d.corners.home.toFixed(1)}</strong></div>
                  <div class="corner-stat"><span>Ospite:</span><strong>${d.corners.away.toFixed(1)}</strong></div>
                  <div class="corner-stat total"><span>Media Tot:</span><strong>${d.corners.total.toFixed(1)}</strong></div>
                </div>
              </div>
              <div class="cards-section">
                <div class="cards-header">ðŸŸ¨ CARTELLINI</div>
                <div class="cards-pick">
                  <span class="cards-pick-value">Over ${d.cards.total >= 4.5 ? '4.5' : d.cards.total >= 4 ? '3.5' : '2.5'}</span>
                  <span class="cards-pick-prob ${d.cards.probs[d.cards.total >= 4.5 ? 4.5 : d.cards.total >= 4 ? 3.5 : 2.5]?.over >= 60 ? 'high' : 'medium'}">${(d.cards.probs[d.cards.total >= 4.5 ? 4.5 : d.cards.total >= 4 ? 3.5 : 2.5]?.over || 50).toFixed(0)}%</span>
                </div>
                <div class="cards-stats">
                  <div class="cards-stat"><span>Casa:</span><strong>${d.cards.home.toFixed(1)}</strong></div>
                  <div class="cards-stat"><span>Ospite:</span><strong>${d.cards.away.toFixed(1)}</strong></div>
                  <div class="cards-stat total"><span>Media Tot:</span><strong>${d.cards.total.toFixed(1)}</strong></div>
                </div>
              </div>
            </div>
          </div>
          
          <div class="analysis-card wide">
            <div class="card-title"><div class="card-title-icon">ðŸŽ²</div><span>Risultati Esatti</span></div>
            <div class="scores-grid">
              ${d.exactScores.map((s, i) => `
                <div class="score-box ${i === 0 ? 'highlight' : ''}">
                  <div class="score-box-value">${s.h}-${s.a}</div>
                  <div class="score-box-prob">${s.p.toFixed(1)}%</div>
                </div>
              `).join('')}
            </div>
          </div>
        </div>
        
        <div class="predictions-panel">
          <div class="predictions-header">
            <div class="predictions-title">âš½ PRONOSTICI AI</div>
            <div class="predictions-subtitle">Clicca per aggiungere alla schedina</div>
            <div class="predictions-legend">
              <div class="legend-item"><span class="legend-dot high"></span> Alta (>65%)</div>
              <div class="legend-item"><span class="legend-dot mid"></span> Media (50-65%)</div>
              <div class="legend-item"><span class="legend-dot low"></span> Bassa (<50%)</div>
            </div>
          </div>
          <div class="predictions-grid">
            ${d.predictions.map(p => `
              <div class="prediction-card ${isInSlip(m.id, p.market) ? 'selected' : ''}" data-market="${p.market}" data-value="${p.value}" data-prob="${p.prob.toFixed(0)}">
                <div class="prediction-market">${p.market}</div>
                <div class="prediction-value">${p.value}</div>
                <div class="prediction-prob ${getProbClass(p.prob)}">${p.prob.toFixed(0)}%</div>
              </div>
            `).join('')}
          </div>
        </div>
      `;
    }

    function renderSlipFloating() {
      if (state.slip.length === 0) return '';
      return `
        <div class="slip-floating">
          <div class="slip-count">ðŸŽ« ${state.slip.length} pronostici</div>
          <button class="slip-btn primary" id="viewSlip">ðŸ“‹ Vedi</button>
          <button class="slip-btn secondary" id="copySlip">ðŸ“‹ Copia</button>
          <button class="slip-btn danger" id="clearSlip">ðŸ—‘ï¸</button>
        </div>
      `;
    }

    function renderSlipModal() {
      const totalProb = state.slip.reduce((acc, s) => acc * (s.prob / 100), 1) * 100;
      return `
        <div class="slip-modal" id="slipModal">
          <div class="slip-modal-content">
            <div class="slip-modal-header">
              <div class="slip-modal-title">ðŸŽ« La Tua Schedina</div>
              <button class="slip-modal-close" id="closeSlip">Ã—</button>
            </div>
            <div class="slip-modal-body">
              ${state.slip.map(s => `
                <div class="slip-item">
                  <div class="slip-item-info">
                    <div class="slip-item-match">${esc(s.matchName)}</div>
                    <div class="slip-item-bet">${s.market}: ${s.value}</div>
                    <div class="slip-item-prob">${s.prob}%</div>
                  </div>
                  <button class="slip-item-remove" data-key="${s.key}">Ã—</button>
                </div>
              `).join('')}
              <div class="slip-total">
                <div class="slip-total-label">ProbabilitÃ  Combinata</div>
                <div class="slip-total-value">${totalProb.toFixed(2)}%</div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function attachEvents() {
      // Stats Modal
      document.getElementById('openStats')?.addEventListener('click', () => {
        state.statsModal = true;
        render();
      });
      document.getElementById('closeStats')?.addEventListener('click', () => {
        state.statsModal = false;
        render();
      });
      document.getElementById('statsModal')?.addEventListener('click', (e) => {
        if (e.target.id === 'statsModal') {
          state.statsModal = false;
          render();
        }
      });
      document.getElementById('checkResults')?.addEventListener('click', async () => {
        await checkPendingResults();
        render();
      });
      document.getElementById('resetStats')?.addEventListener('click', () => {
        if (confirm('Sei sicuro di voler cancellare tutte le statistiche?')) {
          state.trackedBets = [];
          saveTrackedBets();
          saveTrackingToFirebase();
          render();
        }
      });
      
      // Track buttons - PRE-MATCH
      document.querySelectorAll('.track-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const matchId = parseInt(btn.dataset.matchid);
          const matchName = btn.dataset.matchname;
          const pick = btn.dataset.pick;
          const prob = btn.dataset.prob;
          const odds = btn.dataset.odds || 0;
          
          if (!state.trackedBets.some(b => b.matchId === matchId && b.type === 'prematch')) {
            trackBet('prematch', matchId, matchName, pick, prob, odds, false);
            btn.classList.add('tracked');
            btn.textContent = 'âœ… Pronostico Tracciato';
            btn.disabled = true;
            alert('âœ… Pronostico tracciato! Controlla le statistiche nel badge ðŸ“Š');
          }
        });
      });
      
      // Track buttons - LIVE
      document.querySelectorAll('.live-track-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const matchId = parseInt(btn.dataset.matchid);
          const matchName = btn.dataset.matchname;
          const pick = btn.dataset.pick;
          const prob = btn.dataset.prob;
          const odds = btn.dataset.odds || 0;
          
          if (!state.trackedBets.some(b => b.matchId === matchId && b.isLive)) {
            trackBet('live', matchId, matchName, pick, prob, odds, true);
            btn.classList.add('tracked');
            btn.textContent = 'âœ… Tracciato';
            btn.disabled = true;
            alert('âœ… Pronostico LIVE tracciato! Controlla le statistiche nel badge ðŸ“Š');
          }
        });
      });
      
      // LIVE Tab
      document.getElementById('liveTab')?.addEventListener('click', toggleLiveMode);
      document.getElementById('refreshLive')?.addEventListener('click', loadLiveMatches);
      
      // Date tabs
      document.querySelectorAll('.date-tab[data-date]').forEach(tab => {
        tab.addEventListener('click', () => {
          if (state.liveMode) {
            state.liveMode = false;
            stopLiveAutoRefresh();
          }
          loadMatches(parseInt(tab.dataset.date));
        });
      });
      
      // League select
      document.getElementById('leagueSelect')?.addEventListener('change', e => {
        const id = parseInt(e.target.value);
        if (id) {
          state.selectedLeague = state.leagues.find(l => l.id === id);
          state.view = 'matches';
          render();
        }
      });
      
      // Back buttons
      document.getElementById('backToLeagues')?.addEventListener('click', () => {
        state.view = 'leagues';
        state.selectedLeague = null;
        render();
      });
      
      document.getElementById('backToMatches')?.addEventListener('click', () => {
        state.view = 'matches';
        state.selectedMatch = null;
        state.analysis = null;
        render();
      });
      
      // Match items
      document.querySelectorAll('.match-item').forEach(el => {
        el.addEventListener('click', () => {
          const m = state.matches.find(x => x.id === parseInt(el.dataset.id));
          if (m) analyzeMatch(m);
        });
      });
      
      // PICK CARDS nella home - aggiungi alla schedina
      document.querySelectorAll('.pick-card').forEach(el => {
        el.addEventListener('click', () => {
          const matchId = parseInt(el.dataset.matchid);
          const match = state.matches.find(m => m.id === matchId);
          if (match) {
            addToSlip(match, el.dataset.market, el.dataset.value, parseFloat(el.dataset.prob));
          }
        });
      });
      
      // RADDOPPI COMBINATI - aggiungi tutte le scommesse alla schedina
      document.querySelectorAll('.raddoppio-card').forEach(el => {
        el.addEventListener('click', () => {
          const idx = parseInt(el.dataset.raddoppio);
          const raddoppio = state.dailyPicks.raddoppi[idx];
          if (raddoppio) {
            raddoppio.bets.forEach(b => {
              addToSlip(b.match, 'radd_' + b.bet, b.bet, b.prob);
            });
          }
        });
      });
      
      // Predictions click to add (nella pagina analisi)
      document.querySelectorAll('.prediction-card, .combo-card').forEach(el => {
        el.addEventListener('click', () => {
          const m = state.selectedMatch;
          if (m) addToSlip(m, el.dataset.market, el.dataset.value, parseFloat(el.dataset.prob));
        });
      });
      
      // MONEY MANAGEMENT
      document.getElementById('bankrollInput')?.addEventListener('change', e => {
        state.money.bankroll = parseFloat(e.target.value) || 100;
        saveMoney();
        render();
      });
      
      document.getElementById('targetInput')?.addEventListener('change', e => {
        state.money.target = parseFloat(e.target.value) || 500;
        saveMoney();
        render();
      });
      
      document.getElementById('totalBetsInput')?.addEventListener('change', e => {
        state.money.totalBets = parseInt(e.target.value) || 10;
        saveMoney();
        render();
      });
      
      document.getElementById('oddsInput')?.addEventListener('change', e => {
        state.money.currentOdds = parseFloat(e.target.value) || 1.80;
        saveMoney();
        render();
      });
      
      // BET RESULT BUTTONS
      document.getElementById('betWin')?.addEventListener('click', () => recordBetResult(true));
      document.getElementById('betLoss')?.addEventListener('click', () => recordBetResult(false));
      document.getElementById('betReset')?.addEventListener('click', resetMoney);
      
      // Slip actions
      document.getElementById('openSlip')?.addEventListener('click', () => { state.slipModal = true; render(); });
      document.getElementById('viewSlip')?.addEventListener('click', () => { state.slipModal = true; render(); });
      document.getElementById('closeSlip')?.addEventListener('click', () => { state.slipModal = false; render(); });
      document.getElementById('slipModal')?.addEventListener('click', e => { if (e.target.id === 'slipModal') { state.slipModal = false; render(); }});
      document.getElementById('clearSlip')?.addEventListener('click', clearSlip);
      
      document.getElementById('copySlip')?.addEventListener('click', () => {
        const text = state.slip.map(s => `${s.matchName}: ${s.market} ${s.value} (${s.prob}%)`).join('\n');
        navigator.clipboard.writeText(text);
        alert('Schedina copiata!');
      });
      
      // Remove from slip
      document.querySelectorAll('.slip-item-remove').forEach(btn => {
        btn.addEventListener('click', () => removeFromSlip(btn.dataset.key));
      });
    }

    // === INIT ===
    async function init() {
      console.log('ðŸš€ BettingPro v5 starting...');
      await loadSlipFromFirebase();
      await loadTrackingFromFirebase();
      render();
      await loadMatches(0);
      
      // Avvia monitoraggio LIVE in background
      startLiveBackgroundMonitoring();
      console.log('ðŸ“¡ LIVE background monitoring started');
      
      // Verifica risultati pending ogni 5 minuti
      setInterval(checkPendingResults, 5 * 60 * 1000);
    }

    init();
  </script>
</body>
</html>
